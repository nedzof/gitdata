import { Chain } from '../../../../sdk';
import { InsertHeaderResult, ChaintracksStorageBaseOptions, ChaintracksStorageIngestApi, ChaintracksStorageQueryApi } from '../Api/ChaintracksStorageApi';
import { BaseBlockHeader, BlockHeader, LiveBlockHeader } from '../Api/BlockHeaderApi';
import { HeightRange } from '../util/HeightRange';
import { BulkFileDataManager } from '../util/BulkFileDataManager';
/**
 * Required interface methods of a Chaintracks Storage Engine implementation.
 */
export declare abstract class ChaintracksStorageBase implements ChaintracksStorageQueryApi, ChaintracksStorageIngestApi {
    static createStorageBaseOptions(chain: Chain): ChaintracksStorageBaseOptions;
    log: (...args: any[]) => void;
    chain: Chain;
    liveHeightThreshold: number;
    reorgHeightThreshold: number;
    bulkMigrationChunkSize: number;
    batchInsertLimit: number;
    isAvailable: boolean;
    hasMigrated: boolean;
    bulkManager: BulkFileDataManager;
    constructor(options: ChaintracksStorageBaseOptions);
    shutdown(): Promise<void>;
    makeAvailable(): Promise<void>;
    migrateLatest(): Promise<void>;
    dropAllData(): Promise<void>;
    abstract deleteLiveBlockHeaders(): Promise<void>;
    abstract deleteOlderLiveBlockHeaders(maxHeight: number): Promise<number>;
    abstract findChainTipHeader(): Promise<LiveBlockHeader>;
    abstract findChainTipHeaderOrUndefined(): Promise<LiveBlockHeader | undefined>;
    abstract findLiveHeaderForBlockHash(hash: string): Promise<LiveBlockHeader | null>;
    abstract findLiveHeaderForHeaderId(headerId: number): Promise<LiveBlockHeader>;
    abstract findLiveHeaderForHeight(height: number): Promise<LiveBlockHeader | null>;
    abstract findLiveHeaderForMerkleRoot(merkleRoot: string): Promise<LiveBlockHeader | null>;
    abstract findLiveHeightRange(): Promise<HeightRange>;
    abstract findMaxHeaderId(): Promise<number>;
    abstract liveHeadersForBulk(count: number): Promise<LiveBlockHeader[]>;
    abstract getLiveHeaders(range: HeightRange): Promise<LiveBlockHeader[]>;
    /**
     * @param header Header to attempt to add to live storage.
     * @returns details of conditions found attempting to insert header
     */
    abstract insertHeader(header: BlockHeader): Promise<InsertHeaderResult>;
    abstract destroy(): Promise<void>;
    getBulkHeaders(range: HeightRange): Promise<Uint8Array>;
    getHeadersUint8Array(height: number, count: number): Promise<Uint8Array>;
    getHeaders(height: number, count: number): Promise<BaseBlockHeader[]>;
    deleteBulkBlockHeaders(): Promise<void>;
    getAvailableHeightRanges(): Promise<{
        bulk: HeightRange;
        live: HeightRange;
    }>;
    private lastActiveMinHeight;
    pruneLiveBlockHeaders(activeTipHeight: number): Promise<void>;
    findChainTipHash(): Promise<string>;
    findChainTipWork(): Promise<string>;
    findChainWorkForBlockHash(hash: string): Promise<string>;
    findBulkFilesHeaderForHeightOrUndefined(height: number): Promise<BlockHeader | undefined>;
    findHeaderForHeightOrUndefined(height: number): Promise<LiveBlockHeader | BlockHeader | undefined>;
    findHeaderForHeight(height: number): Promise<LiveBlockHeader | BlockHeader>;
    isMerkleRootActive(merkleRoot: string): Promise<boolean>;
    findCommonAncestor(header1: LiveBlockHeader, header2: LiveBlockHeader): Promise<LiveBlockHeader>;
    findReorgDepth(header1: LiveBlockHeader, header2: LiveBlockHeader): Promise<number>;
    private nowMigratingLiveToBulk;
    migrateLiveToBulk(count: number, ignoreLimits?: boolean): Promise<void>;
    addBulkHeaders(headers: BlockHeader[], bulkRange: HeightRange, priorLiveHeaders: BlockHeader[]): Promise<BlockHeader[]>;
    private addBulkHeadersFromBestChain;
    private addLiveHeadersToBulk;
}
//# sourceMappingURL=ChaintracksStorageBase.d.ts.map