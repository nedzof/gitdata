"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ChaintracksFetch = void 0;
const sdk_1 = require("@bsv/sdk");
/**
 * This class implements the ChaintracksFetchApi
 * using the @bsv/sdk `defaultHttpClient`.
 */
class ChaintracksFetch {
    constructor() {
        this.httpClient = (0, sdk_1.defaultHttpClient)();
    }
    async download(url) {
        const response = await fetch(url, {
            method: 'GET',
            headers: {
                'Content-Type': 'application/octet-stream'
            }
        });
        if (!response.ok) {
            throw new Error(`Failed to download from ${url}: ${response.statusText}`);
        }
        const data = await response.arrayBuffer();
        return new Uint8Array(data);
    }
    async fetchJson(url) {
        const requestJsonOptions = {
            method: 'GET',
            headers: {
                Accept: 'application/json'
            }
        };
        const response = await fetch(url, requestJsonOptions);
        if (!response.ok) {
            throw new Error(`Failed to fetch JSON from ${url}: ${response.statusText}`);
        }
        const json = (await response.json());
        return json;
    }
    pathJoin(baseUrl, subpath) {
        // Ensure the subpath doesn't start with a slash to avoid issues
        const cleanSubpath = subpath.replace(/^\/+/, '');
        if (!baseUrl.endsWith('/'))
            baseUrl += '/';
        // Create a new URL object and append the subpath
        const url = new URL(cleanSubpath, baseUrl);
        return url.toString();
    }
}
exports.ChaintracksFetch = ChaintracksFetch;
//# sourceMappingURL=ChaintracksFetch.js.map