import { AbortActionResult, Beef, InternalizeActionArgs, ListActionsResult, ListOutputsResult, PubKeyHex, ListCertificatesResult, TrustSelf, RelinquishCertificateArgs, RelinquishOutputArgs, AbortActionArgs } from '@bsv/sdk';
import { GetReqsAndBeefResult } from './methods/processAction';
import { PostReqsToNetworkResult } from './methods/attemptToPostReqsToNetwork';
import { StorageReaderWriter, StorageReaderWriterOptions } from './StorageReaderWriter';
import { EntityProvenTxReq } from './schema/entities';
import { ServicesCallHistory, WalletServices } from '../sdk/WalletServices.interfaces';
import { AuthId, FindCertificatesArgs, FindOutputBasketsArgs, FindOutputsArgs, ProcessSyncChunkResult, ProvenOrRawTx, PurgeParams, PurgeResults, RequestSyncChunkArgs, StorageCreateActionResult, StorageFeeModel, StorageGetBeefOptions, StorageInternalizeActionResult, StorageProcessActionArgs, StorageProcessActionResults, StorageProvenOrReq, SyncChunk, TrxToken, UpdateProvenTxReqWithNewProvenTxArgs, UpdateProvenTxReqWithNewProvenTxResult, WalletStorageProvider } from '../sdk/WalletStorage.interfaces';
import { Chain, TransactionStatus } from '../sdk/types';
import { TableProvenTxReq, TableProvenTxReqDynamics } from '../../src/storage/schema/tables/TableProvenTxReq';
import { TableOutputBasket } from '../../src/storage/schema/tables/TableOutputBasket';
import { TableOutput, TableOutputX } from '../../src/storage/schema/tables/TableOutput';
import { TableOutputTag } from '../../src/storage/schema/tables/TableOutputTag';
import { TableTxLabel } from '../../src/storage/schema/tables/TableTxLabel';
import { TableMonitorEvent } from '../../src/storage/schema/tables/TableMonitorEvent';
import { ValidCreateActionArgs, ValidListActionsArgs, ValidListCertificatesArgs, ValidListOutputsArgs } from '../sdk/validationHelpers';
import { TableCertificateX } from './schema/tables/TableCertificate';
export declare abstract class StorageProvider extends StorageReaderWriter implements WalletStorageProvider {
    isDirty: boolean;
    _services?: WalletServices;
    feeModel: StorageFeeModel;
    commissionSatoshis: number;
    commissionPubKeyHex?: PubKeyHex;
    maxRecursionDepth?: number;
    static defaultOptions(): {
        feeModel: StorageFeeModel;
        commissionSatoshis: number;
        commissionPubKeyHex: undefined;
    };
    static createStorageBaseOptions(chain: Chain): StorageProviderOptions;
    constructor(options: StorageProviderOptions);
    abstract reviewStatus(args: {
        agedLimit: Date;
        trx?: TrxToken;
    }): Promise<{
        log: string;
    }>;
    abstract purgeData(params: PurgeParams, trx?: TrxToken): Promise<PurgeResults>;
    abstract allocateChangeInput(userId: number, basketId: number, targetSatoshis: number, exactSatoshis: number | undefined, excludeSending: boolean, transactionId: number): Promise<TableOutput | undefined>;
    abstract getProvenOrRawTx(txid: string, trx?: TrxToken): Promise<ProvenOrRawTx>;
    abstract getRawTxOfKnownValidTransaction(txid?: string, offset?: number, length?: number, trx?: TrxToken): Promise<number[] | undefined>;
    abstract getLabelsForTransactionId(transactionId?: number, trx?: TrxToken): Promise<TableTxLabel[]>;
    abstract getTagsForOutputId(outputId: number, trx?: TrxToken): Promise<TableOutputTag[]>;
    abstract listActions(auth: AuthId, args: ValidListActionsArgs): Promise<ListActionsResult>;
    abstract listOutputs(auth: AuthId, args: ValidListOutputsArgs): Promise<ListOutputsResult>;
    abstract countChangeInputs(userId: number, basketId: number, excludeSending: boolean): Promise<number>;
    abstract findCertificatesAuth(auth: AuthId, args: FindCertificatesArgs): Promise<TableCertificateX[]>;
    abstract findOutputBasketsAuth(auth: AuthId, args: FindOutputBasketsArgs): Promise<TableOutputBasket[]>;
    abstract findOutputsAuth(auth: AuthId, args: FindOutputsArgs): Promise<TableOutput[]>;
    abstract insertCertificateAuth(auth: AuthId, certificate: TableCertificateX): Promise<number>;
    abstract adminStats(adminIdentityKey: string): Promise<AdminStatsResult>;
    isStorageProvider(): boolean;
    setServices(v: WalletServices): void;
    getServices(): WalletServices;
    abortAction(auth: AuthId, args: AbortActionArgs): Promise<AbortActionResult>;
    internalizeAction(auth: AuthId, args: InternalizeActionArgs): Promise<StorageInternalizeActionResult>;
    /**
     * Given an array of transaction txids with current ProvenTxReq ready-to-share status,
     * lookup their ProvenTxReqApi req records.
     * For the txids with reqs and status still ready to send construct a single merged beef.
     *
     * @param txids
     * @param knownTxids
     * @param trx
     */
    getReqsAndBeefToShareWithWorld(txids: string[], knownTxids: string[], trx?: TrxToken): Promise<GetReqsAndBeefResult>;
    mergeReqToBeefToShareExternally(req: TableProvenTxReq, mergeToBeef: Beef, knownTxids: string[], trx?: TrxToken): Promise<void>;
    /**
     * Checks if txid is a known valid ProvenTx and returns it if found.
     * Next checks if txid is a current ProvenTxReq and returns that if found.
     * If `newReq` is provided and an existing ProvenTxReq isn't found,
     * use `newReq` to create a new ProvenTxReq.
     *
     * This is safe "findOrInsert" operation using retry if unique index constraint
     * is violated by a race condition insert.
     *
     * @param txid
     * @param newReq
     * @param trx
     * @returns
     */
    getProvenOrReq(txid: string, newReq?: TableProvenTxReq, trx?: TrxToken): Promise<StorageProvenOrReq>;
    updateTransactionsStatus(transactionIds: number[], status: TransactionStatus, trx?: TrxToken): Promise<void>;
    /**
     * For all `status` values besides 'failed', just updates the transaction records status property.
     *
     * For 'status' of 'failed', attempts to make outputs previously allocated as inputs to this transaction usable again.
     *
     * @param status
     * @param transactionId
     * @param userId
     * @param reference
     * @param trx
     */
    updateTransactionStatus(status: TransactionStatus, transactionId?: number, userId?: number, reference?: string, trx?: TrxToken): Promise<void>;
    createAction(auth: AuthId, args: ValidCreateActionArgs): Promise<StorageCreateActionResult>;
    processAction(auth: AuthId, args: StorageProcessActionArgs): Promise<StorageProcessActionResults>;
    attemptToPostReqsToNetwork(reqs: EntityProvenTxReq[], trx?: TrxToken): Promise<PostReqsToNetworkResult>;
    listCertificates(auth: AuthId, args: ValidListCertificatesArgs): Promise<ListCertificatesResult>;
    verifyKnownValidTransaction(txid: string, trx?: TrxToken): Promise<boolean>;
    getValidBeefForKnownTxid(txid: string, mergeToBeef?: Beef, trustSelf?: TrustSelf, knownTxids?: string[], trx?: TrxToken, requiredLevels?: number): Promise<Beef>;
    getValidBeefForTxid(txid: string, mergeToBeef?: Beef, trustSelf?: TrustSelf, knownTxids?: string[], trx?: TrxToken, requiredLevels?: number): Promise<Beef | undefined>;
    getBeefForTransaction(txid: string, options: StorageGetBeefOptions): Promise<Beef>;
    findMonitorEventById(id: number, trx?: TrxToken): Promise<TableMonitorEvent | undefined>;
    relinquishCertificate(auth: AuthId, args: RelinquishCertificateArgs): Promise<number>;
    relinquishOutput(auth: AuthId, args: RelinquishOutputArgs): Promise<number>;
    processSyncChunk(args: RequestSyncChunkArgs, chunk: SyncChunk): Promise<ProcessSyncChunkResult>;
    /**
     * Handles storage changes when a valid MerklePath and mined block header are found for a ProvenTxReq txid.
     *
     * Performs the following storage updates (typically):
     * 1. Lookup the exising `ProvenTxReq` record for its rawTx
     * 2. Insert a new ProvenTx record using properties from `args` and rawTx, yielding a new provenTxId
     * 3. Update ProvenTxReq record with status 'completed' and new provenTxId value (and history of status changed)
     * 4. Unpack notify transactionIds from req and update each transaction's status to 'completed', provenTxId value.
     * 5. Update ProvenTxReq history again to record that transactions have been notified.
     * 6. Return results...
     *
     * Alterations of "typically" to handle:
     */
    updateProvenTxReqWithNewProvenTx(args: UpdateProvenTxReqWithNewProvenTxArgs): Promise<UpdateProvenTxReqWithNewProvenTxResult>;
    /**
     * For each spendable output in the 'default' basket of the authenticated user,
     * verify that the output script, satoshis, vout and txid match that of an output
     * still in the mempool of at least one service provider.
     *
     * @returns object with invalidSpendableOutputs array. A good result is an empty array.
     */
    confirmSpendableOutputs(): Promise<{
        invalidSpendableOutputs: TableOutput[];
    }>;
    updateProvenTxReqDynamics(id: number, update: Partial<TableProvenTxReqDynamics>, trx?: TrxToken): Promise<number>;
    extendOutput(o: TableOutput, includeBasket?: boolean, includeTags?: boolean, trx?: TrxToken): Promise<TableOutputX>;
    validateOutputScript(o: TableOutput, trx?: TrxToken): Promise<void>;
}
export interface StorageProviderOptions extends StorageReaderWriterOptions {
    chain: Chain;
    feeModel: StorageFeeModel;
    /**
     * Transactions created by this Storage can charge a fee per transaction.
     * A value of zero disables commission fees.
     */
    commissionSatoshis: number;
    /**
     * If commissionSatoshis is greater than zero, must be a valid public key hex string.
     * The actual locking script for each commission will use a public key derived
     * from this key by information stored in the commissions table.
     */
    commissionPubKeyHex?: PubKeyHex;
}
export declare function validateStorageFeeModel(v?: StorageFeeModel): StorageFeeModel;
export interface StorageAdminStats {
    requestedBy: string;
    when: string;
    usersDay: number;
    usersWeek: number;
    usersMonth: number;
    usersTotal: number;
    transactionsDay: number;
    transactionsWeek: number;
    transactionsMonth: number;
    transactionsTotal: number;
    txCompletedDay: number;
    txCompletedWeek: number;
    txCompletedMonth: number;
    txCompletedTotal: number;
    txFailedDay: number;
    txFailedWeek: number;
    txFailedMonth: number;
    txFailedTotal: number;
    txUnprocessedDay: number;
    txUnprocessedWeek: number;
    txUnprocessedMonth: number;
    txUnprocessedTotal: number;
    txSendingDay: number;
    txSendingWeek: number;
    txSendingMonth: number;
    txSendingTotal: number;
    txUnprovenDay: number;
    txUnprovenWeek: number;
    txUnprovenMonth: number;
    txUnprovenTotal: number;
    txUnsignedDay: number;
    txUnsignedWeek: number;
    txUnsignedMonth: number;
    txUnsignedTotal: number;
    txNosendDay: number;
    txNosendWeek: number;
    txNosendMonth: number;
    txNosendTotal: number;
    txNonfinalDay: number;
    txNonfinalWeek: number;
    txNonfinalMonth: number;
    txNonfinalTotal: number;
    txUnfailDay: number;
    txUnfailWeek: number;
    txUnfailMonth: number;
    txUnfailTotal: number;
    satoshisDefaultDay: number;
    satoshisDefaultWeek: number;
    satoshisDefaultMonth: number;
    satoshisDefaultTotal: number;
    satoshisOtherDay: number;
    satoshisOtherWeek: number;
    satoshisOtherMonth: number;
    satoshisOtherTotal: number;
    basketsDay: number;
    basketsWeek: number;
    basketsMonth: number;
    basketsTotal: number;
    labelsDay: number;
    labelsWeek: number;
    labelsMonth: number;
    labelsTotal: number;
    tagsDay: number;
    tagsWeek: number;
    tagsMonth: number;
    tagsTotal: number;
}
export interface AdminStatsResult extends StorageAdminStats {
    servicesStats?: ServicesCallHistory;
    monitorStats?: ServicesCallHistory;
}
//# sourceMappingURL=StorageProvider.d.ts.map