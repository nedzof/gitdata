/**
 * A permissions manager testing mock/stub file for:
 *  1) The `@bsv/sdk` library: Transaction, LockingScript, PushDrop, Utils, Random, etc.
 *  2) A BRC-100 `WalletInterface` (the underlying wallet).
 *
 * This file bypasses real validation/logic in `@bsv/sdk`, returning placeholders and
 * stubs to prevent test-time errors such as "Invalid Atomic BEEF prefix."
 */
/**
 * A minimal mock for `Transaction` that won't throw "Invalid Atomic BEEF prefix."
 * We override the static methods so they do not do real parsing/validation.
 */
export declare class MockTransaction {
    inputs: any[];
    outputs: any[];
    fee: number;
    constructor();
    static fromAtomicBEEF(): void;
    static fromBEEF(beef: number[]): MockTransaction;
    getFee(): number;
    toBEEF(): number[];
}
/**
 * Mocks for `LockingScript`. If your code calls e.g. LockingScript.fromHex, we can just
 * store the hex and do nothing else.
 */
export declare class MockLockingScript {
    hex: string;
    constructor(hex: string);
    toHex(): string;
    static fromHex(hex: string): MockLockingScript;
}
/**
 * We stub out all methods: `decode()`, `lock()`, `unlock()`.
 */
export declare class MockPushDrop {
    constructor();
    static decode(script: MockLockingScript): {
        fields: number[][];
    } | undefined;
    lock(fields: number[][], protocolID: [number, string], keyID: string, counterparty: string, singleSignature: boolean, anyoneCanPay: boolean): MockLockingScript;
    unlock(protocolID: [number, string], keyID: string, counterparty: string, sighashType: string, enforceReplayProtection: boolean, sigSize: number, lockingScript: MockLockingScript): {
        sign: (tx: MockTransaction, vin: number) => Promise<MockLockingScript>;
    };
}
/**
 * Mocks for Utils, e.g. toHex, toUTF8, fromUTF8, etc.
 * We can provide minimal stubs that won't break your code.
 */
export declare const MockUtils: {
    toHex: (data: number[]) => string;
    toArray: (str: string, encoding?: string) => number[];
    toUTF8: (arr: number[]) => string;
    toBase64: (arr: number[]) => string;
};
/**
 * Mocks for Random
 */
export declare const MockRandom: (size: number) => number[];
/**
 * Overriding the real classes with our mocks.
 */
export declare const MockedBSV_SDK: {
    Transaction: typeof MockTransaction;
    LockingScript: typeof MockLockingScript;
    PushDrop: typeof MockPushDrop;
    Utils: {
        toHex: (data: number[]) => string;
        toArray: (str: string, encoding?: string) => number[];
        toUTF8: (arr: number[]) => string;
        toBase64: (arr: number[]) => string;
    };
    Random: (size: number) => number[];
    Certificate: null;
};
/**
 * A helper function returning a Jest-mocked `WalletInterface`.
 * This ensures all required methods exist and return plausible values.
 *
 * - By default, `createAction` returns a signableTransaction with empty arrays,
 *   so that the manager can call `Transaction.fromAtomicBEEF([])` without throwing.
 * - You can override or chain .mockResolvedValueOnce(...) inside individual tests
 *   if you want more specific behavior in certain test steps.
 */
export declare function mockUnderlyingWallet(): jest.Mocked<any>;
//# sourceMappingURL=WalletPermissionsManager.fixtures.d.ts.map