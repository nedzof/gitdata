import { IDBPDatabase, IDBPTransaction } from 'idb';
import { ListActionsResult, ListOutputsResult } from '@bsv/sdk';
import { TableCertificate, TableCertificateField, TableCertificateX, TableCommission, TableMonitorEvent, TableOutput, TableOutputBasket, TableOutputTag, TableOutputTagMap, TableProvenTx, TableProvenTxReq, TableSettings, TableSyncState, TableTransaction, TableTxLabel, TableTxLabelMap, TableUser } from './schema/tables';
import { StorageAdminStats, StorageProvider, StorageProviderOptions } from './StorageProvider';
import { StorageIdbSchema } from './schema/StorageIdbSchema';
import { DBType } from './StorageReader';
import { AuthId, FindCertificateFieldsArgs, FindCertificatesArgs, FindCommissionsArgs, FindForUserSincePagedArgs, FindMonitorEventsArgs, FindOutputBasketsArgs, FindOutputsArgs, FindOutputTagMapsArgs, FindOutputTagsArgs, FindProvenTxReqsArgs, FindProvenTxsArgs, FindSyncStatesArgs, FindTransactionsArgs, FindTxLabelMapsArgs, FindTxLabelsArgs, FindUsersArgs, ProvenOrRawTx, PurgeParams, PurgeResults, TrxToken, WalletStorageProvider } from '../sdk/WalletStorage.interfaces';
import { EntityTimeStamp } from '../sdk/types';
import { ValidListActionsArgs, ValidListOutputsArgs } from '../sdk/validationHelpers';
export interface StorageIdbOptions extends StorageProviderOptions {
}
/**
 * This class implements the `StorageProvider` interface using IndexedDB,
 * via the promises wrapper package `idb`.
 */
export declare class StorageIdb extends StorageProvider implements WalletStorageProvider {
    dbName: string;
    db?: IDBPDatabase<StorageIdbSchema>;
    constructor(options: StorageIdbOptions);
    /**
     * This method must be called at least once before any other method accesses the database,
     * and each time the schema may have updated.
     *
     * If the database has already been created in this context, `storageName` and `storageIdentityKey`
     * are ignored.
     *
     * @param storageName
     * @param storageIdentityKey
     * @returns
     */
    migrate(storageName: string, storageIdentityKey: string): Promise<string>;
    /**
     * Following initial database initialization, this method verfies that db is ready for use.
     *
     * @throws `WERR_INVALID_OPERATION` if the database has not been initialized by a call to `migrate`.
     *
     * @param storageName
     * @param storageIdentityKey
     *
     * @returns
     */
    verifyDB(storageName?: string, storageIdentityKey?: string): Promise<IDBPDatabase<StorageIdbSchema>>;
    /**
     * Convert the standard optional `TrxToken` parameter into either a direct knex database instance,
     * or a Knex.Transaction as appropriate.
     */
    toDbTrx(stores: string[], mode: 'readonly' | 'readwrite', trx?: TrxToken): IDBPTransaction<StorageIdbSchema, string[], 'readwrite' | 'readonly'>;
    /**
     * Called by `makeAvailable` to return storage `TableSettings`.
     * Since this is the first async method that must be called by all clients,
     * it is where async initialization occurs.
     *
     * After initialization, cached settings are returned.
     *
     * @param trx
     */
    readSettings(trx?: TrxToken): Promise<TableSettings>;
    initDB(storageName?: string, storageIdentityKey?: string): Promise<IDBPDatabase<StorageIdbSchema>>;
    reviewStatus(args: {
        agedLimit: Date;
        trx?: TrxToken;
    }): Promise<{
        log: string;
    }>;
    purgeData(params: PurgeParams, trx?: TrxToken): Promise<PurgeResults>;
    /**
     * Proceeds in three stages:
     * 1. Find an output that exactly funds the transaction (if exactSatoshis is not undefined).
     * 2. Find an output that overfunds by the least amount (targetSatoshis).
     * 3. Find an output that comes as close to funding as possible (targetSatoshis).
     * 4. Return undefined if no output is found.
     *
     * Outputs must belong to userId and basketId and have spendable true.
     * Their corresponding transaction must have status of 'completed', 'unproven', or 'sending' (if excludeSending is false).
     *
     * @param userId
     * @param basketId
     * @param targetSatoshis
     * @param exactSatoshis
     * @param excludeSending
     * @param transactionId
     * @returns next funding output to add to transaction or undefined if there are none.
     */
    allocateChangeInput(userId: number, basketId: number, targetSatoshis: number, exactSatoshis: number | undefined, excludeSending: boolean, transactionId: number): Promise<TableOutput | undefined>;
    getProvenOrRawTx(txid: string, trx?: TrxToken): Promise<ProvenOrRawTx>;
    getRawTxOfKnownValidTransaction(txid?: string, offset?: number, length?: number, trx?: TrxToken): Promise<number[] | undefined>;
    getLabelsForTransactionId(transactionId?: number, trx?: TrxToken): Promise<TableTxLabel[]>;
    getTagsForOutputId(outputId: number, trx?: TrxToken): Promise<TableOutputTag[]>;
    listActions(auth: AuthId, vargs: ValidListActionsArgs): Promise<ListActionsResult>;
    listOutputs(auth: AuthId, vargs: ValidListOutputsArgs): Promise<ListOutputsResult>;
    countChangeInputs(userId: number, basketId: number, excludeSending: boolean): Promise<number>;
    findCertificatesAuth(auth: AuthId, args: FindCertificatesArgs): Promise<TableCertificateX[]>;
    findOutputBasketsAuth(auth: AuthId, args: FindOutputBasketsArgs): Promise<TableOutputBasket[]>;
    findOutputsAuth(auth: AuthId, args: FindOutputsArgs): Promise<TableOutput[]>;
    insertCertificateAuth(auth: AuthId, certificate: TableCertificateX): Promise<number>;
    dropAllData(): Promise<void>;
    filterOutputTagMaps(args: FindOutputTagMapsArgs, filtered: (v: TableOutputTagMap) => void, userId?: number): Promise<void>;
    findOutputTagMaps(args: FindOutputTagMapsArgs): Promise<TableOutputTagMap[]>;
    filterProvenTxReqs(args: FindProvenTxReqsArgs, filtered: (v: TableProvenTxReq) => void, userId?: number): Promise<void>;
    findProvenTxReqs(args: FindProvenTxReqsArgs): Promise<TableProvenTxReq[]>;
    filterProvenTxs(args: FindProvenTxsArgs, filtered: (v: TableProvenTx) => void, userId?: number): Promise<void>;
    findProvenTxs(args: FindProvenTxsArgs): Promise<TableProvenTx[]>;
    filterTxLabelMaps(args: FindTxLabelMapsArgs, filtered: (v: TableTxLabelMap) => void, userId?: number): Promise<void>;
    findTxLabelMaps(args: FindTxLabelMapsArgs): Promise<TableTxLabelMap[]>;
    countOutputTagMaps(args: FindOutputTagMapsArgs): Promise<number>;
    countProvenTxReqs(args: FindProvenTxReqsArgs): Promise<number>;
    countProvenTxs(args: FindProvenTxsArgs): Promise<number>;
    countTxLabelMaps(args: FindTxLabelMapsArgs): Promise<number>;
    insertCertificate(certificate: TableCertificateX, trx?: TrxToken): Promise<number>;
    insertCertificateField(certificateField: TableCertificateField, trx?: TrxToken): Promise<void>;
    insertCommission(commission: TableCommission, trx?: TrxToken): Promise<number>;
    insertMonitorEvent(event: TableMonitorEvent, trx?: TrxToken): Promise<number>;
    insertOutput(output: TableOutput, trx?: TrxToken): Promise<number>;
    insertOutputBasket(basket: TableOutputBasket, trx?: TrxToken): Promise<number>;
    insertOutputTag(tag: TableOutputTag, trx?: TrxToken): Promise<number>;
    insertOutputTagMap(tagMap: TableOutputTagMap, trx?: TrxToken): Promise<void>;
    insertProvenTx(tx: TableProvenTx, trx?: TrxToken): Promise<number>;
    insertProvenTxReq(tx: TableProvenTxReq, trx?: TrxToken): Promise<number>;
    insertSyncState(syncState: TableSyncState, trx?: TrxToken): Promise<number>;
    insertTransaction(tx: TableTransaction, trx?: TrxToken): Promise<number>;
    insertTxLabel(label: TableTxLabel, trx?: TrxToken): Promise<number>;
    insertTxLabelMap(labelMap: TableTxLabelMap, trx?: TrxToken): Promise<void>;
    insertUser(user: TableUser, trx?: TrxToken): Promise<number>;
    updateIdb<T>(id: number | number[], update: Partial<T>, keyProp: string, storeName: string, trx?: TrxToken): Promise<number>;
    updateIdbKey<T>(key: (number | string)[], update: Partial<T>, keyProps: string[], storeName: string, trx?: TrxToken): Promise<number>;
    updateCertificate(id: number, update: Partial<TableCertificate>, trx?: TrxToken): Promise<number>;
    updateCertificateField(certificateId: number, fieldName: string, update: Partial<TableCertificateField>, trx?: TrxToken): Promise<number>;
    updateCommission(id: number, update: Partial<TableCommission>, trx?: TrxToken): Promise<number>;
    updateMonitorEvent(id: number, update: Partial<TableMonitorEvent>, trx?: TrxToken): Promise<number>;
    updateOutput(id: number, update: Partial<TableOutput>, trx?: TrxToken): Promise<number>;
    updateOutputBasket(id: number, update: Partial<TableOutputBasket>, trx?: TrxToken): Promise<number>;
    updateOutputTag(id: number, update: Partial<TableOutputTag>, trx?: TrxToken): Promise<number>;
    updateProvenTx(id: number, update: Partial<TableProvenTx>, trx?: TrxToken): Promise<number>;
    updateProvenTxReq(id: number | number[], update: Partial<TableProvenTxReq>, trx?: TrxToken): Promise<number>;
    updateSyncState(id: number, update: Partial<TableSyncState>, trx?: TrxToken): Promise<number>;
    updateTransaction(id: number | number[], update: Partial<TableTransaction>, trx?: TrxToken): Promise<number>;
    updateTxLabel(id: number, update: Partial<TableTxLabel>, trx?: TrxToken): Promise<number>;
    updateUser(id: number, update: Partial<TableUser>, trx?: TrxToken): Promise<number>;
    updateOutputTagMap(outputId: number, tagId: number, update: Partial<TableOutputTagMap>, trx?: TrxToken): Promise<number>;
    updateTxLabelMap(transactionId: number, txLabelId: number, update: Partial<TableTxLabelMap>, trx?: TrxToken): Promise<number>;
    destroy(): Promise<void>;
    allStores: string[];
    /**
     * @param scope
     * @param trx
     * @returns
     */
    transaction<T>(scope: (trx: TrxToken) => Promise<T>, trx?: TrxToken): Promise<T>;
    filterCertificateFields(args: FindCertificateFieldsArgs, filtered: (v: TableCertificateField) => void): Promise<void>;
    findCertificateFields(args: FindCertificateFieldsArgs): Promise<TableCertificateField[]>;
    filterCertificates(args: FindCertificatesArgs, filtered: (v: TableCertificateX) => void): Promise<void>;
    findCertificates(args: FindCertificatesArgs): Promise<TableCertificateX[]>;
    filterCommissions(args: FindCommissionsArgs, filtered: (v: TableCommission) => void): Promise<void>;
    findCommissions(args: FindCommissionsArgs): Promise<TableCommission[]>;
    filterMonitorEvents(args: FindMonitorEventsArgs, filtered: (v: TableMonitorEvent) => void): Promise<void>;
    findMonitorEvents(args: FindMonitorEventsArgs): Promise<TableMonitorEvent[]>;
    filterOutputBaskets(args: FindOutputBasketsArgs, filtered: (v: TableOutputBasket) => void): Promise<void>;
    findOutputBaskets(args: FindOutputBasketsArgs): Promise<TableOutputBasket[]>;
    filterOutputs(args: FindOutputsArgs, filtered: (v: TableOutput) => void, tagIds?: number[], isQueryModeAll?: boolean): Promise<void>;
    findOutputs(args: FindOutputsArgs, tagIds?: number[], isQueryModeAll?: boolean): Promise<TableOutput[]>;
    filterOutputTags(args: FindOutputTagsArgs, filtered: (v: TableOutputTag) => void): Promise<void>;
    findOutputTags(args: FindOutputTagsArgs): Promise<TableOutputTag[]>;
    filterSyncStates(args: FindSyncStatesArgs, filtered: (v: TableSyncState) => void): Promise<void>;
    findSyncStates(args: FindSyncStatesArgs): Promise<TableSyncState[]>;
    filterTransactions(args: FindTransactionsArgs, filtered: (v: TableTransaction) => void, labelIds?: number[], isQueryModeAll?: boolean): Promise<void>;
    findTransactions(args: FindTransactionsArgs, labelIds?: number[], isQueryModeAll?: boolean): Promise<TableTransaction[]>;
    filterTxLabels(args: FindTxLabelsArgs, filtered: (v: TableTxLabel) => void): Promise<void>;
    findTxLabels(args: FindTxLabelsArgs): Promise<TableTxLabel[]>;
    filterUsers(args: FindUsersArgs, filtered: (v: TableUser) => void): Promise<void>;
    findUsers(args: FindUsersArgs): Promise<TableUser[]>;
    countCertificateFields(args: FindCertificateFieldsArgs): Promise<number>;
    countCertificates(args: FindCertificatesArgs): Promise<number>;
    countCommissions(args: FindCommissionsArgs): Promise<number>;
    countMonitorEvents(args: FindMonitorEventsArgs): Promise<number>;
    countOutputBaskets(args: FindOutputBasketsArgs): Promise<number>;
    countOutputs(args: FindOutputsArgs, tagIds?: number[], isQueryModeAll?: boolean): Promise<number>;
    countOutputTags(args: FindOutputTagsArgs): Promise<number>;
    countSyncStates(args: FindSyncStatesArgs): Promise<number>;
    countTransactions(args: FindTransactionsArgs, labelIds?: number[], isQueryModeAll?: boolean): Promise<number>;
    countTxLabels(args: FindTxLabelsArgs): Promise<number>;
    countUsers(args: FindUsersArgs): Promise<number>;
    getProvenTxsForUser(args: FindForUserSincePagedArgs): Promise<TableProvenTx[]>;
    getProvenTxReqsForUser(args: FindForUserSincePagedArgs): Promise<TableProvenTxReq[]>;
    getTxLabelMapsForUser(args: FindForUserSincePagedArgs): Promise<TableTxLabelMap[]>;
    getOutputTagMapsForUser(args: FindForUserSincePagedArgs): Promise<TableOutputTagMap[]>;
    verifyReadyForDatabaseAccess(trx?: TrxToken): Promise<DBType>;
    /**
     * Helper to force uniform behavior across database engines.
     * Use to process all individual records with time stamps or number[] retreived from database.
     */
    validateEntity<T extends EntityTimeStamp>(entity: T, dateFields?: string[], booleanFields?: string[]): T;
    /**
     * Helper to force uniform behavior across database engines.
     * Use to process all arrays of records with time stamps retreived from database.
     * @returns input `entities` array with contained values validated.
     */
    validateEntities<T extends EntityTimeStamp>(entities: T[], dateFields?: string[], booleanFields?: string[]): T[];
    /**
     * Helper to force uniform behavior across database engines.
     * Use to process the update template for entities being updated.
     */
    validatePartialForUpdate<T extends EntityTimeStamp>(update: Partial<T>, dateFields?: string[], booleanFields?: string[]): Partial<T>;
    /**
     * Helper to force uniform behavior across database engines.
     * Use to process new entities being inserted into the database.
     */
    validateEntityForInsert<T extends EntityTimeStamp>(entity: T, trx?: TrxToken, dateFields?: string[], booleanFields?: string[]): Promise<any>;
    validateRawTransaction(t: TableTransaction, trx?: TrxToken): Promise<void>;
    adminStats(adminIdentityKey: string): Promise<StorageAdminStats>;
}
//# sourceMappingURL=StorageIdb.d.ts.map