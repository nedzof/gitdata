import { RequestSyncChunkArgs, SyncChunk, SyncStatus, TrxToken, WalletStorageSync } from '../../../sdk/WalletStorage.interfaces';
import { TableSettings } from '../tables/TableSettings';
import { TableSyncState } from '../tables/TableSyncState';
import { EntityBase, EntityStorage, SyncError, SyncMap } from './EntityBase';
export declare class EntitySyncState extends EntityBase<TableSyncState> {
    constructor(api?: TableSyncState);
    validateSyncMap(sm: SyncMap): void;
    static fromStorage(storage: WalletStorageSync, userIdentityKey: string, remoteSettings: TableSettings): Promise<EntitySyncState>;
    /**
     * Handles both insert and update based on id value: zero indicates insert.
     * @param storage
     * @param notSyncMap if not new and true, excludes updating syncMap in storage.
     * @param trx
     */
    updateStorage(storage: EntityStorage, notSyncMap?: boolean, trx?: TrxToken): Promise<void>;
    updateApi(notSyncMap?: boolean): void;
    set created_at(v: Date);
    get created_at(): Date;
    set updated_at(v: Date);
    get updated_at(): Date;
    set userId(v: number);
    get userId(): number;
    set storageIdentityKey(v: string);
    get storageIdentityKey(): string;
    set storageName(v: string);
    get storageName(): string;
    set init(v: boolean);
    get init(): boolean;
    set refNum(v: string);
    get refNum(): string;
    set status(v: SyncStatus);
    get status(): SyncStatus;
    set when(v: Date | undefined);
    get when(): Date | undefined;
    set satoshis(v: number | undefined);
    get satoshis(): number | undefined;
    get apiErrorLocal(): string | undefined;
    get apiErrorOther(): string | undefined;
    get apiSyncMap(): string;
    get id(): number;
    set id(id: number);
    get entityName(): string;
    get entityTable(): string;
    static mergeIdMap(fromMap: Record<number, number>, toMap: Record<number, number>): void;
    /**
     * Merge additions to the syncMap
     * @param iSyncMap
     */
    mergeSyncMap(iSyncMap: SyncMap): void;
    errorLocal: SyncError | undefined;
    errorOther: SyncError | undefined;
    syncMap: SyncMap;
    /**
     * Eliminate any properties besides code and description
     */
    private errorToString;
    equals(ei: TableSyncState, syncMap?: SyncMap | undefined): boolean;
    mergeNew(storage: EntityStorage, userId: number, syncMap: SyncMap, trx?: TrxToken): Promise<void>;
    mergeExisting(storage: EntityStorage, since: Date | undefined, ei: TableSyncState, syncMap: SyncMap, trx?: TrxToken): Promise<boolean>;
    makeRequestSyncChunkArgs(forIdentityKey: string, forStorageIdentityKey: string, maxRoughSize?: number, maxItems?: number): RequestSyncChunkArgs;
    static syncChunkSummary(c: SyncChunk): string;
    processSyncChunk(writer: EntityStorage, args: RequestSyncChunkArgs, chunk: SyncChunk): Promise<{
        done: boolean;
        maxUpdated_at: Date | undefined;
        updates: number;
        inserts: number;
    }>;
}
//# sourceMappingURL=EntitySyncState.d.ts.map