"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getBasketToSpecOp = void 0;
const types_1 = require("../../sdk/types");
const utilityHelpers_1 = require("../../utility/utilityHelpers");
const WERR_errors_1 = require("../../sdk/WERR_errors");
const getBasketToSpecOp = () => {
    return {
        [types_1.specOpWalletBalance]: {
            name: 'totalOutputsIsWalletBalance',
            useBasket: 'default',
            ignoreLimit: true,
            resultFromOutputs: async (s, auth, vargs, specOpTags, outputs) => {
                let totalOutputs = 0;
                for (const o of outputs)
                    totalOutputs += o.satoshis;
                return { totalOutputs, outputs: [] };
            }
        },
        [types_1.specOpInvalidChange]: {
            name: 'invalidChangeOutputs',
            useBasket: 'default',
            ignoreLimit: true,
            includeOutputScripts: true,
            includeSpent: false,
            tagsToIntercept: ['release', 'all'],
            filterOutputs: async (s, auth, vargs, specOpTags, outputs) => {
                const filteredOutputs = [];
                const services = s.getServices();
                for (const o of outputs) {
                    await s.validateOutputScript(o);
                    let ok = false;
                    if (o.lockingScript && o.lockingScript.length > 0) {
                        ok = await services.isUtxo(o);
                    }
                    else {
                        ok = undefined;
                    }
                    if (ok === false) {
                        filteredOutputs.push(o);
                    }
                }
                if (specOpTags.indexOf('release') >= 0) {
                    for (const o of filteredOutputs) {
                        await s.updateOutput(o.outputId, { spendable: false });
                        o.spendable = false;
                    }
                }
                return filteredOutputs;
            }
        },
        [types_1.specOpSetWalletChangeParams]: {
            name: 'setWalletChangeParams',
            tagsParamsCount: 2,
            resultFromTags: async (s, auth, vargs, specOpTags) => {
                if (specOpTags.length !== 2)
                    throw new WERR_errors_1.WERR_INVALID_PARAMETER('numberOfDesiredUTXOs and minimumDesiredUTXOValue', 'valid');
                const numberOfDesiredUTXOs = (0, utilityHelpers_1.verifyInteger)(Number(specOpTags[0]));
                const minimumDesiredUTXOValue = (0, utilityHelpers_1.verifyInteger)(Number(specOpTags[1]));
                const basket = (0, utilityHelpers_1.verifyOne)(await s.findOutputBaskets({
                    partial: { userId: (0, utilityHelpers_1.verifyId)(auth.userId), name: 'default' }
                }));
                await s.updateOutputBasket(basket.basketId, {
                    numberOfDesiredUTXOs,
                    minimumDesiredUTXOValue
                });
                return { totalOutputs: 0, outputs: [] };
            }
        }
    };
};
exports.getBasketToSpecOp = getBasketToSpecOp;
//# sourceMappingURL=ListOutputsSpecOp.js.map