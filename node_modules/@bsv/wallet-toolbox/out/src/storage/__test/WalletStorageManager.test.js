"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
const __1 = require("../..");
const TestUtilsWalletStorage_1 = require("../../../test/utils/TestUtilsWalletStorage");
const dotenv = __importStar(require("dotenv"));
dotenv.config();
describe('WalletStorageManager tests', () => {
    jest.setTimeout(99999999);
    const env = TestUtilsWalletStorage_1._tu.getEnvFlags('test');
    const ctxs = [];
    beforeAll(async () => {
        if (env.runMySQL)
            ctxs.push(await TestUtilsWalletStorage_1._tu.createLegacyWalletMySQLCopy('walletStorageManagerTestSource'));
        ctxs.push(await TestUtilsWalletStorage_1._tu.createLegacyWalletSQLiteCopy('walletStorageManagerTestSource'));
    });
    afterAll(async () => {
        for (const ctx of ctxs) {
            await ctx.storage.destroy();
        }
    });
    const root = '02135476';
    const kp = TestUtilsWalletStorage_1._tu.getKeyPair(root.repeat(8));
    const fredsAddress = kp.address;
    test('1_runAsReader runAsWriter runAsSync interlock correctly', async () => {
        const { storage } = await TestUtilsWalletStorage_1._tu.createSQLiteTestSetup1Wallet({
            databaseName: 'syncTest1'
        });
        const result = [];
        const promises = [];
        const now = Date.now();
        const makeReader = (i, duration) => {
            promises.push(storage.runAsReader(async (reader) => {
                const start = Date.now() - now;
                await (0, __1.wait)(duration);
                const end = Date.now() - now;
                const r = { start, end, t: 'reader', i };
                result.push(r);
                return r;
            }));
        };
        const makeWriter = (i, duration) => {
            promises.push(storage.runAsWriter(async (sync) => {
                const start = Date.now() - now;
                await (0, __1.wait)(duration);
                const end = Date.now() - now;
                const r = { start, end, t: 'writer', i };
                result.push(r);
                return r;
            }));
        };
        const makeSync = (i, duration) => {
            promises.push(storage.runAsSync(async (sync) => {
                const start = Date.now() - now;
                await (0, __1.wait)(duration);
                const end = Date.now() - now;
                const r = { start, end, t: 'sync', i };
                result.push(r);
                return r;
            }));
        };
        let i = 0;
        for (let j = 0; j < 5; j++)
            makeReader(i++, 10 + j * 10);
        makeSync(i++, 5000);
        for (let j = 0; j < 5; j++) {
            makeReader(i++, 10 + j * 10);
            makeWriter(i++, 30 + j * 500);
        }
        makeSync(i++, 5000);
        for (let j = 0; j < 5; j++)
            makeReader(i++, 10 + j * 10);
        await Promise.all(promises);
        expect(result).toBeTruthy();
        let log = '';
        for (const r of result) {
            const overlaps = result.filter(r2 => r2.i != r.i && (r2.t != 'reader' || r.t != 'reader') && r.start > r2.start && r.start < r2.end);
            if (overlaps.length > 0) {
                log += `${r.i} ${r.t} ${r.start} overlaps:\n`;
                for (const o of overlaps)
                    log += `  ${o.i} ${o.t} ${o.start} ${o.end}\n`;
            }
        }
        if (log.length > 0) {
            console.log(log);
            expect(log.length).toBe(0);
        }
        await storage.destroy();
    });
    test('1a_runAsReader runAsWriter runAsSync interlock correctly with low durations', async () => {
        const { storage } = await TestUtilsWalletStorage_1._tu.createSQLiteTestSetup1Wallet({
            databaseName: 'syncTest1a'
        });
        const result = [];
        const promises = [];
        const now = Date.now();
        const makeReader = (i, duration) => {
            promises.push(storage.runAsReader(async (reader) => {
                const start = Date.now() - now;
                await (0, __1.wait)(duration);
                const end = Date.now() - now;
                const r = { start, end, t: 'reader', i };
                result.push(r);
                return r;
            }));
        };
        const makeWriter = (i, duration) => {
            promises.push(storage.runAsWriter(async (sync) => {
                const start = Date.now() - now;
                await (0, __1.wait)(duration);
                const end = Date.now() - now;
                const r = { start, end, t: 'writer', i };
                result.push(r);
                return r;
            }));
        };
        const makeSync = (i, duration) => {
            promises.push(storage.runAsSync(async (sync) => {
                const start = Date.now() - now;
                await (0, __1.wait)(duration);
                const end = Date.now() - now;
                const r = { start, end, t: 'sync', i };
                result.push(r);
                return r;
            }));
        };
        let i = 0;
        for (let j = 0; j < 5; j++)
            makeReader(i++, j);
        makeSync(i++, 5000);
        for (let j = 0; j < 5; j++) {
            makeReader(i++, j);
            makeWriter(i++, j);
        }
        makeSync(i++, 5000);
        for (let j = 0; j < 5; j++)
            makeReader(i++, j);
        await Promise.all(promises);
        expect(result).toBeTruthy();
        let log = '';
        for (const r of result) {
            const overlaps = result.filter(r2 => r2.i != r.i && (r2.t != 'reader' || r.t != 'reader') && r.start > r2.start && r.start < r2.end);
            if (overlaps.length > 0) {
                log += `${r.i} ${r.t} ${r.start} overlaps:\n`;
                for (const o of overlaps)
                    log += `  ${o.i} ${o.t} ${o.start} ${o.end}\n`;
            }
        }
        if (log.length > 0) {
            console.log(log);
            expect(log.length).toBe(0);
        }
        await storage.destroy();
    });
    test.skip('2_TODOTONE - AtomicBEEF error', async () => {
        for (const { wallet } of ctxs) {
            const fred = await TestUtilsWalletStorage_1._tu.createSQLiteTestWallet({
                chain: 'test',
                databaseName: 'syncTest2Fred',
                rootKeyHex: '2'.repeat(64),
                dropAll: true
            });
            const promises = [];
            const result = [];
            const crs1 = [];
            /*** maxI = 6 test PASS ***/
            const maxI = 7;
            const makeWriter2 = async (fred, cr, i, result) => {
                logger(`writer${i}`);
                const internalizeArgs = {
                    tx: cr.tx,
                    outputs: [
                        {
                            outputIndex: 0,
                            protocol: 'basket insertion',
                            insertionRemittance: {
                                basket: 'payments',
                                customInstructions: JSON.stringify({ root, repeat: 8 }),
                                tags: ['test', 'again']
                            }
                        }
                    ],
                    description: `paid ${i}`
                };
                const r = await fred.wallet.internalizeAction(internalizeArgs);
                expect(r.accepted).toBe(true);
                result.push({ r, i });
                return i;
            };
            for (let i = 0; i < maxI; i++) {
                const createArgs = {
                    description: `${kp.address} of ${root}`,
                    outputs: [
                        {
                            satoshis: 1,
                            lockingScript: TestUtilsWalletStorage_1._tu.getLockP2PKH(fredsAddress).toHex(),
                            outputDescription: 'pay fred'
                        }
                    ],
                    options: {
                        returnTXIDOnly: false,
                        randomizeOutputs: false,
                        signAndProcess: true,
                        noSend: true
                    }
                };
                const cr = await wallet.createAction(createArgs);
                expect(cr.tx).toBeTruthy();
                crs1.push(cr);
            }
            let j = 0;
            for (let i = 0; i < maxI; i++)
                promises.push(makeWriter2(fred, crs1[j++], i, result));
            await Promise.all(promises);
            expect(result).toBeTruthy();
        }
    });
});
function logger(s) {
    process.stdout.write(`${s}\n`);
}
//# sourceMappingURL=WalletStorageManager.test.js.map