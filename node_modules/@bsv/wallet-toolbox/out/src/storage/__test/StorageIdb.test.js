"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const sdk_1 = require("@bsv/sdk");
const Setup_1 = require("../../Setup");
const SetupClient_1 = require("../../SetupClient");
const StorageIdb_1 = require("../StorageIdb");
const StorageProvider_1 = require("../StorageProvider");
require("fake-indexeddb/auto");
describe('StorageIdb tests', () => {
    jest.setTimeout(99999999);
    test('0', async () => {
        const options = StorageProvider_1.StorageProvider.createStorageBaseOptions('main');
        const storage = new StorageIdb_1.StorageIdb(options);
        const r = await storage.migrate('storageIdbTest', `42`.repeat(32));
        const db = storage.db;
        expect(db).toBeTruthy();
    });
    test.skip('1', async () => {
        // TODO: THIS TEST PASSES WHEN Describe is run alone, but fails to exit cleanly when run with `npm run test`
        if (Setup_1.Setup.noEnv('test'))
            return;
        const env = Setup_1.Setup.getEnv('test');
        const wallet = await SetupClient_1.SetupClient.createWalletClientNoEnv({
            chain: env.chain,
            rootKeyHex: env.devKeys[env.identityKey]
        });
        const stores = wallet.storage.getStores();
        const options = StorageIdb_1.StorageIdb.createStorageBaseOptions(wallet.chain);
        const store = new StorageIdb_1.StorageIdb(options);
        await store.migrate(store.dbName, sdk_1.PrivateKey.fromRandom().toHex());
        await store.makeAvailable();
        await wallet.storage.addWalletStorageProvider(store);
        await wallet.storage.setActive(stores[0].storageIdentityKey, s => {
            console.log(s);
            return s;
        });
        await wallet.storage.updateBackups(undefined, s => {
            console.log(s);
            return s;
        });
        await wallet.destroy();
    });
});
//# sourceMappingURL=StorageIdb.test.js.map