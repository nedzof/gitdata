import { BlockHeadersService } from '@bsv/sdk';
import { ChaintracksServiceClient, ChaintracksServiceClientOptions } from './chaintracks/ChaintracksServiceClient';
import { HeaderListener, ReorgListener, ChaintracksInfoApi } from './chaintracks/Api/ChaintracksClientApi';
import { Chain } from '../../sdk/types';
import { BlockHeader } from '../../sdk/WalletServices.interfaces';
export declare class BHServiceClient implements ChaintracksServiceClient {
    bhs: BlockHeadersService;
    cache: Record<number, string>;
    chain: Chain;
    serviceUrl: string;
    options: ChaintracksServiceClientOptions;
    apiKey: string;
    constructor(chain: Chain, url: string, apiKey: string);
    currentHeight(): Promise<number>;
    isValidRootForHeight(root: string, height: number): Promise<boolean>;
    getPresentHeight(): Promise<number>;
    findHeaderForHeight(height: number): Promise<BlockHeader | undefined>;
    findHeaderForBlockHash(hash: string): Promise<BlockHeader | undefined>;
    getHeaders(height: number, count: number): Promise<string>;
    findChainWorkForBlockHash(hash: string): Promise<string | undefined>;
    findChainTipHeader(): Promise<BlockHeader>;
    getJsonOrUndefined<T>(path: string): Promise<T | undefined>;
    getJson<T>(path: string): Promise<T>;
    postJsonVoid<T>(path: string, params: T): Promise<void>;
    addHeader(header: any): Promise<void>;
    findHeaderForMerkleRoot(merkleRoot: string, height?: number): Promise<undefined>;
    startListening(): Promise<void>;
    listening(): Promise<void>;
    isSynchronized(): Promise<boolean>;
    getChain(): Promise<Chain>;
    isListening(): Promise<boolean>;
    getChainTipHeader(): Promise<BlockHeader>;
    findChainTipHash(): Promise<string>;
    subscribeHeaders(listener: HeaderListener): Promise<string>;
    subscribeReorgs(listener: ReorgListener): Promise<string>;
    unsubscribe(subscriptionId: string): Promise<boolean>;
    getInfo(): Promise<ChaintracksInfoApi>;
}
//# sourceMappingURL=BHServiceClient.d.ts.map