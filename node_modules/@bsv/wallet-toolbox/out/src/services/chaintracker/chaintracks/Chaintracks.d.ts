import { ChaintracksOptions, ChaintracksManagementApi } from './Api/ChaintracksApi';
import { Chain } from '../../../sdk/types';
import { ChaintracksInfoApi, HeaderListener, ReorgListener } from './Api/ChaintracksClientApi';
import { BaseBlockHeader, BlockHeader, LiveBlockHeader } from './Api/BlockHeaderApi';
import { ChaintracksFsApi } from './Api/ChaintracksFsApi';
export declare class Chaintracks implements ChaintracksManagementApi {
    options: ChaintracksOptions;
    static createOptions(chain: Chain): ChaintracksOptions;
    log: (...args: any[]) => void;
    readonly chain: Chain;
    readonly readonly: boolean;
    private promises;
    private callbacks;
    private storage;
    private bulkIngestors;
    private liveIngestors;
    private baseHeaders;
    private liveHeaders;
    private addLiveRecursionLimit;
    private available;
    private startupError;
    private subscriberCallbacksEnabled;
    private stopMainThread;
    private lastPresentHeight;
    private lastPresentHeightMsecs;
    private lastPresentHeightMaxAge;
    private lock;
    constructor(options: ChaintracksOptions);
    getChain(): Promise<Chain>;
    /**
     * Caches and returns most recently sourced value if less than one minute old.
     * @returns the current externally available chain height (via bulk ingestors).
     */
    getPresentHeight(): Promise<number>;
    currentHeight(): Promise<number>;
    subscribeHeaders(listener: HeaderListener): Promise<string>;
    subscribeReorgs(listener: ReorgListener): Promise<string>;
    unsubscribe(subscriptionId: string): Promise<boolean>;
    /**
     * Queues a potentially new, unknown header for consideration as an addition to the chain.
     * When the header is considered, if the prior header is unknown, recursive calls to the
     * bulk ingestors will be attempted to resolve the linkage up to a depth of `addLiveRecursionLimit`.
     *
     * Headers are considered in the order they were added.
     *
     * @param header
     */
    addHeader(header: BaseBlockHeader): Promise<void>;
    /**
     * If not already available, takes a writer lock to queue calls until available.
     * Becoming available starts by initializing ingestors and main thread,
     * and ends when main thread sets `available`.
     * Note that the main thread continues running and takes additional write locks
     * itself when already available.
     *
     * @returns when available for client requests
     */
    makeAvailable(): Promise<void>;
    startPromises(): Promise<void>;
    destroy(): Promise<void>;
    listening(): Promise<void>;
    isListening(): Promise<boolean>;
    isSynchronized(): Promise<boolean>;
    findHeaderForHeight(height: number): Promise<BlockHeader | undefined>;
    private findHeaderForHeightNoLock;
    findHeaderForBlockHash(hash: string): Promise<BlockHeader | undefined>;
    private findHeaderForBlockHashNoLock;
    isValidRootForHeight(root: string, height: number): Promise<boolean>;
    getInfo(): Promise<ChaintracksInfoApi>;
    private getInfoNoLock;
    getHeaders(height: number, count: number): Promise<string>;
    findChainTipHeader(): Promise<BlockHeader>;
    findChainTipHash(): Promise<string>;
    findLiveHeaderForBlockHash(hash: string): Promise<LiveBlockHeader | undefined>;
    findChainWorkForBlockHash(hash: string): Promise<string | undefined>;
    /**
     * @returns true iff all headers from height zero through current chainTipHeader height can be retreived and form a valid chain.
     */
    validate(): Promise<boolean>;
    exportBulkHeaders(toFolder: string, toFs: ChaintracksFsApi, sourceUrl?: string, toHeadersPerFile?: number, maxHeight?: number): Promise<void>;
    startListening(): Promise<void>;
    private syncBulkStorage;
    private syncBulkStorageNoLock;
    private getMissingBlockHeader;
    private invalidInsertHeaderResult;
    private addLiveHeader;
    /**
     * Long running method terminated by setting `stopMainThread` false.
     *
     * The promise returned by this method is held in the `promises` array.
     *
     * When synchronized (bulk and live storage is valid up to most recent presentHeight),
     * this method will process headers from `baseHeaders` and `liveHeaders` arrays to extend the chain of headers.
     *
     * If a significant gap is detected between bulk+live and presentHeight, `syncBulkStorage` is called to re-establish sync.
     *
     * Periodically CDN bulk ingestor is invoked to check if incremental headers can be migrated to CDN backed files.
     */
    private mainThreadShiftLiveHeaders;
}
//# sourceMappingURL=Chaintracks.d.ts.map