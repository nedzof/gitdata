import { Knex } from 'knex';
import { InsertHeaderResult, ChaintracksStorageBaseOptions } from '../Api/ChaintracksStorageApi';
import { ChaintracksStorageBase } from './ChaintracksStorageBase';
import { LiveBlockHeader } from '../Api/BlockHeaderApi';
import { BlockHeader } from '../../../../sdk/WalletServices.interfaces';
import { DBType } from '../../../../storage/StorageReader';
import { BulkHeaderFileInfo } from '../util/BulkHeaderFile';
import { HeightRange } from '../util/HeightRange';
import { ChaintracksStorageBulkFileApi } from '../Api/ChaintracksStorageApi';
import { Chain } from '../../../../sdk/types';
export interface ChaintracksStorageKnexOptions extends ChaintracksStorageBaseOptions {
    /**
     * Required.
     *
     * Knex.js database interface initialized with valid connection configuration.
     */
    knex: Knex | undefined;
}
/**
 * Implements the ChaintracksStorageApi using Knex.js for both MySql and Sqlite support.
 * Also see `chaintracksStorageMemory` which leverages Knex support for an in memory database.
 */
export declare class ChaintracksStorageKnex extends ChaintracksStorageBase implements ChaintracksStorageBulkFileApi {
    static createStorageKnexOptions(chain: Chain, knex?: Knex): ChaintracksStorageKnexOptions;
    knex: Knex;
    _dbtype?: DBType;
    bulkFilesTableName: string;
    headerTableName: string;
    constructor(options: ChaintracksStorageKnexOptions);
    get dbtype(): DBType;
    shutdown(): Promise<void>;
    makeAvailable(): Promise<void>;
    migrateLatest(): Promise<void>;
    dropAllData(): Promise<void>;
    destroy(): Promise<void>;
    findLiveHeightRange(): Promise<HeightRange>;
    findLiveHeaderForHeaderId(headerId: number): Promise<LiveBlockHeader>;
    findChainTipHeader(): Promise<LiveBlockHeader>;
    findChainTipHeaderOrUndefined(): Promise<LiveBlockHeader | undefined>;
    findLiveHeaderForHeight(height: number): Promise<LiveBlockHeader | null>;
    findLiveHeaderForBlockHash(hash: string): Promise<LiveBlockHeader | null>;
    findLiveHeaderForMerkleRoot(merkleRoot: string): Promise<LiveBlockHeader | null>;
    deleteBulkFile(fileId: number): Promise<number>;
    insertBulkFile(file: BulkHeaderFileInfo): Promise<number>;
    updateBulkFile(fileId: number, file: BulkHeaderFileInfo): Promise<number>;
    getBulkFiles(): Promise<BulkHeaderFileInfo[]>;
    dbTypeSubstring(source: string, fromOffset: number, forLength?: number): string;
    getBulkFileData(fileId: number, offset?: number, length?: number): Promise<Uint8Array | undefined>;
    /**
     * @param header Header to attempt to add to live storage.
     * @returns details of conditions found attempting to insert header
     */
    insertHeader(header: BlockHeader): Promise<InsertHeaderResult>;
    findMaxHeaderId(): Promise<number>;
    deleteLiveBlockHeaders(): Promise<void>;
    deleteBulkBlockHeaders(): Promise<void>;
    deleteOlderLiveBlockHeaders(maxHeight: number): Promise<number>;
    getLiveHeaders(range: HeightRange): Promise<LiveBlockHeader[]>;
    concatSerializedHeaders(bufs: number[][]): number[];
    liveHeadersForBulk(count: number): Promise<LiveBlockHeader[]>;
}
//# sourceMappingURL=ChaintracksStorageKnex.d.ts.map