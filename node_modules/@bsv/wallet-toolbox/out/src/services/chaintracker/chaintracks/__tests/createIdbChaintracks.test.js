"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const TestUtilsWalletStorage_1 = require("../../../../../test/utils/TestUtilsWalletStorage");
const utilityHelpers_1 = require("../../../../utility/utilityHelpers");
const createIdbChaintracks_1 = require("../createIdbChaintracks");
require("fake-indexeddb/auto");
describe('createIdbChaintracks tests', () => {
    jest.setTimeout(99999999);
    test('0', async () => {
        const target = 'main';
        if (TestUtilsWalletStorage_1._tu.noEnv(target))
            return;
        const env = TestUtilsWalletStorage_1._tu.getEnv(target);
        const { chain, chaintracks, storage, available } = await (0, createIdbChaintracks_1.createIdbChaintracks)(env.chain, env.whatsonchainApiKey);
        await available;
        const headerListener = (header) => {
            console.log(`headerListener: height: ${header.height} hash: ${header.hash} ${new Date().toISOString()}`);
        };
        chaintracks.subscribeHeaders(headerListener);
        expect(countDatas(storage.bulkManager)).toBeLessThanOrEqual(3);
        const tipHash = await chaintracks.findChainTipHash();
        const tip = await chaintracks.findChainTipHeader();
        chaintracks.log(`tip: height: ${tip.height} hash: ${tip.hash}`);
        expect(tip.hash).toBe(tipHash);
        const forHash = await chaintracks.findHeaderForBlockHash(tip.hash);
        expect(forHash === null || forHash === void 0 ? void 0 : forHash.hash).toBe(tip.hash);
        const forHashLive = await chaintracks.findLiveHeaderForBlockHash(tip.hash);
        expect(forHashLive === null || forHashLive === void 0 ? void 0 : forHashLive.hash).toBe(tip.hash);
        const chainwork = await chaintracks.findChainWorkForBlockHash(tip.hash);
        expect(forHashLive === null || forHashLive === void 0 ? void 0 : forHashLive.chainWork).toBe(chainwork);
        const forHeight = await chaintracks.findHeaderForHeight(tip.height);
        expect(forHeight === null || forHeight === void 0 ? void 0 : forHeight.hash).toBe(tip.hash);
        const listening = await chaintracks.isListening();
        expect(listening).toBe(true);
        //    console.log('validating...')
        //    const validated = await chaintracks.validate()
        //    expect(validated).toBe(true)
        //    console.log('validated')
        for (;;)
            await (0, utilityHelpers_1.wait)(120000);
    });
});
function countDatas(manager) {
    let count = 0;
    for (const file of manager['bfds']) {
        if (file.data)
            count += 1;
    }
    return count;
}
//# sourceMappingURL=createIdbChaintracks.test.js.map