"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LiveIngestorTeranodeP2P = void 0;
const LiveIngestorBase_1 = require("./LiveIngestorBase");
class LiveIngestorTeranodeP2P extends LiveIngestorBase_1.LiveIngestorBase {
    static createLiveIngestorTeranodeP2POptions(chain) {
        const options = {
            ...LiveIngestorBase_1.LiveIngestorBase.createLiveIngestorBaseOptions(chain)
        };
        return options;
    }
    constructor(options) {
        super(options);
    }
    async getHeaderByHash(hash) {
        return undefined;
    }
    async startListening(liveHeaders) {
        const errors = [];
        const enqueue = header => {
            liveHeaders.push(header);
        };
        const error = (code, message) => {
            errors.push({ code, message, count: errors.length });
            return false;
        };
        for (;;) {
            const ok = true; // await this.woc.listenForNewBlockHeaders(enqueue, error, this.idleWait)
            if (!ok || errors.length > 0) {
                console.log(`TeranodeP2P live ingestor ok=${ok} error count=${errors.length}`);
                for (const e of errors)
                    console.log(`TeranodeP2P error code=${e.code} count=${e.count} message=${e.message}`);
            }
            if (ok)
                break;
            errors.length = 0;
        }
    }
    stopListening() {
        //this.woc?.stopNewListener()
    }
}
exports.LiveIngestorTeranodeP2P = LiveIngestorTeranodeP2P;
//# sourceMappingURL=LiveIngestorTeranodeP2P.js.map