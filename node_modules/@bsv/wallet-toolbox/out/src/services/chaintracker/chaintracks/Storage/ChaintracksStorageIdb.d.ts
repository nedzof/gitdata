import { ChaintracksStorageBaseOptions, ChaintracksStorageBulkFileApi, InsertHeaderResult } from '../Api/ChaintracksStorageApi';
import { ChaintracksStorageBase } from './ChaintracksStorageBase';
import { LiveBlockHeader } from '../Api/BlockHeaderApi';
import { HeightRange } from '../util/HeightRange';
import { BlockHeader } from '../../../../sdk/WalletServices.interfaces';
import { IDBPDatabase, IDBPTransaction } from 'idb';
import { BulkHeaderFileInfo } from '../util/BulkHeaderFile';
export interface ChaintracksStorageIdbOptions extends ChaintracksStorageBaseOptions {
}
export declare class ChaintracksStorageIdb extends ChaintracksStorageBase implements ChaintracksStorageBulkFileApi {
    dbName: string;
    db?: IDBPDatabase<ChaintracksStorageIdbSchema>;
    whenLastAccess?: Date;
    allStores: string[];
    constructor(options: ChaintracksStorageIdbOptions);
    makeAvailable(): Promise<void>;
    migrateLatest(): Promise<void>;
    destroy(): Promise<void>;
    deleteLiveBlockHeaders(): Promise<void>;
    /**
     * Delete live headers with height less or equal to `maxHeight`
     *
     * Set existing headers with previousHeaderId value set to the headerId value of
     * a header which is to be deleted to null.
     *
     * @param maxHeight delete all records with less or equal `height`
     * @returns number of deleted records
     */
    deleteOlderLiveBlockHeaders(maxHeight: number): Promise<number>;
    /**
     * @returns the active chain tip header
     * @throws an error if there is no tip.
     */
    findChainTipHeader(): Promise<LiveBlockHeader>;
    /**
     *
     * @returns the active chain tip header
     * @throws an error if there is no tip.
     */
    findChainTipHeaderOrUndefined(): Promise<LiveBlockHeader | undefined>;
    findLiveHeaderForBlockHash(hash: string): Promise<LiveBlockHeader | null>;
    findLiveHeaderForHeaderId(headerId: number): Promise<LiveBlockHeader>;
    findLiveHeaderForHeight(height: number): Promise<LiveBlockHeader | null>;
    findLiveHeaderForMerkleRoot(merkleRoot: string): Promise<LiveBlockHeader | null>;
    findLiveHeightRange(): Promise<HeightRange>;
    findMaxHeaderId(): Promise<number>;
    liveHeadersForBulk(count: number): Promise<LiveBlockHeader[]>;
    getLiveHeaders(range: HeightRange): Promise<LiveBlockHeader[]>;
    insertHeader(header: BlockHeader): Promise<InsertHeaderResult>;
    deleteBulkFile(fileId: number): Promise<number>;
    insertBulkFile(file: BulkHeaderFileInfo): Promise<number>;
    updateBulkFile(fileId: number, file: BulkHeaderFileInfo): Promise<number>;
    getBulkFiles(): Promise<BulkHeaderFileInfo[]>;
    getBulkFileData(fileId: number, offset?: number, length?: number): Promise<Uint8Array | undefined>;
    /**
     * IndexedDB does not do indices of boolean properties.
     * So true is stored as a 1, and false is stored as no property value (delete v['property'])
     *
     * This function restores these property values to true and false.
     *
     * @param header
     * @returns copy of header with updated properties
     */
    private repairStoredLiveHeader;
    private prepareStoredLiveHeader;
    insertLiveHeader(header: LiveBlockHeader): Promise<LiveBlockHeader>;
    initDB(): Promise<IDBPDatabase<ChaintracksStorageIdbSchema>>;
    toDbTrxReadOnly(stores: string[]): IDBPTransaction<ChaintracksStorageIdbSchema, string[], 'readonly'>;
    toDbTrxReadWrite(stores: string[]): IDBPTransaction<ChaintracksStorageIdbSchema, string[], 'readwrite'>;
}
export interface ChaintracksStorageIdbSchema {
    liveHeaders: {
        key: number;
        value: LiveBlockHeader;
        indexes: {
            hash: string;
            previousHash: string;
            previousHeaderId: number | null;
            isActive: boolean;
            activeTip: [boolean, boolean];
            height: number;
        };
    };
    bulkHeaders: {
        key: number;
        value: BulkHeaderFileInfo;
        indexes: {
            firstHeight: number;
        };
    };
}
//# sourceMappingURL=ChaintracksStorageIdb.d.ts.map