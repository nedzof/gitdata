"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ChaintracksKnexMigrations = void 0;
class ChaintracksKnexMigrations {
    constructor(chain) {
        this.chain = chain;
        this.migrations = {};
        this.migrations = this.setupMigrations();
    }
    async getMigrations() {
        return Object.keys(this.migrations).sort();
    }
    getMigrationName(migration) {
        return migration;
    }
    async getMigration(migration) {
        return this.migrations[migration];
    }
    async getLatestMigration() {
        const ms = await this.getMigrations();
        return ms[ms.length - 1];
    }
    static async latestMigration() {
        const km = new ChaintracksKnexMigrations('test');
        return await km.getLatestMigration();
    }
    setupMigrations() {
        const migrations = {};
        const liveHeadersTableName = `live_headers`;
        const bulkFilesTableName = `bulk_files`;
        migrations['2025-06-28-001 initial migration'] = {
            async up(knex) {
                await knex.schema.createTable(liveHeadersTableName, table => {
                    table.increments('headerId');
                    table.integer('previousHeaderId').unsigned().references('headerId').inTable(liveHeadersTableName);
                    table.binary('previousHash', 32);
                    table.integer('height').unsigned().notNullable;
                    table.boolean('isActive').notNullable;
                    table.boolean('isChainTip').notNullable;
                    table.binary('hash', 32).notNullable;
                    table.binary('chainWork', 32).notNullable;
                    table.integer('version').unsigned().notNullable;
                    table.binary('merkleRoot', 32).notNullable;
                    table.integer('time').unsigned().notNullable;
                    table.integer('bits').unsigned().notNullable;
                    table.integer('nonce').unsigned().notNullable;
                    table.unique(['hash']);
                    table.index(['previousHeaderId']);
                    table.index(['height']);
                    table.index(['previousHash']);
                    table.index(['merkleRoot']);
                    table.index(['isChainTip']);
                    table.index(['isActive']);
                    table.index(['isActive', 'isChainTip']);
                });
                await knex.schema.createTable(bulkFilesTableName, table => {
                    table.increments('fileId');
                    table.string('chain').notNullable();
                    table.string('fileName').notNullable();
                    table.integer('firstHeight').unsigned().notNullable();
                    table.integer('count').unsigned().notNullable();
                    table.string('prevHash', 64).notNullable(); // hex encoded
                    table.string('lastHash', 64).notNullable(); // hex encoded
                    table.string('prevChainWork', 64).notNullable(); // hex encoded
                    table.string('lastChainWork', 64).notNullable(); // hex encoded
                    table.string('fileHash').notNullable(); // base64 encoded
                    table.boolean('validated').defaultTo(false).notNullable();
                    table.string('sourceUrl').nullable();
                    table.binary('data', 32000000).nullable(); // 32MB max size
                    table.index(['firstHeight', 'chain']);
                });
            },
            async down(knex) {
                await knex.schema.dropTable(liveHeadersTableName);
                await knex.schema.dropTable(bulkFilesTableName);
            }
        };
        return migrations;
    }
}
exports.ChaintracksKnexMigrations = ChaintracksKnexMigrations;
//# sourceMappingURL=ChaintracksKnexMigrations.js.map