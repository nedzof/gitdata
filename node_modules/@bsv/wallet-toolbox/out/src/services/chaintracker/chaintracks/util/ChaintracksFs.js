"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ChaintracksAppendableFile = exports.ChaintracksWritableFile = exports.ChaintracksReadableFile = exports.ChaintracksFs = exports.ChaintracksFsStatics = void 0;
const fs_1 = require("fs");
const path_1 = __importDefault(require("path"));
class ChaintracksFsStatics {
    static async delete(path) {
        await fs_1.promises.unlink(path);
    }
    static async writeFile(path, data) {
        await this.ensureFoldersExist(path);
        await fs_1.promises.writeFile(path, Buffer.from(data));
    }
    static async readFile(path) {
        const buffer = await fs_1.promises.readFile(path);
        return Uint8Array.from(buffer);
    }
    static async openReadableFile(path) {
        return await ChaintracksReadableFile.openAsReadable(path);
    }
    static async openWritableFile(path) {
        return await ChaintracksWritableFile.openAsWritable(path);
    }
    static async openAppendableFile(path) {
        return await ChaintracksAppendableFile.openAsAppendable(path);
    }
    static async ensureFoldersExist(path) {
        const parsedPath = path_1.default.parse(path);
        await fs_1.promises.mkdir(parsedPath.dir, { recursive: true });
    }
    static pathJoin(...parts) {
        return path_1.default.join(...parts);
    }
}
exports.ChaintracksFsStatics = ChaintracksFsStatics;
/**
 * This object is an implementation of the `ChaintracksFsApi` interface
 * using the `fs` package which may not be available in all environments.
 */
exports.ChaintracksFs = ChaintracksFsStatics;
class ChaintracksReadableFile {
    constructor(path, f) {
        this.path = path;
        this.f = f;
        this.parsedPath = path_1.default.parse(path);
    }
    async close() {
        await this.f.close();
    }
    async getLength() {
        const stats = await this.f.stat();
        return stats.size;
    }
    async read(length, offset) {
        length || (length = 80 * 1024); // Default to 80KB if no length is specified
        const buffer = Buffer.alloc(length);
        const rr = await this.f.read(buffer, 0, length, offset || 0);
        const rb = rr.bytesRead < length ? buffer.subarray(0, rr.bytesRead) : buffer;
        return Uint8Array.from(rb);
    }
    static async openAsReadable(path) {
        const f = await fs_1.promises.open(path, 'r');
        const file = new ChaintracksReadableFile(path, f);
        return file;
    }
}
exports.ChaintracksReadableFile = ChaintracksReadableFile;
class ChaintracksWritableFile {
    constructor(path, f) {
        this.foldersEnsured = false;
        this.path = path;
        this.f = f;
        this.parsedPath = path_1.default.parse(path);
    }
    static async openAsWritable(path) {
        const f = await fs_1.promises.open(path, 'w');
        const file = new ChaintracksWritableFile(path, f);
        return file;
    }
    async close() {
        await this.f.close();
    }
    async ensureFoldersExist() {
        if (!this.foldersEnsured) {
            await ChaintracksFsStatics.ensureFoldersExist(this.path);
            this.foldersEnsured = true;
        }
    }
    async append(data) {
        await this.ensureFoldersExist();
        throw new Error('Method not implemented.');
    }
}
exports.ChaintracksWritableFile = ChaintracksWritableFile;
class ChaintracksAppendableFile extends ChaintracksReadableFile {
    constructor(path, f) {
        super(path, f);
        this.foldersEnsured = false;
    }
    static async openAsAppendable(path) {
        const f = await fs_1.promises.open(path, 'a+');
        const file = new ChaintracksAppendableFile(path, f);
        return file;
    }
    async ensureFoldersExist() {
        if (!this.foldersEnsured) {
            await ChaintracksFsStatics.ensureFoldersExist(this.path);
            this.foldersEnsured = true;
        }
    }
    async append(data) {
        await this.ensureFoldersExist();
        await this.f.write(Buffer.from(data));
    }
}
exports.ChaintracksAppendableFile = ChaintracksAppendableFile;
//# sourceMappingURL=ChaintracksFs.js.map