"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ChaintracksServiceClient = void 0;
const utilityHelpers_noBuffer_1 = require("../../../utility/utilityHelpers.noBuffer");
/**
 * Connects to a ChaintracksService to implement 'ChaintracksClientApi'
 *
 */
class ChaintracksServiceClient {
    static createChaintracksServiceClientOptions() {
        const options = {
            useAuthrite: false
        };
        return options;
    }
    constructor(chain, serviceUrl, options) {
        this.chain = chain;
        this.serviceUrl = serviceUrl;
        this.options = options || ChaintracksServiceClient.createChaintracksServiceClientOptions();
    }
    subscribeHeaders(listener) {
        throw new Error('Method not implemented.');
    }
    subscribeReorgs(listener) {
        throw new Error('Method not implemented.');
    }
    unsubscribe(subscriptionId) {
        throw new Error('Method not implemented.');
    }
    async currentHeight() {
        return await this.getPresentHeight();
    }
    async isValidRootForHeight(root, height) {
        const r = await this.findHeaderForHeight(height);
        if (!r)
            return false;
        const isValid = root === (0, utilityHelpers_noBuffer_1.asString)(r.merkleRoot);
        return isValid;
    }
    async getJsonOrUndefined(path) {
        let e = undefined;
        for (let retry = 0; retry < 3; retry++) {
            try {
                const r = await fetch(`${this.serviceUrl}${path}`);
                const v = await r.json();
                if (v.status === 'success')
                    return v.value;
                else
                    e = new Error(JSON.stringify(v));
            }
            catch (eu) {
                e = eu;
            }
            if (e && e.name !== 'ECONNRESET')
                break;
        }
        if (e)
            throw e;
    }
    async getJson(path) {
        const r = await this.getJsonOrUndefined(path);
        if (r === undefined)
            throw new Error('Value was undefined. Requested object may not exist.');
        return r;
    }
    async postJsonVoid(path, params) {
        const headers = {};
        headers['Content-Type'] = 'application/json';
        const r = await fetch(`${this.serviceUrl}${path}`, {
            body: JSON.stringify(params),
            method: 'POST',
            headers
            //cache: 'no-cache',
        });
        try {
            const s = await r.json();
            if (s.status === 'success')
                return;
            throw new Error(JSON.stringify(s));
        }
        catch (e) {
            console.log(`Exception: ${JSON.stringify(e)}`);
            throw new Error(JSON.stringify(e));
        }
    }
    //
    // HTTP API FUNCTIONS
    //
    async addHeader(header) {
        const r = await this.postJsonVoid('/addHeaderHex', header);
        if (typeof r === 'string')
            throw new Error(r);
    }
    async startListening() {
        await this.getPresentHeight();
    }
    async listening() {
        await this.getPresentHeight();
    }
    async getChain() {
        return this.chain;
        //return await this.getJson('/getChain')
    }
    async isListening() {
        try {
            await this.getPresentHeight();
            return true;
        }
        catch (_a) {
            return false;
        }
    }
    async isSynchronized() {
        return await this.isListening();
    }
    async getPresentHeight() {
        return await this.getJson('/getPresentHeight');
    }
    async getInfo() {
        return await this.getJson('/getInfo');
    }
    async findChainTipHeader() {
        return await this.getJson('/findChainTipHeaderHex');
    }
    async findChainTipHash() {
        return await this.getJson('/findChainTipHashHex');
    }
    async getHeaders(height, count) {
        return await this.getJson(`/getHeaders?height=${height}&count=${count}`);
    }
    async findHeaderForHeight(height) {
        return await this.getJsonOrUndefined(`/findHeaderHexForHeight?height=${height}`);
    }
    async findHeaderForBlockHash(hash) {
        return await this.getJsonOrUndefined(`/findHeaderHexForBlockHash?hash=${hash}`);
    }
}
exports.ChaintracksServiceClient = ChaintracksServiceClient;
//# sourceMappingURL=ChaintracksServiceClient.js.map