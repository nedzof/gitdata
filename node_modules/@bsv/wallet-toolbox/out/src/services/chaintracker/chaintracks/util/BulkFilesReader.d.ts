import { HeightRange } from './HeightRange';
import { BaseBlockHeader } from '../../../../sdk/WalletServices.interfaces';
import { ChaintracksFsApi } from '../Api/ChaintracksFsApi';
import { ChaintracksStorageBase } from '../Storage/ChaintracksStorageBase';
import { ChaintracksFetchApi } from '../Api/ChaintracksFetchApi';
import { BulkHeaderFile, BulkHeaderFileFs, BulkHeaderFilesInfo, BulkHeaderFileStorage } from './BulkHeaderFile';
/**
 * Breaks available bulk headers stored in multiple files into a sequence of buffers with
 * limited maximum size.
 */
export declare class BulkFilesReader {
    /**
     * Previously validated bulk header files which may pull data from backing storage on demand.
     */
    files: BulkHeaderFile[];
    /**
     * Subset of headers currently being "read".
     */
    range: HeightRange;
    /**
     * Maximum buffer size returned from `read()` in bytes.
     */
    maxBufferSize: number;
    /**
     * "Read pointer", the next height to be "read".
     */
    nextHeight: number | undefined;
    constructor(files: BulkHeaderFile[], range?: HeightRange, maxBufferSize?: number);
    protected setRange(range?: HeightRange): void;
    setMaxBufferSize(maxBufferSize: number | undefined): void;
    private getLastFile;
    get heightRange(): HeightRange;
    private getFileForHeight;
    readBufferForHeightOrUndefined(height: number): Promise<Uint8Array | undefined>;
    readBufferForHeight(height: number): Promise<Uint8Array>;
    readHeaderForHeight(height: number): Promise<BaseBlockHeader>;
    readHeaderForHeightOrUndefined(height: number): Promise<BaseBlockHeader | undefined>;
    /**
     * Returns the Buffer of block headers from the given `file` for the given `range`.
     * If `range` is undefined, the file's full height range is read.
     * The returned Buffer will only contain headers in `file` and in `range`
     * @param file
     * @param range
     */
    private readBufferFromFile;
    private nextFile;
    /**
     * @returns an array containing the next `maxBufferSize` bytes of headers from the files.
     */
    read(): Promise<Uint8Array | undefined>;
    /**
     * Reset the reading process and adjust the range to be read to a new subset of what's available...
     * @param range new range for subsequent `read` calls to return.
     * @param maxBufferSize optionally update largest buffer size for `read` to return
     */
    resetRange(range: HeightRange, maxBufferSize?: number): void;
    validateFiles(): Promise<void>;
    exportHeadersToFs(toFs: ChaintracksFsApi, toHeadersPerFile: number, toFolder: string): Promise<void>;
}
export declare class BulkFilesReaderFs extends BulkFilesReader {
    fs: ChaintracksFsApi;
    constructor(fs: ChaintracksFsApi, files: BulkHeaderFileFs[], range?: HeightRange, maxBufferSize?: number);
    /**
     * Return a BulkFilesReader configured to access the intersection of `range` and available headers.
     * @param rootFolder
     * @param jsonFilename
     * @param range
     * @returns
     */
    static fromFs(fs: ChaintracksFsApi, rootFolder: string, jsonFilename: string, range?: HeightRange, maxBufferSize?: number): Promise<BulkFilesReaderFs>;
    static writeEmptyJsonFile(fs: ChaintracksFsApi, rootFolder: string, jsonFilename: string): Promise<string>;
    static readJsonFile(fs: ChaintracksFsApi, rootFolder: string, jsonFilename: string, failToEmptyRange?: boolean): Promise<BulkHeaderFilesInfo>;
}
export declare class BulkFilesReaderStorage extends BulkFilesReader {
    constructor(storage: ChaintracksStorageBase, files: BulkHeaderFileStorage[], range?: HeightRange, maxBufferSize?: number);
    static fromStorage(storage: ChaintracksStorageBase, fetch?: ChaintracksFetchApi, range?: HeightRange, maxBufferSize?: number): Promise<BulkFilesReaderStorage>;
}
//# sourceMappingURL=BulkFilesReader.d.ts.map