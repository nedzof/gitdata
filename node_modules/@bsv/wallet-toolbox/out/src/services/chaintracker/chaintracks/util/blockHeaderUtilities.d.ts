import { BigNumber } from '@bsv/sdk';
import { Chain } from '../../../../sdk/types';
import { ChaintracksFsApi } from '../Api/ChaintracksFsApi';
import { BulkHeaderFileInfo } from './BulkHeaderFile';
import { ChaintracksFetchApi } from '../Api/ChaintracksFetchApi';
import { BaseBlockHeader, BlockHeader } from '../../../../sdk/WalletServices.interfaces';
/**
 * Computes sha256 hash of file contents read as bytes with no encoding.
 * @param filepath Full filepath to file.
 * @param bufferSize Optional read buffer size to use. Defaults to 80,000 bytes. Currently ignored.
 * @returns `{hash, length}` where `hash` is base64 string form of file hash and `length` is file length in bytes.
 */
export declare function sha256HashOfBinaryFile(fs: ChaintracksFsApi, filepath: string, bufferSize?: number): Promise<{
    hash: string;
    length: number;
}>;
/**
 * Validates the contents of a bulk header file.
 * @param bf BulkHeaderFileInfo containing `data` to validate.
 * @param prevHash Required previous header hash.
 * @param prevChainWork Required previous chain work.
 * @param fetch Optional ChaintracksFetchApi instance for fetching data.
 * @returns Validated BulkHeaderFileInfo with `validated` set to true.
 */
export declare function validateBulkFileData(bf: BulkHeaderFileInfo, prevHash: string, prevChainWork: string, fetch?: ChaintracksFetchApi): Promise<BulkHeaderFileInfo>;
/**
 * Validate headers contained in an array of bytes. The headers must be consecutive block headers, 80 bytes long,
 *  where the hash of each header equals the previousHash of the following header.
 * @param buffer Buffer of headers to be validated.
 * @param previousHash Expected previousHash of first header.
 * @param offset Optional starting offset within `buffer`.
 * @param count Optional number of headers to validate. Validates to end of buffer if missing.
 * @returns Header hash of last header validated or previousHash if there where none.
 */
export declare function validateBufferOfHeaders(buffer: Uint8Array, previousHash: string, offset?: number, count?: number, previousChainWork?: string): {
    lastHeaderHash: string;
    lastChainWork: string | undefined;
};
/**
 * Verifies that buffer begins with valid genesis block header for the specified chain.
 * @param buffer
 * @param chain
 */
export declare function validateGenesisHeader(buffer: Uint8Array, chain: Chain): void;
/**
 * @param work chainWork as a BigNumber
 * @returns Converted chainWork value from BN to hex string of 32 bytes.
 */
export declare function workBNtoBuffer(work: BigNumber): string;
/**
 * Returns true if work1 is more work (greater than) work2
 */
export declare function isMoreWork(work1: string, work2: string): boolean;
/**
 * Add two Buffer encoded chainwork values
 * @returns Sum of work1 + work2 as Buffer encoded chainWork value
 */
export declare function addWork(work1: string, work2: string): string;
/**
 * Subtract Buffer encoded chainwork values
 * @returns work1 - work2 as Buffer encoded chainWork value
 */
export declare function subWork(work1: string, work2: string): string;
/**
 * Computes "target" value for 4 byte Bitcoin block header "bits" value.
 * @param bits number or converted from Buffer using `readUint32LE`
 * @returns 32 byte Buffer with "target" value
 */
export declare function convertBitsToTarget(bits: number | number[]): BigNumber;
/**
 * Computes "chainWork" value for 4 byte Bitcoin block header "bits" value.
 * @param bits number or converted from Buffer using `readUint32LE`
 * @returns 32 byte Buffer with "chainWork" value
 */
export declare function convertBitsToWork(bits: number | number[]): string;
export declare function deserializeBaseBlockHeaders(buffer: number[] | Uint8Array, offset?: number, count?: number | undefined): BaseBlockHeader[];
export declare function deserializeBlockHeaders(firstHeight: number, buffer: number[] | Uint8Array, offset?: number, count?: number | undefined): BlockHeader[];
/**
 * Given a block header, ensures that its format is correct. This does not
 * check its difficulty or validity relative to the chain of headers.
 *
 * Throws on format errors.
 *
 * @param The header to validate
 *
 * @returns true if the header is correctly formatted
 */
export declare function validateHeaderFormat(header: BlockHeader): void;
/**
 * Ensures that a header has a valid proof-of-work
 * Requires chain is 'main'
 *
 * @param header The header to validate
 *
 * @returns true if the header is valid
 */
export declare function validateHeaderDifficulty(hash: Buffer, bits: number): boolean;
/**
 * Computes double sha256 hash of bitcoin block header
 * bytes are reversed to bigendian order
 *
 * If header is a Buffer, it is required to 80 bytes long
 * and in standard block header serialized encoding.
 *
 * @returns doule sha256 hash of header bytes reversed
 * @publicbody
 */
export declare function blockHash(header: BaseBlockHeader | number[] | Uint8Array): string;
/**
 * Serializes a block header as an 80 byte Buffer.
 * The exact serialized format is defined in the Bitcoin White Paper
 * such that computing a double sha256 hash of the buffer computes
 * the block hash for the header.
 * @returns 80 byte Buffer
 * @publicbody
 */
export declare function serializeBaseBlockHeader(header: BaseBlockHeader, buffer?: number[], offset?: number): number[];
export declare function serializeBaseBlockHeaders(headers: BlockHeader[]): Uint8Array;
/**
 * Deserialize a BaseBlockHeader from an 80 byte buffer
 * @publicbody
 */
export declare function deserializeBaseBlockHeader(buffer: number[] | Uint8Array, offset?: number): BaseBlockHeader;
export declare function deserializeBlockHeader(buffer: number[] | Uint8Array, offset: number | undefined, height: number): BlockHeader;
/**
 * Returns the genesis block for the specified chain.
 * @publicbody
 */
export declare function genesisHeader(chain: Chain): BlockHeader;
/**
 * Returns the genesis block for the specified chain.
 * @publicbody
 */
export declare function genesisBuffer(chain: Chain): number[];
/**
 * Returns a copy of a Buffer with byte order reversed.
 * @returns new buffer with byte order reversed.
 * @publicbody
 */
export declare function swapByteOrder(buffer: number[]): number[];
/**
 * @param num a number value in the Uint32 value range
 * @param littleEndian true for little-endian byte order in Buffer
 * @returns four byte buffer with Uint32 number encoded
 * @publicbody
 */
export declare function convertUint32ToBuffer(n: number, littleEndian?: boolean): number[];
export declare function writeUInt32LE(n: number, a: number[] | Uint8Array, offset: number): number;
export declare function writeUInt32BE(n: number, a: number[] | Uint8Array, offset: number): number;
export declare function readUInt32LE(a: number[] | Uint8Array, offset: number): number;
export declare function readUInt32BE(a: number[] | Uint8Array, offset: number): number;
/**
 * @param buffer four byte buffer with Uint32 number encoded
 * @param littleEndian true for little-endian byte order in Buffer
 * @returns a number value in the Uint32 value range
 * @publicbody
 */
export declare function convertBufferToUint32(buffer: number[] | Uint8Array, littleEndian?: boolean): number;
//# sourceMappingURL=blockHeaderUtilities.d.ts.map