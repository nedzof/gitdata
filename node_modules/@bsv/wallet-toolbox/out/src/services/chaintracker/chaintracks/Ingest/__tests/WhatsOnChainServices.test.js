"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const blockHeaderUtilities_1 = require("../../util/blockHeaderUtilities");
const ChaintracksFetch_1 = require("../../util/ChaintracksFetch");
const WhatsOnChainServices_1 = require("../WhatsOnChainServices");
const WhatsOnChainIngestorWs_1 = require("../WhatsOnChainIngestorWs");
const HeightRange_1 = require("../../util/HeightRange");
describe('WhatsOnChainServices tests', () => {
    jest.setTimeout(999999999);
    const chain = 'main';
    const options = WhatsOnChainServices_1.WhatsOnChainServices.createWhatsOnChainServicesOptions(chain);
    const woc = new WhatsOnChainServices_1.WhatsOnChainServices(options);
    test('getHeaderByHash', async () => {
        const header = await woc.getHeaderByHash('000000000000000001b3e99847d57ff3e0bfc4222cea5c29f10bf24387a250a2');
        expect((header === null || header === void 0 ? void 0 : header.height) === 781348).toBe(true);
    });
    test('getChainTipHeight', async () => {
        const height = await woc.getChainTipHeight();
        expect(height > 600000).toBe(true);
    });
    const stopOldListenersToken = { stop: undefined };
    function stopOldListener() {
        var _a;
        (_a = stopOldListenersToken.stop) === null || _a === void 0 ? void 0 : _a.call(stopOldListenersToken);
    }
    test.skip('0 listenForOldBlockHeaders', async () => {
        // The service this depends on appears to be deprecated...
        const height = await woc.getChainTipHeight();
        expect(height > 600000).toBe(true);
        const headersOld = [];
        const errorsOld = [];
        const okOld = await (0, WhatsOnChainIngestorWs_1.WocHeadersBulkListener)(height - 4, height, h => headersOld.push(h), (code, message) => {
            errorsOld.push({ code, message });
            return true;
        }, stopOldListenersToken, chain);
        expect(okOld).toBe(true);
        expect(errorsOld.length).toBe(0);
        expect(headersOld.length >= 4).toBe(true);
    });
    const stopNewListenersToken = { stop: undefined };
    test.skip('1 listenForNewBlockHeaders', async () => {
        // The service this depends on appears to be deprecated...
        const height = await woc.getChainTipHeight();
        expect(height > 600000).toBe(true);
        // Comment out this line to just wait for next new header...
        //setTimeout(() => woc.stopNewListener(), 5000)
        const headersNew = [];
        const errorsNew = [];
        const eh = h => {
            var _a;
            headersNew.push(h);
            if (headersNew.length >= 1)
                (_a = stopNewListenersToken.stop) === null || _a === void 0 ? void 0 : _a.call(stopNewListenersToken);
        };
        const errh = (code, message) => {
            errorsNew.push({ code, message });
            return true;
        };
        const okNew = await (0, WhatsOnChainIngestorWs_1.WocHeadersLiveListener)(eh, errh, stopNewListenersToken, chain, console.log.bind(console));
        if (errorsNew.length > 0)
            console.log(JSON.stringify(errorsNew));
        expect(errorsNew.length).toBe(0);
        expect(okNew).toBe(true);
        expect(headersNew.length >= 0).toBe(true);
    });
    test('2 get latest header bytes', async () => {
        const fetch = new ChaintracksFetch_1.ChaintracksFetch();
        //for (;;) {
        const bytes = await fetch.download(`https://api.whatsonchain.com/v1/bsv/main/block/headers/latest`);
        console.log(`headers: ${bytes.length / 80}`);
        const latest = await fetch.download(`https://api.whatsonchain.com/v1/bsv/main/block/headers/latest?count=1`);
        const bh = (0, blockHeaderUtilities_1.deserializeBlockHeader)(latest, 0, 0);
        console.log(`latest hash: ${bh.hash} at ${new Date().toISOString()}`);
        //  await wait(60 * 1000)
        //}
    });
    test('3 get headers', async () => {
        const fetch = new ChaintracksFetch_1.ChaintracksFetch();
        //for (;;) {
        const headers = await fetch.fetchJson(`https://api.whatsonchain.com/v1/bsv/main/block/headers`);
        let log = '';
        for (const h of headers) {
            log += `${h.height} ${h.hash} ${h.confirmations} ${h.nTx}\n`;
        }
        console.log(`${new Date().toISOString()}\n${log}`);
        //await wait(60 * 1000)
        //}
    });
    test('4 get header byte file links', async () => {
        const fetch = new ChaintracksFetch_1.ChaintracksFetch();
        const woc = new WhatsOnChainServices_1.WhatsOnChainServices(WhatsOnChainServices_1.WhatsOnChainServices.createWhatsOnChainServicesOptions('main'));
        const files = await woc.getHeaderByteFileLinks(new HeightRange_1.HeightRange(907123, 911000));
        expect(files.length).toBe(3);
        expect(files[0].range.minHeight).toBe(906001);
        expect(files[0].range.maxHeight).toBe(908000);
        expect(files[1].range.minHeight).toBe(908001);
        expect(files[1].range.maxHeight).toBe(910000);
        expect(files[2].range.minHeight).toBe(910001);
        expect(files[2].range.maxHeight).toBeGreaterThan(910001);
    });
});
//# sourceMappingURL=WhatsOnChainServices.test.js.map