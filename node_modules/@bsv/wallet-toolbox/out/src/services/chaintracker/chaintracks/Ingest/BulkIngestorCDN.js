"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BulkIngestorCDN = void 0;
const BulkIngestorBase_1 = require("./BulkIngestorBase");
const sdk_1 = require("../../../../sdk");
const BulkFileDataManager_1 = require("../util/BulkFileDataManager");
class BulkIngestorCDN extends BulkIngestorBase_1.BulkIngestorBase {
    /**
     *
     * @param chain
     * @param localCachePath defaults to './data/bulk_cdn_headers/'
     * @returns
     */
    static createBulkIngestorCDNOptions(chain, cdnUrl, fetch, maxPerFile) {
        const options = {
            ...BulkIngestorBase_1.BulkIngestorBase.createBulkIngestorBaseOptions(chain),
            fetch,
            jsonResource: `${chain}NetBlockHeaders.json`,
            cdnUrl,
            maxPerFile
        };
        return options;
    }
    constructor(options) {
        super(options);
        if (!options.jsonResource)
            throw new Error('The jsonResource options property is required.');
        if (!options.cdnUrl)
            throw new Error('The cdnUrl options property is required.');
        this.fetch = options.fetch;
        this.jsonResource = options.jsonResource;
        this.cdnUrl = options.cdnUrl;
        this.maxPerFile = options.maxPerFile;
    }
    async getPresentHeight() {
        return undefined;
    }
    getJsonHttpHeaders() {
        const headers = {
            Accept: 'application/json'
        };
        return headers;
    }
    /**
     * A BulkFile CDN serves a JSON BulkHeaderFilesInfo resource which lists all the available binary bulk header files available and associated metadata.
     *
     * The term "CDN file" is used for a local bulk file that has a sourceUrl. (Not undefined)
     * The term "incremental file" is used for the local bulk file that holds all the non-CDN bulk headers and must chain to the live headers if there are any.
     *
     * Bulk ingesting from a CDN happens in one of three contexts:
     *
     * 1. Cold Start: No local bulk or live headers.
     * 2. Incremental: Available CDN files extend into an existing incremental file but not into the live headers.
     * 3. Replace: Available CDN files extend into live headers.
     *
     * Context Cold Start:
     * - The CDN files are selected in height order, starting at zero, always choosing the largest count less than the local maximum (maxPerFile).
     *
     * Context Incremental:
     * - Last existing CDN file is updated if CDN now has a higher count.
     * - Additional CDN files are added as in Cold Start.
     * - The existing incremental file is truncated or deleted.
     *
     * Context Replace:
     * - Existing live headers are truncated or deleted.
     * - Proceed as context Incremental.
     *
     * @param before bulk and live range of headers before ingesting any new headers.
     * @param fetchRange total range of header heights needed including live headers
     * @param bulkRange range of missing bulk header heights required.
     * @param priorLiveHeaders
     * @returns
     */
    async fetchHeaders(before, fetchRange, bulkRange, priorLiveHeaders) {
        const storage = this.storage();
        const toUrl = (file) => this.fetch.pathJoin(this.cdnUrl, file);
        const url = toUrl(this.jsonResource);
        this.availableBulkFiles = await this.fetch.fetchJson(url);
        if (!this.availableBulkFiles) {
            throw new sdk_1.WERR_INVALID_PARAMETER(`${this.jsonResource}`, `a valid BulkHeaderFilesInfo JSON resource available from ${url}`);
        }
        this.selectedFiles = (0, BulkFileDataManager_1.selectBulkHeaderFiles)(this.availableBulkFiles.files, this.chain, this.maxPerFile || this.availableBulkFiles.headersPerFile);
        for (const bf of this.selectedFiles) {
            if (!bf.fileHash) {
                throw new sdk_1.WERR_INVALID_PARAMETER(`fileHash`, `valid for alll files in ${this.jsonResource} from ${url}`);
            }
            if (!bf.chain || bf.chain !== this.chain) {
                throw new sdk_1.WERR_INVALID_PARAMETER(`chain`, `"${this.chain}" for all files in ${this.jsonResource} from ${url}`);
            }
            if (!bf.sourceUrl || bf.sourceUrl !== this.cdnUrl)
                bf.sourceUrl = this.cdnUrl;
        }
        let log = 'BulkIngestorCDN fetchHeaders log:\n';
        log += `  url: ${url}\n`;
        this.currentRange = await storage.bulkManager.getHeightRange();
        log += `  bulk range before: ${this.currentRange}\n`;
        const r = await storage.bulkManager.merge(this.selectedFiles);
        this.currentRange = await storage.bulkManager.getHeightRange();
        log += `  bulk range after:  ${this.currentRange}\n`;
        for (const u of r.unchanged) {
            log += `  unchanged: ${u.fileName}, fileId=${u.fileId}\n`;
        }
        for (const i of r.inserted) {
            log += `  inserted: ${i.fileName}, fileId=${i.fileId}\n`;
        }
        for (const u of r.updated) {
            log += `  updated: ${u.fileName}, fileId=${u.fileId}\n`;
        }
        this.log(log);
        return priorLiveHeaders;
    }
}
exports.BulkIngestorCDN = BulkIngestorCDN;
//# sourceMappingURL=BulkIngestorCDN.js.map