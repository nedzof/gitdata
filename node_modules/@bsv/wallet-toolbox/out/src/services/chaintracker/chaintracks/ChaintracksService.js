"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ChaintracksService = void 0;
const Chaintracks_1 = require("./Chaintracks");
const express_1 = __importDefault(require("express"));
const body_parser_1 = __importDefault(require("body-parser"));
const createDefaultNoDbChaintracksOptions_1 = require("./createDefaultNoDbChaintracksOptions");
const Services_1 = require("../../Services");
const sdk_1 = require("../../../sdk");
const utilityHelpers_1 = require("../../../utility/utilityHelpers");
class ChaintracksService {
    static createChaintracksServiceOptions(chain) {
        const options = {
            chain,
            routingPrefix: ''
        };
        return options;
    }
    constructor(options) {
        this.options = { ...options };
        this.port = options.port;
        this.chain = options.chain;
        this.chaintracks = options.chaintracks || new Chaintracks_1.Chaintracks((0, createDefaultNoDbChaintracksOptions_1.createNoDbChaintracksOptions)(this.chain));
        this.services = options.services || new Services_1.Services(this.chain);
        // Prevent recursion...
        this.services.updateFiatExchangeRateServices.remove('ChaintracksService');
        if (this.chaintracks.chain !== this.chain || this.services.chain !== this.chain) {
            throw new sdk_1.WERR_INVALID_PARAMETER('chain', `All components (chaintracks and services) must be on chain ${this.chain}`);
        }
    }
    async stopJsonRpcServer() {
        var _a, _b;
        (_a = this.server) === null || _a === void 0 ? void 0 : _a.close();
        await ((_b = this.chaintracks) === null || _b === void 0 ? void 0 : _b.destroy());
    }
    async startJsonRpcServer(port) {
        await this.chaintracks.makeAvailable();
        port || (port = this.port || 3011);
        this.port = port;
        const app = (0, express_1.default)();
        app.use(body_parser_1.default.json());
        // This allows the API to be used when CORS is enforced
        app.use((req, res, next) => {
            res.header('Access-Control-Allow-Origin', '*');
            res.header('Access-Control-Allow-Headers', '*');
            res.header('Access-Control-Allow-Methods', '*');
            res.header('Access-Control-Expose-Headers', '*');
            res.header('Access-Control-Allow-Private-Network', 'true');
            if (req.method === 'OPTIONS') {
                res.sendStatus(200);
            }
            else {
                next();
            }
        });
        app.get(`/robots.txt`, (req, res) => {
            res.type('text/plain');
            res.send(`User-agent: *\nDisallow: /`);
        });
        app.get(`/`, (req, res) => {
            res.type('text/plain');
            res.send(`Chaintracks ${this.chain}Net Block Header Service`);
        });
        const handleErr = (err, res) => {
            res.status(500).json({
                status: 'error',
                code: 'ERR_INTERNAL',
                description: (err === null || err === void 0 ? void 0 : err.message) || 'An internal error has occurred.'
            });
        };
        const appGetVoid = (path, action, noCache = false) => {
            app['get'](this.options.routingPrefix + path, async (req, res) => {
                if (noCache) {
                    res.setHeader('Cache-Control', 'no-cache, no-store, must-revalidate');
                    res.setHeader('Pragma', 'no-cache');
                    res.setHeader('Expires', '0');
                }
                try {
                    console.log(`request ${path}`);
                    await action(req.query);
                    res.status(200).json({ status: 'success' });
                }
                catch (err) {
                    handleErr(err, res);
                }
            });
        };
        const appGet = (path, action, noCache = false) => {
            app['get'](this.options.routingPrefix + path, async (req, res) => {
                if (noCache) {
                    res.setHeader('Cache-Control', 'no-cache, no-store, must-revalidate');
                    res.setHeader('Pragma', 'no-cache');
                    res.setHeader('Expires', '0');
                }
                try {
                    const r = await action(req.query);
                    console.log('request', path, JSON.stringify(req.query), '->', JSON.stringify(r));
                    res.status(200).json({ status: 'success', value: r });
                }
                catch (err) {
                    console.log(`request ${path} -> error`);
                    handleErr(err, res);
                }
            });
        };
        const appPostVoid = (path, action) => {
            app['post'](this.options.routingPrefix + path, async (req, res) => {
                try {
                    console.log(`request POST ${path}`);
                    await action(req.body);
                    res.status(200).json({ status: 'success' });
                }
                catch (err) {
                    handleErr(err, res);
                }
            });
        };
        appGet('/getChain', async () => await this.chaintracks.getChain());
        appGet('/getInfo', async (q) => {
            if (q.wait)
                await (0, utilityHelpers_1.wait)(Number(q.wait));
            const r = await this.chaintracks.getInfo();
            if (q.wait)
                r['wait'] = q.wait;
            return r;
        }, true);
        appGet('/getFiatExchangeRates', async () => {
            // update if needed
            await this.services.getFiatExchangeRate('GBP');
            // return current values
            return this.services.options.fiatExchangeRates;
        }, true);
        appPostVoid('/addHeaderHex', async (header) => {
            await this.chaintracks.addHeader(header);
        });
        appGet('/getPresentHeight', async () => await this.chaintracks.getPresentHeight(), true);
        appGet('/findChainTipHashHex', async () => (await this.chaintracks.findChainTipHash()) || '', true);
        appGet('/findChainTipHeaderHex', async () => await this.chaintracks.findChainTipHeader(), true);
        appGet('/findHeaderHexForHeight', async (q) => {
            return await this.chaintracks.findHeaderForHeight(Number(q.height));
        });
        appGet('/findHeaderHexForBlockHash', async (q) => {
            return await this.chaintracks.findLiveHeaderForBlockHash(q.hash);
        });
        appGet('/getHeaders', async (q) => {
            return await this.chaintracks.getHeaders(Number(q.height), Number(q.count));
        });
        this.server = app.listen(this.port, () => {
            console.log(`ChaintracksService listening on port ${this.port}`);
        });
    }
}
exports.ChaintracksService = ChaintracksService;
//# sourceMappingURL=ChaintracksService.js.map