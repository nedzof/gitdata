"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const TestUtilsWalletStorage_1 = require("../../utils/TestUtilsWalletStorage");
const index_client_1 = require("../../../src/index.client");
const StorageIdb_1 = require("../../../src/storage/StorageIdb");
require("fake-indexeddb/auto");
describe('idb transactionAbort tests', () => {
    jest.setTimeout(99999999);
    const chain = 'test';
    const env = TestUtilsWalletStorage_1._tu.getEnv(chain);
    let setups = [];
    beforeEach(async () => {
        const options = index_client_1.StorageProvider.createStorageBaseOptions(chain);
        const storage = new StorageIdb_1.StorageIdb(options);
        await storage.dropAllData();
        await storage.migrate('idb find tests', '1'.repeat(64));
        await storage.makeAvailable();
        const setup1 = await TestUtilsWalletStorage_1._tu.createTestSetup1(storage);
        const u1tx2 = (await TestUtilsWalletStorage_1._tu.insertTestTransaction(storage, setup1.u1, false, { status: 'completed' })).tx;
        const setup2 = {
            ...setup1,
            u1tx2,
            u1tx2o0: await TestUtilsWalletStorage_1._tu.insertTestOutput(storage, u1tx2, 0, 3, setup1.u1basket1),
            u1tx2o1: await TestUtilsWalletStorage_1._tu.insertTestOutput(storage, u1tx2, 1, 13, setup1.u1basket1),
            u1tx2o2: await TestUtilsWalletStorage_1._tu.insertTestOutput(storage, u1tx2, 2, 113, setup1.u1basket1),
            u1tx2o3: await TestUtilsWalletStorage_1._tu.insertTestOutput(storage, u1tx2, 3, 1113, setup1.u1basket1),
            u1tx2o4: await TestUtilsWalletStorage_1._tu.insertTestOutput(storage, u1tx2, 4, 11113, setup1.u1basket1),
            u1tx2o5: await TestUtilsWalletStorage_1._tu.insertTestOutput(storage, u1tx2, 5, 111113, setup1.u1basket1),
            u1tx2o6: await TestUtilsWalletStorage_1._tu.insertTestOutput(storage, u1tx2, 6, 1111113, setup1.u1basket1),
            u1tx2o7: await TestUtilsWalletStorage_1._tu.insertTestOutput(storage, u1tx2, 7, 11111113, setup1.u1basket1),
            u1tx2o8: await TestUtilsWalletStorage_1._tu.insertTestOutput(storage, u1tx2, 8, 111111113, setup1.u1basket1),
            u1tx3: (await TestUtilsWalletStorage_1._tu.insertTestTransaction(storage, setup1.u1, false, { status: 'completed' })).tx,
            u1tx4: (await TestUtilsWalletStorage_1._tu.insertTestTransaction(storage, setup1.u1, false, { status: 'unproven' })).tx,
            u1tx5: (await TestUtilsWalletStorage_1._tu.insertTestTransaction(storage, setup1.u1, false, { status: 'sending' })).tx
        };
        setups = [{ setup: setup2, storage }];
    });
    afterEach(async () => {
        for (const { storage } of setups) {
            await storage.destroy();
        }
    });
    test('0 basket with no outputs', async () => {
        for (const { storage, setup } of setups) {
            const r = await storage.allocateChangeInput(setup.u1.userId, 42, 11113, 11113, true, setup.u1tx3.transactionId);
            expect(r).toBeUndefined();
        }
    });
    test('1 exactSatoshis', async () => {
        for (const { storage, setup } of setups) {
            const r = await storage.allocateChangeInput(setup.u1.userId, setup.u1basket1.basketId, 11113, 11113, true, setup.u1tx3.transactionId);
            expect(r === null || r === void 0 ? void 0 : r.outputId).toBe(setup.u1tx2o4.outputId);
            const r2 = await storage.allocateChangeInput(setup.u1.userId, setup.u1basket1.basketId, 11113, 11113, true, setup.u1tx3.transactionId);
            expect(r2 === null || r2 === void 0 ? void 0 : r2.outputId).toBe(setup.u1tx2o5.outputId);
        }
    });
    test('2 targetSatoshis exact', async () => {
        for (const { storage, setup } of setups) {
            const r = await storage.allocateChangeInput(setup.u1.userId, setup.u1basket1.basketId, 11113, undefined, true, setup.u1tx3.transactionId);
            expect(r === null || r === void 0 ? void 0 : r.outputId).toBe(setup.u1tx2o4.outputId);
            const r2 = await storage.allocateChangeInput(setup.u1.userId, setup.u1basket1.basketId, 11113, undefined, true, setup.u1tx3.transactionId);
            expect(r2 === null || r2 === void 0 ? void 0 : r2.outputId).toBe(setup.u1tx2o5.outputId);
        }
    });
    test('2a targetSatoshis exact unproven', async () => {
        for (const { storage, setup } of setups) {
            await storage.updateTransaction(setup.u1tx2.transactionId, { status: 'unproven' });
            const r = await storage.allocateChangeInput(setup.u1.userId, setup.u1basket1.basketId, 11113, undefined, true, setup.u1tx3.transactionId);
            expect(r === null || r === void 0 ? void 0 : r.outputId).toBe(setup.u1tx2o4.outputId);
            const r2 = await storage.allocateChangeInput(setup.u1.userId, setup.u1basket1.basketId, 11113, undefined, true, setup.u1tx3.transactionId);
            expect(r2 === null || r2 === void 0 ? void 0 : r2.outputId).toBe(setup.u1tx2o5.outputId);
        }
    });
    test('2b targetSatoshis exact sending', async () => {
        for (const { storage, setup } of setups) {
            await storage.updateTransaction(setup.u1tx2.transactionId, { status: 'sending' });
            const r3 = await storage.allocateChangeInput(setup.u1.userId, setup.u1basket1.basketId, 11113, undefined, true, setup.u1tx3.transactionId);
            expect(r3).toBeUndefined();
            const r = await storage.allocateChangeInput(setup.u1.userId, setup.u1basket1.basketId, 11113, undefined, false, setup.u1tx3.transactionId);
            expect(r === null || r === void 0 ? void 0 : r.outputId).toBe(setup.u1tx2o4.outputId);
            const r2 = await storage.allocateChangeInput(setup.u1.userId, setup.u1basket1.basketId, 11113, undefined, false, setup.u1tx3.transactionId);
            expect(r2 === null || r2 === void 0 ? void 0 : r2.outputId).toBe(setup.u1tx2o5.outputId);
        }
    });
    test('3 targetSatoshis high', async () => {
        for (const { storage, setup } of setups) {
            const r = await storage.allocateChangeInput(setup.u1.userId, setup.u1basket1.basketId, 11114, undefined, true, setup.u1tx3.transactionId);
            expect(r === null || r === void 0 ? void 0 : r.outputId).toBe(setup.u1tx2o5.outputId);
            const r2 = await storage.allocateChangeInput(setup.u1.userId, setup.u1basket1.basketId, 11114, undefined, true, setup.u1tx3.transactionId);
            expect(r2 === null || r2 === void 0 ? void 0 : r2.outputId).toBe(setup.u1tx2o6.outputId);
        }
    });
    test('4 targetSatoshis low', async () => {
        for (const { storage, setup } of setups) {
            const r = await storage.allocateChangeInput(setup.u1.userId, setup.u1basket1.basketId, 11112, undefined, true, setup.u1tx3.transactionId);
            expect(r === null || r === void 0 ? void 0 : r.outputId).toBe(setup.u1tx2o4.outputId);
            const r2 = await storage.allocateChangeInput(setup.u1.userId, setup.u1basket1.basketId, 11112, undefined, true, setup.u1tx3.transactionId);
            expect(r2 === null || r2 === void 0 ? void 0 : r2.outputId).toBe(setup.u1tx2o5.outputId);
        }
    });
    test('5 targetSatoshis above max', async () => {
        for (const { storage, setup } of setups) {
            const r = await storage.allocateChangeInput(setup.u1.userId, setup.u1basket1.basketId, 111111114, undefined, true, setup.u1tx3.transactionId);
            expect(r === null || r === void 0 ? void 0 : r.outputId).toBe(setup.u1tx2o8.outputId);
            const r2 = await storage.allocateChangeInput(setup.u1.userId, setup.u1basket1.basketId, 111111114, undefined, true, setup.u1tx3.transactionId);
            expect(r2 === null || r2 === void 0 ? void 0 : r2.outputId).toBe(setup.u1tx2o7.outputId);
        }
    });
});
//# sourceMappingURL=allocateChange.test.js.map