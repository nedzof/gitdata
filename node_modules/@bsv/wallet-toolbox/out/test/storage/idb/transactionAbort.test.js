"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const TestUtilsWalletStorage_1 = require("../../utils/TestUtilsWalletStorage");
const index_client_1 = require("../../../src/index.client");
const StorageIdb_1 = require("../../../src/storage/StorageIdb");
require("fake-indexeddb/auto");
describe('idb transactionAbort tests', () => {
    jest.setTimeout(99999999);
    let storages = [];
    const chain = 'test';
    const env = TestUtilsWalletStorage_1._tu.getEnv(chain);
    beforeEach(async () => {
        storages = [];
        const options = index_client_1.StorageProvider.createStorageBaseOptions(chain);
        storages.push(new StorageIdb_1.StorageIdb(options));
        for (const storage of storages) {
            await storage.dropAllData();
            await storage.migrate('insert tests', '1'.repeat(64));
        }
    });
    afterEach(async () => {
        for (const storage of storages) {
            await storage.destroy();
            await new Promise(resolve => setTimeout(resolve, 0)); // Allow fake-indexeddb to clean up
        }
    });
    test('0 unaborted case', async () => {
        for (const storage of storages) {
            let aborted = false;
            let count = await storage.countProvenTxs({ partial: {} });
            expect(count).toBe(0);
            try {
                const r = await storage.transaction(async (tx) => {
                    const r12 = await TestUtilsWalletStorage_1._tu.insertTestProvenTx(storage, '12'.repeat(32), tx);
                    const r23 = await TestUtilsWalletStorage_1._tu.insertTestProvenTx(storage, '23'.repeat(32), tx);
                    //tx['abort']()
                    return [r12.provenTxId, r23.provenTxId];
                });
                expect(r).toEqual([1, 2]);
            }
            catch (e) {
                aborted = true;
                (0, TestUtilsWalletStorage_1.logger)('Transaction aborted', e === null || e === void 0 ? void 0 : e['name']);
            }
            expect(aborted).toBe(false);
            count = await storage.countProvenTxs({ partial: {} });
            expect(count).toBe(2);
        }
    });
    test('1 call abort case', async () => {
        for (const storage of storages) {
            let aborted = false;
            let count = await storage.countProvenTxs({ partial: {} });
            expect(count).toBe(0);
            try {
                const r = await storage.transaction(async (tx) => {
                    const r12 = await TestUtilsWalletStorage_1._tu.insertTestProvenTx(storage, '12'.repeat(32), tx);
                    const r23 = await TestUtilsWalletStorage_1._tu.insertTestProvenTx(storage, '23'.repeat(32), tx);
                    tx['abort']();
                    return [r12.provenTxId, r23.provenTxId];
                });
                expect(r).toEqual([1, 2]);
            }
            catch (e) {
                aborted = true;
                (0, TestUtilsWalletStorage_1.logger)('Transaction aborted', e === null || e === void 0 ? void 0 : e['name']);
            }
            expect(aborted).toBe(true);
            count = await storage.countProvenTxs({ partial: {} });
            expect(count).toBe(0);
        }
    });
    test('2 throw error case', async () => {
        for (const storage of storages) {
            let aborted = false;
            let count = await storage.countProvenTxs({ partial: {} });
            expect(count).toBe(0);
            try {
                const r = await storage.transaction(async (tx) => {
                    const r12 = await TestUtilsWalletStorage_1._tu.insertTestProvenTx(storage, '12'.repeat(32), tx);
                    const r23 = await TestUtilsWalletStorage_1._tu.insertTestProvenTx(storage, '23'.repeat(32), tx);
                    throw new Error('Test error');
                    return [r12.provenTxId, r23.provenTxId];
                });
                expect(r).toEqual([1, 2]);
            }
            catch (e) {
                aborted = true;
                (0, TestUtilsWalletStorage_1.logger)('Transaction aborted', e === null || e === void 0 ? void 0 : e['name']);
            }
            expect(aborted).toBe(true);
            count = await storage.countProvenTxs({ partial: {} });
            expect(count).toBe(0);
        }
    });
});
//# sourceMappingURL=transactionAbort.test.js.map