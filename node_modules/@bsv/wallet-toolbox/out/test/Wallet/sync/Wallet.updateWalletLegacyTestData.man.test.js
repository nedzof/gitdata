"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
const src_1 = require("../../../src");
const index_client_1 = require("../../../src/index.client");
const TaskPurge_1 = require("../../../src/monitor/tasks/TaskPurge");
const sync_1 = require("../../../src/storage/sync");
const TestUtilsWalletStorage_1 = require("../../utils/TestUtilsWalletStorage");
const dotenv = __importStar(require("dotenv"));
dotenv.config();
const main_satoshi_shop = process.env.SATOSHI_SHOP_MAIN_IDENTITY || '';
/**
 * NOTICE: These tests are designed to chain one after the other.
 * Disable the "await WaitFor*()" lines to run them individually.
 *
 * The inital import from staging dojo takes around 100 seconds... be patient.
 */
describe('Wallet sync tests', () => {
    jest.setTimeout(99999999);
    beforeAll(async () => { });
    afterAll(async () => { });
    let doWait = false;
    let done0 = false;
    const waitFor0 = async () => {
        while (doWait && !done0)
            await (0, index_client_1.wait)(100);
    };
    let done1 = false;
    const waitFor1 = async () => {
        while (doWait && !done1)
            await (0, index_client_1.wait)(100);
    };
    let done2 = false;
    const waitFor2 = async () => {
        while (doWait && !done2)
            await (0, index_client_1.wait)(100);
    };
    const env = TestUtilsWalletStorage_1._tu.getEnv('test');
    const identityKeyTone = '03ac2d10bdb0023f4145cc2eba2fcd2ad3070cb2107b0b48170c46a9440e4cc3fe';
    const rootKeyHex = env.devKeys[identityKeyTone];
    test('0 sync staging dojo to local MySQL', async () => {
        console.log('Importing from staging dojo to local MySQL stagingdojotone');
        const chain = 'test';
        const connection = JSON.parse(process.env.TEST_DOJO_CONNECTION || '');
        const readerKnex = TestUtilsWalletStorage_1._tu.createMySQLFromConnection(connection);
        const reader = new sync_1.StorageMySQLDojoReader({ chain, knex: readerKnex });
        const writer = await TestUtilsWalletStorage_1._tu.createMySQLTestWallet({
            databaseName: 'stagingdojotone',
            chain: 'test',
            rootKeyHex,
            dropAll: true
        });
        const identityKey = writer.identityKey;
        await writer.storage.syncFromReader(identityKey, new index_client_1.StorageSyncReader({ identityKey }, reader));
        await reader.destroy();
        await writer.activeStorage.destroy();
        done0 = true;
    });
    test.skip('0a sync production dojo to local MySQL', async () => {
        const chain = 'main';
        const env = TestUtilsWalletStorage_1._tu.getEnv(chain);
        console.log('Importing from production dojo to local MySQL productiondojotone');
        const identityKey = main_satoshi_shop;
        const rootKeyHex = env.devKeys[identityKey];
        const connection = JSON.parse(process.env.MAIN_DOJO_CONNECTION || '');
        const readerKnex = TestUtilsWalletStorage_1._tu.createMySQLFromConnection(connection);
        const reader = new sync_1.StorageMySQLDojoReader({ chain, knex: readerKnex });
        const writer = await TestUtilsWalletStorage_1._tu.createMySQLTestWallet({
            databaseName: 'main_satoshi_shop',
            chain: 'main',
            rootKeyHex,
            dropAll: true
        });
        await writer.storage.syncFromReader(identityKey, new index_client_1.StorageSyncReader({ identityKey }, reader));
        await reader.destroy();
        await writer.activeStorage.destroy();
    });
    test.skip('0b sweep mysql dojo sync to another wallet', async () => {
        const chain = 'main';
        const env = TestUtilsWalletStorage_1._tu.getEnv(chain);
        // const prod_faucet = '030b78da8101cd8929ec355c694c275fbaf4f73d4eaa104873463779cac69a2a01' // prod faucet
        // const identityKeyTone = process.env.MY_MAIN_IDENTITY || ''
        const identityKey = main_satoshi_shop;
        const rootKeyHex = env.devKeys[identityKey];
        const sweepFrom = await TestUtilsWalletStorage_1._tu.createMySQLTestWallet({
            databaseName: 'main_satoshi_shop',
            chain,
            rootKeyHex
        });
        const sweepTo = await TestUtilsWalletStorage_1._tu.createTestWalletWithStorageClient({
            rootKeyHex: env.devKeys[env.identityKey],
            chain
        });
        //await sweepTo.activeStorage.updateProvenTxReq(2, { status: 'invalid' })
        //await sweepTo.activeStorage.updateTransactionStatus('failed', 2)
        await sweepFrom.wallet.sweepTo(sweepTo.wallet);
        await sweepTo.wallet.destroy();
        await sweepFrom.wallet.destroy();
    });
    test.skip('1 aggressively purge records from MySQL stagingdojotone', async () => {
        await waitFor0();
        const { monitor, activeStorage } = await TestUtilsWalletStorage_1._tu.createMySQLTestWallet({
            databaseName: 'stagingdojotone',
            chain: 'test',
            rootKeyHex
        });
        {
            const task = new TaskPurge_1.TaskPurge(monitor, {
                purgeCompleted: true,
                purgeFailed: true,
                purgeSpent: true,
                purgeCompletedAge: 1,
                purgeFailedAge: 1,
                purgeSpentAge: 1
            });
            TaskPurge_1.TaskPurge.checkNow = true;
            monitor._tasks.push(task);
            await monitor.runTask('Purge');
        }
        await activeStorage.destroy();
        done1 = true;
    });
    test.skip('2 sync pruned MySQL stagingdojotone to SQLite walletLegacyTestData', async () => {
        await waitFor1();
        console.log('syncing local MySQL stagingdojotone to local SQLite walletLegacyTestData in tmp folder');
        const reader = await TestUtilsWalletStorage_1._tu.createMySQLTestWallet({
            databaseName: 'stagingdojotone',
            chain: 'test',
            rootKeyHex
        });
        const writer = await TestUtilsWalletStorage_1._tu.createSQLiteTestWallet({
            databaseName: 'walletLegacyTestData',
            chain: 'test',
            rootKeyHex,
            dropAll: true
        });
        const identityKey = writer.identityKey;
        await writer.storage.syncFromReader(identityKey, new index_client_1.StorageSyncReader({ identityKey }, reader.activeStorage));
        await reader.activeStorage.destroy();
        await writer.activeStorage.destroy();
        console.log('REMEMBER: copy walletLegacyTestData.sqlite from tmp up to data!');
        done2 = true;
    });
    test.skip('3 sync pruned MySQL stagingdojotone to MySQL walletLegacyTestData', async () => {
        await waitFor2();
        console.log('syncing local MySQL stagingdojotone to local SQLite walletLegacyTestData in tmp folder');
        const reader = await TestUtilsWalletStorage_1._tu.createMySQLTestWallet({
            databaseName: 'stagingdojotone',
            chain: 'test',
            rootKeyHex
        });
        const writer = await TestUtilsWalletStorage_1._tu.createMySQLTestWallet({
            databaseName: 'walletLegacyTestData',
            chain: 'test',
            rootKeyHex,
            dropAll: true
        });
        const identityKey = writer.identityKey;
        await writer.storage.syncFromReader(identityKey, new index_client_1.StorageSyncReader({ identityKey }, reader.activeStorage));
        await reader.activeStorage.destroy();
        await writer.activeStorage.destroy();
    });
    test('8b run monitor mainnet', async () => {
        if (src_1.Setup.noEnv('main'))
            return;
        if (!src_1.Setup.getEnv('main').filePath)
            return;
        // Only run if `Setup` style .env is present with a sqlite filePath...
        const c = await TestUtilsWalletStorage_1._tu.createWalletSetupEnv('main');
        await c.monitor.runOnce();
        await c.wallet.destroy();
    });
});
//# sourceMappingURL=Wallet.updateWalletLegacyTestData.man.test.js.map