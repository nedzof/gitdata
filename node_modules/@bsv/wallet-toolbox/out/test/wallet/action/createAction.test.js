"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/* eslint-disable @typescript-eslint/no-unused-vars */
const sdk_1 = require("@bsv/sdk");
const index_all_1 = require("../../../src/index.all");
const TestUtilsWalletStorage_1 = require("../../utils/TestUtilsWalletStorage");
const includeTestChaintracks = false;
const noLog = true;
describe('createAction test', () => {
    jest.setTimeout(99999999);
    const amount = 1319;
    const env = TestUtilsWalletStorage_1._tu.getEnv('test');
    const testName = () => expect.getState().currentTestName || 'test';
    let ctxs;
    beforeEach(async () => {
        ctxs = [];
        if (env.runMySQL)
            ctxs.push(await TestUtilsWalletStorage_1._tu.createLegacyWalletMySQLCopy('createActionTests'));
        ctxs.push(await TestUtilsWalletStorage_1._tu.createLegacyWalletSQLiteCopy(`${testName()}`));
        TestUtilsWalletStorage_1._tu.mockPostServicesAsSuccess(ctxs);
    });
    afterEach(async () => {
        for (const ctx of ctxs) {
            await ctx.storage.destroy();
        }
    });
    test('0_invalid_params', async () => {
        for (const { wallet } of ctxs) {
            {
                const args = [
                    // description is too short...
                    { description: '' },
                    // no outputs, inputs or sendWith, now legal as isRemixChange transaction
                    //{ description: '12345' },
                    // lockingScript must be hexadecimal
                    {
                        description: '12345',
                        outputs: [
                            {
                                satoshis: 42,
                                lockingScript: 'fred',
                                outputDescription: 'pay fred'
                            }
                        ]
                    },
                    // lockingScript must be even length
                    {
                        description: '12345',
                        outputs: [
                            {
                                satoshis: 42,
                                lockingScript: 'abc',
                                outputDescription: 'pay fred'
                            }
                        ]
                    }
                ];
                for (const a of args) {
                    await (0, TestUtilsWalletStorage_1.expectToThrowWERR)(index_all_1.sdk.WERR_INVALID_PARAMETER, () => wallet.createAction(a));
                }
            }
        }
    });
    test('1_repeatable txid', async () => {
        for (const { wallet } of ctxs) {
            wallet.randomVals = [0.1, 0.2, 0.3, 0.7, 0.8, 0.9];
            const root = '02135476';
            const kp = TestUtilsWalletStorage_1._tu.getKeyPair(root.repeat(8));
            const createArgs = {
                description: `repeatable`,
                outputs: [
                    {
                        satoshis: 45,
                        lockingScript: TestUtilsWalletStorage_1._tu.getLockP2PKH(kp.address).toHex(),
                        outputDescription: 'pay echo'
                    }
                ],
                options: {
                    randomizeOutputs: false,
                    signAndProcess: true,
                    noSend: true
                }
            };
            const cr = await wallet.createAction(createArgs);
            expect(cr.txid === '4f428a93c43c2d120204ecdc06f7916be8a5f4542cc8839a0fd79bd1b44582f3');
        }
    });
    test('2_signableTransaction', async () => {
        var _a;
        if (!includeTestChaintracks)
            return;
        for (const { wallet } of ctxs) {
            const root = '02135476';
            const kp = TestUtilsWalletStorage_1._tu.getKeyPair(root.repeat(8));
            let txid1;
            let txid2;
            const outputSatoshis = 42;
            let noSendChange;
            let inputBEEF;
            {
                const createArgs = {
                    description: `${kp.address} of ${root}`,
                    outputs: [
                        {
                            satoshis: outputSatoshis,
                            lockingScript: TestUtilsWalletStorage_1._tu.getLockP2PKH(kp.address).toHex(),
                            outputDescription: 'pay fred'
                        }
                    ],
                    options: {
                        randomizeOutputs: false,
                        signAndProcess: false,
                        noSend: true
                    }
                };
                const cr = await wallet.createAction(createArgs);
                noSendChange = cr.noSendChange;
                expect(cr.noSendChange).toBeTruthy();
                expect(cr.sendWithResults).toBeUndefined();
                expect(cr.tx).toBeUndefined();
                expect(cr.txid).toBeUndefined();
                expect(cr.signableTransaction).toBeTruthy();
                const st = cr.signableTransaction;
                expect(st.reference).toBeTruthy();
                // const tx = Transaction.fromAtomicBEEF(st.tx) // Transaction doesn't support V2 Beef yet.
                const atomicBeef = sdk_1.Beef.fromBinary(st.tx);
                const tx = atomicBeef.txs[atomicBeef.txs.length - 1].tx;
                for (const input of tx.inputs) {
                    expect(atomicBeef.findTxid(input.sourceTXID)).toBeTruthy();
                }
                // Spending authorization check happens here...
                //expect(st.amount > 242 && st.amount < 300).toBe(true)
                // sign and complete
                const signArgs = {
                    reference: st.reference,
                    spends: {},
                    options: {
                        returnTXIDOnly: false,
                        noSend: true
                    }
                };
                const sr = await wallet.signAction(signArgs);
                inputBEEF = sr.tx;
                txid1 = sr.txid;
                // Update the noSendChange txid to final signed value.
                noSendChange = noSendChange.map(op => `${txid1}.${op.split('.')[1]}`);
            }
            {
                const unlock = TestUtilsWalletStorage_1._tu.getUnlockP2PKH(kp.privateKey, outputSatoshis);
                const unlockingScriptLength = await unlock.estimateLength();
                const createArgs = {
                    description: `${kp.address} of ${root}`,
                    inputs: [
                        {
                            outpoint: `${txid1}.0`,
                            inputDescription: 'spend ${kp.address} of ${root}',
                            unlockingScriptLength
                        }
                    ],
                    inputBEEF,
                    options: {
                        noSendChange,
                        // signAndProcess: false, // Not required as an input lacks unlock script...
                        noSend: true
                    }
                };
                const cr = await wallet.createAction(createArgs);
                expect(cr.noSendChange).toBeTruthy();
                expect(cr.sendWithResults).toBeUndefined();
                expect(cr.tx).toBeUndefined();
                expect(cr.txid).toBeUndefined();
                expect(cr.signableTransaction).toBeTruthy();
                const st = cr.signableTransaction;
                expect(st.reference).toBeTruthy();
                const atomicBeef = sdk_1.Beef.fromBinary(st.tx);
                const tx = atomicBeef.txs[atomicBeef.txs.length - 1].tx;
                tx.inputs[0].unlockingScriptTemplate = unlock;
                await tx.sign();
                const unlockingScript = tx.inputs[0].unlockingScript.toHex();
                const signArgs = {
                    reference: st.reference,
                    spends: { 0: { unlockingScript } },
                    options: {
                        returnTXIDOnly: true,
                        noSend: true
                    }
                };
                const sr = await wallet.signAction(signArgs);
                txid2 = sr.txid;
            }
            {
                const createArgs = {
                    description: `${kp.address} of ${root}`,
                    options: {
                        acceptDelayedBroadcast: false,
                        sendWith: [txid1, txid2]
                    }
                };
                const cr = await wallet.createAction(createArgs);
                expect(cr.noSendChange).not.toBeTruthy();
                expect((_a = cr.sendWithResults) === null || _a === void 0 ? void 0 : _a.length).toBe(2);
                const [swr1, swr2] = cr.sendWithResults;
                expect(swr1.status !== 'failed').toBe(true);
                expect(swr2.status !== 'failed').toBe(true);
                expect(swr1.txid).toBe(txid1);
                expect(swr2.txid).toBe(txid2);
            }
        }
    });
    test('3_Transaction with multiple outputs()', async () => {
        var _a, _b, _c, _d;
        const root = '02135476';
        const kp = TestUtilsWalletStorage_1._tu.getKeyPair(root.repeat(8));
        for (const { wallet } of ctxs) {
            const args = {
                description: 'Multiple outputs',
                outputs: [
                    {
                        satoshis: 10,
                        lockingScript: TestUtilsWalletStorage_1._tu.getLockP2PKH(kp.address).toHex(),
                        outputDescription: 'Output 1'
                    },
                    {
                        satoshis: 20,
                        lockingScript: TestUtilsWalletStorage_1._tu.getLockP2PKH(kp.address).toHex(),
                        outputDescription: 'Output 2'
                    }
                ],
                options: {
                    signAndProcess: false,
                    noSend: true
                }
            };
            const r = await wallet.createAction(args);
            expect((_a = r.signableTransaction) === null || _a === void 0 ? void 0 : _a.reference).toBeTruthy();
            expect((_b = r.noSendChange) === null || _b === void 0 ? void 0 : _b.length).toBe(1);
            expect((_c = r.signableTransaction) === null || _c === void 0 ? void 0 : _c.reference).toBeTruthy();
            expect(Array.isArray((_d = r.signableTransaction) === null || _d === void 0 ? void 0 : _d.tx)).toBe(true);
        }
    });
    test('4_Transaction with large number of outputs(50) and randomized', async () => {
        var _a, _b, _c, _d;
        const root = '02135476';
        const kp = TestUtilsWalletStorage_1._tu.getKeyPair(root.repeat(8));
        for (const { wallet } of ctxs) {
            const outputs = Array.from({ length: 50 }, (_, i) => ({
                satoshis: i + 1, // Increment amounts
                lockingScript: TestUtilsWalletStorage_1._tu.getLockP2PKH(kp.address).toHex(),
                outputDescription: `Output ${i}`
            }));
            const args = {
                description: 'Randomized Outputs',
                lockTime: 500000,
                outputs,
                options: {
                    signAndProcess: false,
                    noSend: true,
                    randomizeOutputs: true
                }
            };
            const r = await wallet.createAction(args);
            expect((_a = r.signableTransaction) === null || _a === void 0 ? void 0 : _a.reference).toBeTruthy();
            expect((_b = r.noSendChange) === null || _b === void 0 ? void 0 : _b.length).toBe(1);
            expect((_c = r.signableTransaction) === null || _c === void 0 ? void 0 : _c.reference).toBeTruthy();
            expect(Array.isArray((_d = r.signableTransaction) === null || _d === void 0 ? void 0 : _d.tx)).toBe(true);
        }
    });
});
//# sourceMappingURL=createAction.test.js.map