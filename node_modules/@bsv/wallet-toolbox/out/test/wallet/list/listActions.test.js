"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const index_client_1 = require("../../../src/index.client");
const TestUtilsWalletStorage_1 = require("../../utils/TestUtilsWalletStorage");
const path_1 = __importDefault(require("path"));
require("fake-indexeddb/auto");
describe('listActions tests', () => {
    jest.setTimeout(99999999);
    const storages = [];
    const chain = 'test';
    const setups = [];
    const env = TestUtilsWalletStorage_1._tu.getEnv('test');
    const ctxs = [];
    const testName = () => expect.getState().currentTestName || 'test';
    const databaseName = path_1.default.parse(expect.getState().testPath).name;
    beforeAll(async () => {
        if (env.runMySQL) {
            ctxs.push(await TestUtilsWalletStorage_1._tu.createLegacyWalletMySQLCopy(databaseName));
        }
        ctxs.push(await TestUtilsWalletStorage_1._tu.createIdbLegacyWalletCopy(databaseName));
        ctxs.push(await TestUtilsWalletStorage_1._tu.createLegacyWalletSQLiteCopy(databaseName));
    });
    afterAll(async () => {
        for (const ctx of ctxs) {
            await ctx.storage.destroy();
        }
    });
    test('0 invalid params', async () => {
        for (const { wallet } of ctxs) {
            const invalidArgs = [
                { labels: ['toolong890'.repeat(31)] }
                // Oh so many things to test...
            ];
            for (const args of invalidArgs) {
                await (0, TestUtilsWalletStorage_1.expectToThrowWERR)(index_client_1.sdk.WERR_INVALID_PARAMETER, () => wallet.listActions(args));
            }
        }
    });
    test('1 all actions', async () => {
        for (const { wallet } of ctxs) {
            {
                const args = {
                    includeLabels: true,
                    labels: []
                };
                const r = await wallet.listActions(args);
                expect(r.totalActions).toBe(191);
                expect(r.actions.length).toBe(10);
                let i = 0;
                for (const a of r.actions) {
                    expect(a.inputs).toBeUndefined();
                    expect(a.outputs).toBeUndefined();
                    expect(Array.isArray(a.labels)).toBe(true);
                }
            }
        }
    });
    test('2 non-existing label with any', async () => {
        for (const { wallet } of ctxs) {
            {
                const args = {
                    includeLabels: true,
                    labels: ['xyzzy'],
                    labelQueryMode: 'any'
                };
                const r = await wallet.listActions(args);
                expect(r.totalActions).toBe(0);
                expect(r.actions.length).toBe(0);
            }
        }
    });
    test('3_label babbage_protocol_perm', async () => {
        var _a;
        for (const { wallet } of ctxs) {
            {
                const args = {
                    includeLabels: true,
                    labels: ['babbage_protocol_perm']
                };
                const r = await wallet.listActions(args);
                expect(r.totalActions).toBeGreaterThanOrEqual(r.actions.length);
                expect(r.actions.length).toBe(args.limit || 10);
                let i = 0;
                for (const a of r.actions) {
                    expect(a.inputs).toBeUndefined();
                    expect(a.outputs).toBeUndefined();
                    expect(Array.isArray(a.labels)).toBe(true);
                    expect((_a = a.labels) === null || _a === void 0 ? void 0 : _a.indexOf('babbage_protocol_perm')).toBeGreaterThan(-1);
                }
            }
        }
    });
    test('4_label babbage_protocol_perm', async () => {
        var _a;
        for (const { wallet } of ctxs) {
            {
                const args = {
                    includeLabels: true,
                    labels: ['babbage_protocol_perm']
                };
                const r = await wallet.listActions(args);
                expect(r.totalActions).toBeGreaterThanOrEqual(r.actions.length);
                expect(r.actions.length).toBe(args.limit || 10);
                let i = 0;
                for (const a of r.actions) {
                    expect(a.inputs).toBeUndefined();
                    expect(a.outputs).toBeUndefined();
                    expect(Array.isArray(a.labels)).toBe(true);
                    for (const label of args.labels) {
                        expect((_a = a.labels) === null || _a === void 0 ? void 0 : _a.indexOf(label)).toBeGreaterThan(-1);
                    }
                }
            }
        }
    });
    test('5_label babbage_protocol_perm or babbage_basket_access', async () => {
        for (const { wallet } of ctxs) {
            {
                const args = {
                    includeLabels: true,
                    labels: ['babbage_protocol_perm', 'babbage_basket_access']
                };
                const r = await wallet.listActions(args);
                expect(r.totalActions).toBeGreaterThanOrEqual(r.actions.length);
                expect(r.actions.length).toBe(args.limit || 10);
                let i = 0;
                for (const a of r.actions) {
                    expect(a.inputs).toBeUndefined();
                    expect(a.outputs).toBeUndefined();
                    expect(Array.isArray(a.labels)).toBe(true);
                    let count = 0;
                    for (const label of args.labels) {
                        if (a.labels.indexOf(label) > -1)
                            count++;
                    }
                    expect(count).toBeGreaterThan(0);
                }
            }
        }
    });
    test('6_label babbage_protocol_perm and babbage_basket_access', async () => {
        for (const { wallet } of ctxs) {
            {
                const args = {
                    includeLabels: true,
                    labels: ['babbage_protocol_perm', 'babbage_basket_access'],
                    labelQueryMode: 'all'
                };
                const r = await wallet.listActions(args);
                expect(r.totalActions).toBe(0);
            }
        }
    });
    test('7_includeOutputs', async () => {
        for (const { wallet } of ctxs) {
            {
                const args = {
                    includeOutputs: true,
                    labels: ['babbage_protocol_perm']
                };
                const r = await wallet.listActions(args);
                expect(r.totalActions).toBeGreaterThanOrEqual(r.actions.length);
                expect(r.actions.length).toBe(args.limit || 10);
                let i = 0;
                for (const a of r.actions) {
                    expect(a.isOutgoing === true || a.isOutgoing === false).toBe(true);
                    expect(a.inputs).toBeUndefined();
                    expect(Array.isArray(a.outputs)).toBe(true);
                    expect(a.labels).toBeUndefined();
                    for (const o of a.outputs) {
                        expect(o.outputIndex).toBeGreaterThanOrEqual(0);
                        expect(o.lockingScript).toBeUndefined();
                    }
                }
            }
        }
    });
    test('8_includeOutputs and script', async () => {
        var _a;
        for (const { wallet } of ctxs) {
            {
                const args = {
                    includeOutputs: true,
                    includeOutputLockingScripts: true,
                    labels: ['babbage_protocol_perm']
                };
                const r = await wallet.listActions(args);
                let i = 0;
                for (const a of r.actions) {
                    for (const o of a.outputs) {
                        expect((_a = o.lockingScript) === null || _a === void 0 ? void 0 : _a.length).toBeGreaterThan(0);
                    }
                }
            }
        }
    });
    test('9_includeInputs', async () => {
        for (const { wallet } of ctxs) {
            {
                const args = {
                    includeInputs: true,
                    labels: ['babbage_protocol_perm']
                };
                const r = await wallet.listActions(args);
                let i = 0;
                for (const a of r.actions) {
                    expect(a.isOutgoing === true || a.isOutgoing === false).toBe(true);
                    expect(a.outputs).toBeUndefined();
                    expect(Array.isArray(a.inputs)).toBe(true);
                    expect(a.labels).toBeUndefined();
                    for (const i of a.inputs) {
                        expect(i.sourceLockingScript).toBeUndefined();
                        expect(i.unlockingScript).toBeUndefined();
                    }
                }
            }
        }
    });
    test('10_includeInputs and unlock', async () => {
        var _a;
        for (const { wallet } of ctxs) {
            {
                const args = {
                    includeInputs: true,
                    includeInputUnlockingScripts: true,
                    labels: ['babbage_protocol_perm']
                };
                const r = await wallet.listActions(args);
                let i = 0;
                for (const a of r.actions) {
                    expect(a.isOutgoing === true || a.isOutgoing === false).toBe(true);
                    expect(a.outputs).toBeUndefined();
                    expect(Array.isArray(a.inputs)).toBe(true);
                    expect(a.labels).toBeUndefined();
                    for (const i of a.inputs) {
                        expect(i.sourceLockingScript).toBeUndefined();
                        expect((_a = i.unlockingScript) === null || _a === void 0 ? void 0 : _a.length).toBeGreaterThan(0);
                    }
                }
            }
        }
    });
    test('11_includeInputs and lock', async () => {
        var _a;
        for (const { wallet } of ctxs) {
            {
                const args = {
                    includeInputs: true,
                    includeInputSourceLockingScripts: true,
                    labels: ['babbage_protocol_perm']
                };
                const r = await wallet.listActions(args);
                let i = 0;
                for (const a of r.actions) {
                    expect(a.isOutgoing === true || a.isOutgoing === false).toBe(true);
                    expect(a.outputs).toBeUndefined();
                    expect(Array.isArray(a.inputs)).toBe(true);
                    expect(a.labels).toBeUndefined();
                    for (const i of a.inputs) {
                        expect((_a = i.sourceLockingScript) === null || _a === void 0 ? void 0 : _a.length).toBeGreaterThan(0);
                        expect(i.unlockingScript).toBeUndefined();
                    }
                }
            }
        }
    });
});
//# sourceMappingURL=listActions.test.js.map