import { Transaction } from '@bsv/sdk';
export class GASPVersionMismatchError extends Error {
    code;
    currentVersion;
    foreignVersion;
    constructor(message, currentVersion, foreignVersion) {
        super(message);
        this.code = 'ERR_GASP_VERSION_MISMATCH';
        this.currentVersion = currentVersion;
        this.foreignVersion = foreignVersion;
    }
}
/**
 * Log levels for controlling output verbosity.
 */
export var LogLevel;
(function (LogLevel) {
    LogLevel[LogLevel["NONE"] = 0] = "NONE";
    LogLevel[LogLevel["ERROR"] = 1] = "ERROR";
    LogLevel[LogLevel["WARN"] = 2] = "WARN";
    LogLevel[LogLevel["INFO"] = 3] = "INFO";
    LogLevel[LogLevel["DEBUG"] = 4] = "DEBUG";
})(LogLevel || (LogLevel = {}));
/**
 * Main class implementing the Graph Aware Sync Protocol.
 */
export class GASP {
    version;
    storage;
    remote;
    lastInteraction;
    /**
     * @deprecated Retained for backwards compatibility. Use `logLevel` and the new logging methods instead.
     */
    log;
    /**
     * The log level: NONE, ERROR, WARN, INFO, DEBUG.
     */
    logLevel;
    logPrefix;
    unidirectional;
    /**
     * When true, run tasks sequentially rather than using Promise.all (parallel).
     */
    sequential;
    /**
     *
     * @param storage The GASP Storage interface to use
     * @param remote The GASP Remote interface to use
     * @param lastInteraction The timestamp when we last interacted with this remote party
     * @param logPrefix Optional prefix for log messages
     * @param log Whether to log messages (backwards-compatibility only)
     * @param unidirectional Whether to disable the "reply" side and do pull-only
     * @param logLevel The log level for the instance
     * @param sequential Whether to run tasks sequentially (avoid Promise.all) or in parallel
     */
    constructor(storage, remote, lastInteraction = 0, logPrefix = '[GASP] ', log = false, unidirectional = false, logLevel = LogLevel.INFO, sequential = false) {
        this.storage = storage;
        this.remote = remote;
        this.lastInteraction = lastInteraction;
        this.version = 1;
        this.logPrefix = logPrefix;
        this.log = log;
        this.unidirectional = unidirectional;
        this.logLevel = logLevel;
        this.sequential = sequential;
        this.validateTimestamp(this.lastInteraction);
        this.logData(`GASP initialized with version: ${this.version}, lastInteraction: ${this.lastInteraction}, unidirectional: ${this.unidirectional}, logLevel: ${LogLevel[this.logLevel]}, sequential: ${this.sequential}`);
    }
    /**
     * Helper method to execute callbacks either in parallel or sequentially,
     * depending on the `sequential` flag.
     */
    async runConcurrently(items, callback) {
        if (this.sequential) {
            // Run sequentially
            for (const item of items) {
                await callback(item);
            }
        }
        else {
            // Run in parallel
            await Promise.all(items.map(callback));
        }
    }
    /**
     * Legacy log method for backwards compatibility only.
     * Internally, logs at INFO level if `log === true`.
     */
    logData(...data) {
        if (this.log) {
            this.infoLog(...data);
        }
    }
    /**
     * New recommended methods for logging, respecting the logLevel.
     */
    errorLog(...data) {
        if (this.logLevel >= LogLevel.ERROR) {
            console.error(this.logPrefix, '[ERROR]', ...data);
        }
    }
    warnLog(...data) {
        if (this.logLevel >= LogLevel.WARN) {
            console.warn(this.logPrefix, '[WARN]', ...data);
        }
    }
    infoLog(...data) {
        if (this.logLevel >= LogLevel.INFO) {
            console.info(this.logPrefix, '[INFO]', ...data);
        }
    }
    debugLog(...data) {
        if (this.logLevel >= LogLevel.DEBUG) {
            console.debug(this.logPrefix, '[DEBUG]', ...data);
        }
    }
    validateTimestamp(timestamp) {
        if (typeof timestamp !== 'number' || isNaN(timestamp) || timestamp < 0 || !Number.isInteger(timestamp)) {
            throw new Error('Invalid timestamp format');
        }
    }
    /**
     * Computes a 36-byte structure from a transaction ID and output index.
     * @param txid The transaction ID.
     * @param index The output index.
     * @returns A string representing the 36-byte structure.
     */
    compute36ByteStructure(txid, index) {
        const result = `${txid}.${index.toString()}`;
        this.debugLog(`Computed 36-byte structure: ${result} from txid: ${txid}, index: ${index}`);
        return result;
    }
    /**
     * Deconstructs a 36-byte structure into a transaction ID and output index.
     * @param outpoint The 36-byte structure.
     * @returns An object containing the transaction ID and output index.
     */
    deconstruct36ByteStructure(outpoint) {
        const [txid, index] = outpoint.split('.');
        const result = {
            txid,
            outputIndex: parseInt(index, 10)
        };
        this.debugLog(`Deconstructed 36-byte structure: ${outpoint} into txid: ${txid}, outputIndex: ${result.outputIndex}`);
        return result;
    }
    /**
     * Computes the transaction ID for a given transaction.
     * @param tx The transaction string.
     * @returns The computed transaction ID.
     */
    computeTXID(tx) {
        const txid = Transaction.fromHex(tx).id('hex');
        this.debugLog(`Computed TXID: ${txid} from transaction: ${tx}`);
        return txid;
    }
    /**
     * Synchronizes the transaction data between the local and remote participants.
     * @param host Host identifier for sync state management
     * @param limit Optional limit for the number of UTXOs to fetch per page (default: 1000)
     */
    async sync(host, limit) {
        this.infoLog(`Starting sync process. Last interaction timestamp: ${this.lastInteraction}`);
        const localUTXOs = await this.storage.findKnownUTXOs(0);
        // Find which UTXOs we already have
        const knownOutpoints = new Set();
        for (const utxo of await this.storage.findKnownUTXOs(0)) {
            knownOutpoints.add(this.compute36ByteStructure(utxo.txid, utxo.outputIndex));
        }
        const sharedOutpoints = new Set();
        let initialResponse;
        do {
            const initialRequest = await this.buildInitialRequest(this.lastInteraction, limit);
            initialResponse = await this.remote.getInitialResponse(initialRequest);
            const ingestQueue = [];
            for (const utxo of initialResponse.UTXOList) {
                if (utxo.score !== undefined && utxo.score > this.lastInteraction) {
                    this.lastInteraction = utxo.score;
                }
                const outpoint = this.compute36ByteStructure(utxo.txid, utxo.outputIndex);
                if (knownOutpoints.has(outpoint)) {
                    sharedOutpoints.add(outpoint);
                    knownOutpoints.delete(outpoint);
                }
                else if (!sharedOutpoints.has(outpoint)) {
                    ingestQueue.push(utxo);
                }
            }
            this.infoLog(`Processing page with ${initialResponse.UTXOList.length} UTXOs (since: ${initialResponse.since})`);
            await this.runConcurrently(ingestQueue, async (UTXO) => {
                try {
                    this.infoLog(`Requesting node for UTXO: ${JSON.stringify(UTXO)}`);
                    const outpoint = this.compute36ByteStructure(UTXO.txid, UTXO.outputIndex);
                    const resolvedNode = await this.remote.requestNode(outpoint, UTXO.txid, UTXO.outputIndex, true);
                    this.debugLog(`Received unspent graph node from remote: ${JSON.stringify(resolvedNode)}`);
                    await this.processIncomingNode(resolvedNode);
                    await this.completeGraph(resolvedNode.graphID);
                    sharedOutpoints.add(outpoint);
                }
                catch (e) {
                    this.warnLog(`Error with incoming UTXO ${UTXO.txid}.${UTXO.outputIndex}: ${e.message}`);
                }
            });
        } while (limit && initialResponse.UTXOList.length >= limit);
        // 2. Only do the “reply” half if unidirectional is disabled
        if (!this.unidirectional) {
            await this.runConcurrently(localUTXOs.filter(utxo => utxo.score >= initialResponse.since &&
                !sharedOutpoints.has(this.compute36ByteStructure(utxo.txid, utxo.outputIndex))), async (UTXO) => {
                try {
                    this.infoLog(`Hydrating GASP node for UTXO: ${JSON.stringify(UTXO)}`);
                    const outgoingNode = await this.storage.hydrateGASPNode(this.compute36ByteStructure(UTXO.txid, UTXO.outputIndex), UTXO.txid, UTXO.outputIndex, true);
                    this.debugLog(`Sending unspent graph node for remote: ${JSON.stringify(outgoingNode)}`);
                    await this.processOutgoingNode(outgoingNode);
                }
                catch (e) {
                    this.warnLog(`Error with outgoing UTXO ${UTXO.txid}.${UTXO.outputIndex}: ${e.message}`);
                }
            });
        }
        this.infoLog('Sync completed!');
    }
    /**
     * Builds the initial request for the sync process.
     * @param since The timestamp to sync from
     * @param limit The limit for the number of UTXOs to fetch
     * @returns A promise for the initial request object.
     */
    async buildInitialRequest(since, limit) {
        const request = {
            version: this.version,
            since,
            limit
        };
        this.debugLog(`Built initial request: ${JSON.stringify(request)}`);
        return request;
    }
    /**
     * Builds the initial response based on the received request.
     * @param request The initial request object.
     * @returns A promise for an initial response
     */
    async getInitialResponse(request) {
        this.infoLog(`Received initial request: ${JSON.stringify(request)}`);
        if (request.version !== this.version) {
            const error = new GASPVersionMismatchError(`GASP version mismatch. Current version: ${this.version}, foreign version: ${request.version}`, this.version, request.version);
            this.errorLog(`GASP version mismatch error: ${error.message}`);
            throw error;
        }
        this.validateTimestamp(request.since);
        const response = {
            since: this.lastInteraction,
            UTXOList: await this.storage.findKnownUTXOs(request.since, request.limit)
        };
        this.debugLog(`Built initial response: ${JSON.stringify(response)}`);
        return response;
    }
    /**
     * Builds the initial reply based on the received response.
     * @param response The initial response object.
     * @returns A promise for an initial reply
     */
    async getInitialReply(response) {
        this.infoLog(`Received initial response: ${JSON.stringify(response)}`);
        const knownUTXOs = await this.storage.findKnownUTXOs(response.since);
        const filteredUTXOs = knownUTXOs.filter(x => !response.UTXOList.some(y => y.txid === x.txid && y.outputIndex === x.outputIndex));
        const reply = {
            UTXOList: filteredUTXOs
        };
        this.debugLog(`Built initial reply: ${JSON.stringify(reply)}`);
        return reply;
    }
    /**
     * Provides a requested node to a foreign instance who requested it.
     */
    async requestNode(graphID, txid, outputIndex, metadata) {
        this.infoLog(`Remote is requesting node with graphID: ${graphID}, txid: ${txid}, outputIndex: ${outputIndex}, metadata: ${metadata}`);
        const node = await this.storage.hydrateGASPNode(graphID, txid, outputIndex, metadata);
        this.debugLog(`Returning node: ${JSON.stringify(node)}`);
        return node;
    }
    /**
     * Provides a set of inputs we care about after processing a new incoming node.
     * Also finalizes or discards a graph if no additional data is requested from the foreign instance.
     */
    async submitNode(node) {
        this.infoLog(`Remote party is submitting node: ${JSON.stringify(node)}`);
        await this.storage.appendToGraph(node);
        const requestedInputs = await this.storage.findNeededInputs(node);
        this.debugLog(`Requested inputs: ${JSON.stringify(requestedInputs)}`);
        if (!requestedInputs) {
            await this.completeGraph(node.graphID);
        }
        return requestedInputs;
    }
    /**
     * Handles the completion of a newly-synced graph
     * @param {string} graphID The ID of the newly-synced graph
     */
    async completeGraph(graphID) {
        this.infoLog(`Completing newly-synced graph: ${graphID}`);
        try {
            await this.storage.validateGraphAnchor(graphID);
            this.debugLog(`Graph validated for node: ${graphID}`);
            await this.storage.finalizeGraph(graphID);
            this.infoLog(`Graph finalized for node: ${graphID}`);
        }
        catch (e) {
            this.warnLog(`Error validating graph: ${e.message}. Discarding graph for node: ${graphID}`);
            await this.storage.discardGraph(graphID);
        }
    }
    /**
     * Processes an incoming node from the remote participant.
     * @param node The incoming GASP node.
     * @param spentBy The 36-byte structure of the node that spent this one, if applicable.
     */
    async processIncomingNode(node, spentBy, seenNodes = new Set()) {
        const nodeId = `${this.computeTXID(node.rawTx)}.${node.outputIndex}`;
        this.debugLog(`Processing incoming node: ${JSON.stringify(node)}, spentBy: ${spentBy}`);
        if (seenNodes.has(nodeId)) {
            this.debugLog(`Node ${nodeId} already processed, skipping.`);
            return; // Prevent infinite recursion
        }
        seenNodes.add(nodeId);
        await this.storage.appendToGraph(node, spentBy);
        const neededInputs = await this.storage.findNeededInputs(node);
        this.debugLog(`Needed inputs for node ${nodeId}: ${JSON.stringify(neededInputs)}`);
        if (neededInputs) {
            await this.runConcurrently(Object.entries(neededInputs.requestedInputs), async ([outpoint, { metadata }]) => {
                const { txid, outputIndex } = this.deconstruct36ByteStructure(outpoint);
                this.infoLog(`Requesting new node for txid: ${txid}, outputIndex: ${outputIndex}, metadata: ${metadata}`);
                const newNode = await this.remote.requestNode(node.graphID, txid, outputIndex, metadata);
                this.debugLog(`Received new node: ${JSON.stringify(newNode)}`);
                await this.processIncomingNode(newNode, this.compute36ByteStructure(this.computeTXID(node.rawTx), node.outputIndex), seenNodes);
            });
        }
    }
    /**
     * Processes an outgoing node to the remote participant.
     * @param node The outgoing GASP node.
     */
    async processOutgoingNode(node, seenNodes = new Set()) {
        if (this.unidirectional) {
            this.debugLog(`Skipping outgoing node processing in unidirectional mode.`);
            return;
        }
        const nodeId = `${this.computeTXID(node.rawTx)}.${node.outputIndex}`;
        this.debugLog(`Processing outgoing node: ${JSON.stringify(node)}`);
        if (seenNodes.has(nodeId)) {
            this.debugLog(`Node ${nodeId} already processed, skipping.`);
            return; // Prevent infinite recursion
        }
        seenNodes.add(nodeId);
        // Attempt to submit the node to the remote
        const response = await this.remote.submitNode(node);
        this.debugLog(`Received response for submitted node: ${JSON.stringify(response)}`);
        if (response) {
            await this.runConcurrently(Object.entries(response.requestedInputs), async ([outpoint, { metadata }]) => {
                const { txid, outputIndex } = this.deconstruct36ByteStructure(outpoint);
                try {
                    this.infoLog(`Hydrating node for txid: ${txid}, outputIndex: ${outputIndex}, metadata: ${metadata}`);
                    const hydratedNode = await this.storage.hydrateGASPNode(node.graphID, txid, outputIndex, metadata);
                    this.debugLog(`Hydrated node: ${JSON.stringify(hydratedNode)}`);
                    await this.processOutgoingNode(hydratedNode, seenNodes);
                }
                catch (e) {
                    this.errorLog(`Error hydrating node: ${e.message}`);
                    // If we can't send the outgoing node, we just stop. The remote won't validate the anchor, and their temporary graph will be discarded.
                    return;
                }
            });
        }
    }
}
//# sourceMappingURL=GASP.js.map