import { GASPNode, GASPNodeResponse, GASPStorage, GASPOutput } from '@bsv/gasp';
import { Engine } from '../Engine.js';
/**
 * Represents a node in the temporary graph.
 */
export interface GraphNode {
    txid: string;
    graphID: string;
    rawTx: string;
    outputIndex: number;
    spentBy?: string;
    proof?: string;
    txMetadata?: string;
    outputMetadata?: string;
    inputs?: Record<string, {
        hash: string;
    }> | undefined;
    children: GraphNode[];
    parent?: GraphNode;
}
export declare class OverlayGASPStorage implements GASPStorage {
    topic: string;
    engine: Engine;
    maxNodesInGraph?: number | undefined;
    readonly temporaryGraphNodeRefs: Record<string, GraphNode>;
    constructor(topic: string, engine: Engine, maxNodesInGraph?: number | undefined);
    /**
     *
     * @param since
     * @returns
     */
    findKnownUTXOs(since: number): Promise<GASPOutput[]>;
    /**
     * For a given txid and output index, returns the associated transaction, a merkle proof if the transaction is in a block, and metadata if if requested. If no metadata is requested, metadata hashes on inputs are not returned.
     * @param graphID
     * @param txid
     * @param outputIndex
     * @param metadata
     * @returns
     */
    hydrateGASPNode(graphID: string, txid: string, outputIndex: number, metadata: boolean): Promise<GASPNode>;
    /**
    * For a given node, returns the inputs needed to complete the graph, including whether updated metadata is requested for those inputs.
    * @param tx The node for which needed inputs should be found.
    * @returns A promise for a mapping of requested input transactions and whether metadata should be provided for each.
    */
    findNeededInputs(tx: GASPNode): Promise<GASPNodeResponse | undefined>;
    /**
     * Ensures that no inputs are requested from foreign nodes before sending any GASP response
     * Also terminates graphs if the response would be empty.
     */
    private stripAlreadyKnownInputs;
    /**
    * Appends a new node to a temporary graph.
    * @param tx The node to append to this graph.
    * @param spentBy Unless this is the same node identified by the graph ID, denotes the TXID and input index for the node which spent this one, in 36-byte format.
    * @throws If the node cannot be appended to the graph, either because the graph ID is for a graph the recipient does not want or because the graph has grown to be too large before being finalized.
    */
    appendToGraph(tx: GASPNode, spentBy?: string | undefined): Promise<void>;
    /**
      * Checks whether the given graph, in its current state, makes reference only to transactions that are proven in the blockchain, or already known by the recipient to be valid.
      * Additionally, in a breadth-first manner (ensuring that all inputs for any given node are processed before nodes that spend them), it ensures that the root node remains valid according to the rules of the overlay's topic manager,
      * while considering any coins which the Manager had previously indicated were either valid or invalid.
      * @param graphID The TXID and output index (in 36-byte format) for the UTXO at the tip of this graph.
      * @throws If the graph is not well-anchored, according to the rules of Bitcoin or the rules of the Overlay Topic Manager.
      */
    validateGraphAnchor(graphID: string): Promise<void>;
    /**
     * Deletes all data associated with a temporary graph that has failed to sync, if the graph exists.
     * @param graphID The TXID and output index (in 36-byte format) for the UTXO at the tip of this graph.
     */
    discardGraph(graphID: string): Promise<void>;
    /**
     * Finalizes a graph, solidifying the new UTXO and its ancestors so that it will appear in the list of known UTXOs.
     * @param graphID The TXID and output index (in 36-byte format) for the UTXO at the root of this graph.
     */
    finalizeGraph(graphID: string): Promise<void>;
    /**
     * Computes an ordered set of BEEFs for the graph with the given graph IDs
     * @param {string} graphID â€” The ID of the graph for which BEEFs are required
     * @returns Ordered BEEFs for the graph
     */
    private computeOrderedBEEFsForGraph;
    /**
     * Computes a full BEEF for a given graph node, based on the temporary graph store.
     * @param node Graph node for which BEEF is needed.
     * @returns BEEF array, including all proofs on inputs.
     */
    private getBEEFForNode;
}
//# sourceMappingURL=OverlayGASPStorage.d.ts.map