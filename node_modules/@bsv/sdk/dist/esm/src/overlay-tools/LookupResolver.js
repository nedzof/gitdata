import { Transaction } from '../transaction/index.js';
import OverlayAdminTokenTemplate from './OverlayAdminTokenTemplate.js';
// Only bind window.fetch in the browser
const defaultFetch = typeof window !== 'undefined' ? fetch.bind(window) : fetch;
/** Default SLAP trackers */
export const DEFAULT_SLAP_TRACKERS = [
    // BSVA clusters
    'https://overlay-us-1.bsvb.tech',
    'https://overlay-eu-1.bsvb.tech',
    'https://overlay-ap-1.bsvb.tech',
    // Babbage primary overlay service
    'https://users.bapp.dev'
    // NOTE: Other entities may submit pull requests to the library if they maintain SLAP overlay services.
    // Additional trackers run by different entities contribute to greater network resiliency.
    // It also generally doesn't hurt to have more trackers in this list.
    // DISCLAIMER:
    // Trackers known to host invalid or illegal records will be removed at the discretion of the BSV Association.
];
/** Default testnet SLAP trackers */
export const DEFAULT_TESTNET_SLAP_TRACKERS = [
    // Babbage primary testnet overlay service
    'https://testnet-users.bapp.dev'
];
const MAX_TRACKER_WAIT_TIME = 5000;
export class HTTPSOverlayLookupFacilitator {
    fetchClient;
    allowHTTP;
    constructor(httpClient = defaultFetch, allowHTTP = false) {
        this.fetchClient = httpClient;
        this.allowHTTP = allowHTTP;
    }
    async lookup(url, question, timeout = 5000) {
        if (!url.startsWith('https:') && !this.allowHTTP) {
            throw new Error('HTTPS facilitator can only use URLs that start with "https:"');
        }
        const controller = typeof AbortController !== 'undefined' ? new AbortController() : undefined;
        const timer = setTimeout(() => {
            try {
                controller?.abort();
            }
            catch { /* noop */ }
        }, timeout);
        try {
            const fco = {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ service: question.service, query: question.query }),
                signal: controller?.signal
            };
            const response = await this.fetchClient(`${url}/lookup`, fco);
            if (!response.ok)
                throw new Error(`Failed to facilitate lookup (HTTP ${response.status})`);
            return await response.json();
        }
        catch (e) {
            // Normalize timeouts to a consistent error message
            if (e?.name === 'AbortError')
                throw new Error('Request timed out');
            throw e;
        }
        finally {
            clearTimeout(timer);
        }
    }
}
/**
 * Represents a Lookup Resolver.
 */
export default class LookupResolver {
    facilitator;
    slapTrackers;
    hostOverrides;
    additionalHosts;
    networkPreset;
    // ---- Caches / memoization ----
    hostsCache;
    hostsInFlight;
    hostsTtlMs;
    hostsMaxEntries;
    txMemo;
    txMemoTtlMs;
    constructor(config = {}) {
        this.networkPreset = config.networkPreset ?? 'mainnet';
        this.facilitator = config.facilitator ?? new HTTPSOverlayLookupFacilitator(undefined, this.networkPreset === 'local');
        this.slapTrackers = config.slapTrackers ?? (this.networkPreset === 'mainnet' ? DEFAULT_SLAP_TRACKERS : DEFAULT_TESTNET_SLAP_TRACKERS);
        this.hostOverrides = config.hostOverrides ?? {};
        this.additionalHosts = config.additionalHosts ?? {};
        // cache tuning
        this.hostsTtlMs = config.cache?.hostsTtlMs ?? 5 * 60 * 1000; // 5 min
        this.hostsMaxEntries = config.cache?.hostsMaxEntries ?? 128;
        this.txMemoTtlMs = config.cache?.txMemoTtlMs ?? 10 * 60 * 1000; // 10 min
        this.hostsCache = new Map();
        this.hostsInFlight = new Map();
        this.txMemo = new Map();
    }
    /**
     * Given a LookupQuestion, returns a LookupAnswer. Aggregates across multiple services and supports resiliency.
     */
    async query(question, timeout) {
        let competentHosts = [];
        if (question.service === 'ls_slap') {
            competentHosts = this.networkPreset === 'local' ? ['http://localhost:8080'] : this.slapTrackers;
        }
        else if (this.hostOverrides[question.service] != null) {
            competentHosts = this.hostOverrides[question.service];
        }
        else if (this.networkPreset === 'local') {
            competentHosts = ['http://localhost:8080'];
        }
        else {
            competentHosts = await this.getCompetentHostsCached(question.service);
        }
        if (this.additionalHosts[question.service]?.length > 0) {
            // preserve order: resolved hosts first, then additional (unique)
            const extra = this.additionalHosts[question.service];
            const seen = new Set(competentHosts);
            for (const h of extra)
                if (!seen.has(h))
                    competentHosts.push(h);
        }
        if (competentHosts.length < 1) {
            throw new Error(`No competent ${this.networkPreset} hosts found by the SLAP trackers for lookup service: ${question.service}`);
        }
        // Fire all hosts with per-host timeout, harvest successful output-list responses
        const hostResponses = await Promise.allSettled(competentHosts.map(async (host) => {
            return await this.facilitator.lookup(host, question, timeout);
        }));
        const outputsMap = new Map();
        // Memo key helper for tx parsing
        const beefKey = (beef) => {
            if (typeof beef !== 'object')
                return ''; // The invalid BEEF has an empty key.
            // A fast and deterministic key for memoization; avoids large JSON strings
            // since beef is an array of integers, join is safe and compact.
            return beef.join(',');
        };
        for (const result of hostResponses) {
            if (result.status !== 'fulfilled')
                continue;
            const response = result.value;
            if (response?.type !== 'output-list' || !Array.isArray(response.outputs))
                continue;
            for (const output of response.outputs) {
                const keyForBeef = beefKey(output.beef);
                let memo = this.txMemo.get(keyForBeef);
                const now = Date.now();
                if (typeof memo !== 'object' || memo === null || memo.expiresAt <= now) {
                    try {
                        const txId = Transaction.fromBEEF(output.beef).id('hex');
                        memo = { txId, expiresAt: now + this.txMemoTtlMs };
                        // prune opportunistically if the map gets too large (cheap heuristic)
                        if (this.txMemo.size > 4096)
                            this.evictOldest(this.txMemo);
                        this.txMemo.set(keyForBeef, memo);
                    }
                    catch {
                        continue;
                    }
                }
                const uniqKey = `${memo.txId}.${output.outputIndex}`;
                // last-writer wins is fine here; outputs are identical if uniqKey matches
                outputsMap.set(uniqKey, output);
            }
        }
        return {
            type: 'output-list',
            outputs: Array.from(outputsMap.values())
        };
    }
    /**
     * Cached wrapper for competent host discovery with stale-while-revalidate.
     */
    async getCompetentHostsCached(service) {
        const now = Date.now();
        const cached = this.hostsCache.get(service);
        // if fresh, return immediately
        if (typeof cached === 'object' && cached.expiresAt > now) {
            return cached.hosts.slice();
        }
        // if stale but present, kick off a refresh if not already in-flight and return stale
        if (typeof cached === 'object' && cached.expiresAt <= now) {
            if (!this.hostsInFlight.has(service)) {
                this.hostsInFlight.set(service, this.refreshHosts(service).finally(() => {
                    this.hostsInFlight.delete(service);
                }));
            }
            return cached.hosts.slice();
        }
        // no cache: coalesce concurrent requests
        if (this.hostsInFlight.has(service)) {
            try {
                const hosts = await this.hostsInFlight.get(service);
                if (typeof hosts !== 'object') {
                    throw new Error('Hosts is not defined.');
                }
                return hosts.slice();
            }
            catch {
                // fall through to a fresh attempt below
            }
        }
        const promise = this.refreshHosts(service).finally(() => {
            this.hostsInFlight.delete(service);
        });
        this.hostsInFlight.set(service, promise);
        const hosts = await promise;
        return hosts.slice();
    }
    /**
     * Actually resolves competent hosts from SLAP trackers and updates cache.
     */
    async refreshHosts(service) {
        const hosts = await this.findCompetentHosts(service);
        const expiresAt = Date.now() + this.hostsTtlMs;
        // bounded cache with simple FIFO eviction
        if (!this.hostsCache.has(service) && this.hostsCache.size >= this.hostsMaxEntries) {
            const oldestKey = this.hostsCache.keys().next().value;
            if (oldestKey !== undefined)
                this.hostsCache.delete(oldestKey);
        }
        this.hostsCache.set(service, { hosts, expiresAt });
        return hosts;
    }
    /**
     * Returns a list of competent hosts for a given lookup service.
     * @param service Service for which competent hosts are to be returned
     * @returns Array of hosts competent for resolving queries
     */
    async findCompetentHosts(service) {
        const query = {
            service: 'ls_slap',
            query: { service }
        };
        // Query all SLAP trackers; tolerate failures.
        const trackerResponses = await Promise.allSettled(this.slapTrackers.map(async (tracker) => await this.facilitator.lookup(tracker, query, MAX_TRACKER_WAIT_TIME)));
        const hosts = new Set();
        for (const result of trackerResponses) {
            if (result.status !== 'fulfilled')
                continue;
            const answer = result.value;
            if (answer.type !== 'output-list')
                continue;
            for (const output of answer.outputs) {
                try {
                    const tx = Transaction.fromBEEF(output.beef);
                    const script = tx.outputs[output.outputIndex]?.lockingScript;
                    if (typeof script !== 'object' || script === null)
                        continue;
                    const parsed = OverlayAdminTokenTemplate.decode(script);
                    if (parsed.topicOrService !== service || parsed.protocol !== 'SLAP')
                        continue;
                    if (typeof parsed.domain === 'string' && parsed.domain.length > 0) {
                        hosts.add(parsed.domain);
                    }
                }
                catch {
                    continue;
                }
            }
        }
        return [...hosts];
    }
    /** Evict an arbitrary “oldest” entry from a Map (iteration order). */
    evictOldest(m) {
        const firstKey = m.keys().next().value;
        if (firstKey !== undefined)
            m.delete(firstKey);
    }
}
//# sourceMappingURL=LookupResolver.js.map