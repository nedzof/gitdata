
1) Update file: src/db/schema.sql
With content (only the receipts table section shown; keep the rest unchanged):
```sql
-- Receipts: add counters bytes_used and last_seen for D07
CREATE TABLE IF NOT EXISTS receipts (
  receipt_id TEXT PRIMARY KEY,
  version_id TEXT NOT NULL,
  quantity INTEGER NOT NULL,
  content_hash TEXT,
  amount_sat INTEGER NOT NULL,
  status TEXT NOT NULL DEFAULT 'pending', -- 'pending'|'paid'|'consumed'|'expired'
  created_at INTEGER NOT NULL,
  expires_at INTEGER NOT NULL,
  bytes_used INTEGER NOT NULL DEFAULT 0,
  last_seen INTEGER
);

-- Revenue log (from D06, keep as-is)
CREATE TABLE IF NOT EXISTS revenue_events (
  event_id INTEGER PRIMARY KEY AUTOINCREMENT,
  receipt_id TEXT NOT NULL,
  version_id TEXT NOT NULL,
  amount_sat INTEGER NOT NULL,
  quantity INTEGER NOT NULL,
  created_at INTEGER NOT NULL,
  type TEXT NOT NULL DEFAULT 'pay'
);

CREATE INDEX IF NOT EXISTS idx_receipts_version ON receipts(version_id);
CREATE INDEX IF NOT EXISTS idx_receipts_status ON receipts(status);
CREATE INDEX IF NOT EXISTS idx_revenue_version ON revenue_events(version_id);
CREATE INDEX IF NOT EXISTS idx_revenue_receipt ON revenue_events(receipt_id);
```

2) Update file: src/db/index.ts
With content:
```ts
import Database from 'better-sqlite3';
import fs from 'fs';
import path from 'path';

export type DeclarationRow = {
  version_id: string;
  txid: string | null;
  type: 'DLM1' | 'TRN1' | 'UNKNOWN';
  status: 'pending' | 'confirmed';
  created_at: number;
  block_hash: string | null;
  height: number | null;
  opret_vout: number | null;
  raw_tx: string | null;
  proof_json: string | null;
};

export type ManifestRow = {
  version_id: string;
  manifest_hash: string;
  content_hash: string | null;
  title: string | null;
  license: string | null;
  classification: string | null;
  created_at: string | null;
  manifest_json: string;
};

export type ReceiptRow = {
  receipt_id: string;
  version_id: string;
  quantity: number;
  content_hash: string | null;
  amount_sat: number;
  status: 'pending' | 'paid' | 'consumed' | 'expired';
  created_at: number;
  expires_at: number;
  bytes_used: number;
  last_seen: number | null;
};

export type RevenueEventRow = {
  event_id?: number;
  receipt_id: string;
  version_id: string;
  amount_sat: number;
  quantity: number;
  created_at: number;
  type: 'pay' | 'refund' | 'adjust';
};

export function openDb(dbPath = process.env.DB_PATH || './data/overlay.db') {
  fs.mkdirSync(path.dirname(dbPath), { recursive: true });
  const db = new Database(dbPath);
  db.pragma('journal_mode = WAL');
  return db;
}

export function initSchema(db: Database.Database, schemaFile = 'src/db/schema.sql') {
  const sql = fs.readFileSync(schemaFile, 'utf8');
  db.exec(sql);
}

/* Prices */
export function setPrice(db: Database.Database, versionId: string, satoshis: number) {
  db.prepare(
    `INSERT INTO prices(version_id, satoshis) VALUES (?, ?)
     ON CONFLICT(version_id) DO UPDATE SET satoshis = excluded.satoshis`,
  ).run(versionId, satoshis);
}
export function getPrice(db: Database.Database, versionId: string): number | undefined {
  const row = db.prepare('SELECT satoshis FROM prices WHERE version_id = ?').get(versionId) as any;
  return row?.satoshis;
}

/* Manifests */
export function getManifest(db: Database.Database, versionId: string): ManifestRow | undefined {
  return db.prepare('SELECT * FROM manifests WHERE version_id = ?').get(versionId) as any;
}

/* Receipts */
export function insertReceipt(db: Database.Database, row: Omit<ReceiptRow, 'bytes_used' | 'last_seen'> & Partial<Pick<ReceiptRow, 'bytes_used' | 'last_seen'>>) {
  const stmt = db.prepare(`
    INSERT INTO receipts(receipt_id, version_id, quantity, content_hash, amount_sat, status, created_at, expires_at, bytes_used, last_seen)
    VALUES (@receipt_id, @version_id, @quantity, @content_hash, @amount_sat, @status, @created_at, @expires_at, COALESCE(@bytes_used,0), @last_seen)
  `);
  stmt.run(row as any);
}

export function getReceipt(db: Database.Database, receiptId: string): ReceiptRow | undefined {
  return db.prepare('SELECT * FROM receipts WHERE receipt_id = ?').get(receiptId) as any;
}

export function setReceiptStatus(
  db: Database.Database,
  receiptId: string,
  status: ReceiptRow['status'],
) {
  db.prepare('UPDATE receipts SET status = ?, last_seen = ? WHERE receipt_id = ?').run(status, Math.floor(Date.now()/1000), receiptId);
}

export function updateReceiptUsage(
  db: Database.Database,
  receiptId: string,
  addBytes: number,
) {
  const now = Math.floor(Date.now() / 1000);
  const tx = db.transaction(() => {
    const r = getReceipt(db, receiptId);
    if (!r) throw new Error('receipt-not-found');
    const newBytes = (r.bytes_used || 0) + addBytes;
    db.prepare('UPDATE receipts SET bytes_used = ?, last_seen = ? WHERE receipt_id = ?')
      .run(newBytes, now, receiptId);
  });
  tx();
}

/* Revenue log */
export function logRevenue(db: Database.Database, ev: RevenueEventRow) {
  const stmt = db.prepare(`
    INSERT INTO revenue_events(receipt_id, version_id, amount_sat, quantity, created_at, type)
    VALUES (@receipt_id, @version_id, @amount_sat, @quantity, @created_at, @type)
  `);
  stmt.run(ev as any);
}
```

3) Create file: src/routes/data.ts
With content:
```ts
import type { Request, Response, Router } from 'express';
import { Router as makeRouter } from 'express';
import fs from 'fs';
import path from 'path';
import Database from 'better-sqlite3';
import { getManifest, getReceipt, setReceiptStatus, updateReceiptUsage } from '../db';

// Config (can be tuned via ENV)
const DATA_ROOT = process.env.DATA_ROOT || path.resolve(process.cwd(), 'data', 'blobs');
// Total bytes allowed per receipt (MVP: simple cap)
const BYTES_MAX_PER_RECEIPT = Number(process.env.BYTES_MAX_PER_RECEIPT || 104857600); // 100 MB default
// If true, mark receipt as consumed after first successful delivery
const SINGLE_USE_RECEIPTS = /^true$/i.test(process.env.SINGLE_USE_RECEIPTS || 'false');

function json(res: Response, code: number, body: any) {
  return res.status(code).json(body);
}

// Resolve a local file path by contentHash
function resolveBlobPath(contentHash: string): string {
  return path.join(DATA_ROOT, contentHash.toLowerCase());
}

/**
 * GET /v1/data?contentHash=&receiptId=
 * Validates the receipt, enforces TTL and quotas, then streams local file bytes from DATA_ROOT/contentHash.
 * Notes:
 * - For production, prefer presigned URLs to your object store/CDN and update counters when links are redeemed.
 * - This MVP streams from disk to demonstrate quota/TTL enforcement and atomic counters.
 */
export function dataRouter(db: Database.Database): Router {
  const router = makeRouter();

  router.get('/v1/data', async (req: Request, res: Response) => {
    try {
      const contentHash = String(req.query.contentHash || '').toLowerCase();
      const receiptId = String(req.query.receiptId || '');

      if (!/^[0-9a-fA-F]{64}$/.test(contentHash)) {
        return json(res, 400, { error: 'bad-request', hint: 'contentHash=64-hex required' });
      }
      if (!receiptId || receiptId.length < 8) {
        return json(res, 400, { error: 'bad-request', hint: 'receiptId required' });
      }

      // Load receipt and validate
      const rc = getReceipt(db, receiptId);
      if (!rc) return json(res, 404, { error: 'not-found', hint: 'receipt missing' });

      const now = Math.floor(Date.now() / 1000);
      if (now > rc.expires_at) {
        setReceiptStatus(db, receiptId, 'expired');
        return json(res, 403, { error: 'expired', hint: 'receipt expired' });
      }

      if (rc.status === 'consumed') {
        return json(res, 409, { error: 'already-consumed' });
      }
      if (rc.status !== 'pending' && rc.status !== 'paid') {
        return json(res, 403, { error: 'forbidden', hint: `invalid-status:${rc.status}` });
      }
      if (!rc.content_hash || rc.content_hash.toLowerCase() !== contentHash) {
        return json(res, 409, { error: 'content-mismatch' });
      }

      // Optional manifest presence (not strictly required for streaming)
      const man = getManifest(db, rc.version_id);
      if (!man) {
        // Not fatal for streaming, but return a clear message
        return json(res, 409, { error: 'manifest-missing', hint: 'manifest not found for version' });
      }

      // Enforce quota: total bytes per receipt
      const blobPath = resolveBlobPath(contentHash);
      if (!fs.existsSync(blobPath) || !fs.statSync(blobPath).isFile()) {
        return json(res, 404, { error: 'not-found', hint: 'content blob not found on server' });
      }
      const size = fs.statSync(blobPath).size;
      const used = rc.bytes_used || 0;
      if (BYTES_MAX_PER_RECEIPT > 0 && used + size > BYTES_MAX_PER_RECEIPT) {
        return json(res, 409, { error: 'quota-exceeded', hint: `limit=${BYTES_MAX_PER_RECEIPT}, used=${used}, size=${size}` });
      }

      // Stream headers
      res.setHeader('content-type', 'application/octet-stream');
      res.setHeader('content-length', String(size));
      res.setHeader('x-receipt-id', receiptId);
      res.setHeader('x-version-id', rc.version_id);
      res.setHeader('x-bytes-used', String(used));
      res.setHeader('x-bytes-limit', String(BYTES_MAX_PER_RECEIPT));

      // Start streaming
      const rs = fs.createReadStream(blobPath);
      rs.on('error', (err) => {
        if (!res.headersSent) {
          return json(res, 500, { error: 'stream-error', message: String((err as any)?.message || err) });
        }
        try { res.end(); } catch {}
      });
      rs.on('open', () => {
        rs.pipe(res);
      });
      rs.on('end', () => {
        // Update counters atomically after full delivery
        try {
          updateReceiptUsage(db, receiptId, size);
          if (SINGLE_USE_RECEIPTS) {
            setReceiptStatus(db, receiptId, 'consumed');
          }
        } catch {
          // swallow DB errors here; delivery succeeded
        }
      });
    } catch (e: any) {
      return json(res, 500, { error: 'data-failed', message: String(e?.message || e) });
    }
  });

  return router;
}
```

4) Create file: test/integration/data.spec.ts
With content:
```ts
import assert from 'assert';
import fs from 'fs';
import os from 'os';
import path from 'path';
import express from 'express';
import request from 'supertest';
import Database from 'better-sqlite3';

import { initSchema, upsertManifest } from '../../src/db';
import { payRouter } from '../../src/routes/pay';
import { dataRouter } from '../../src/routes/data';

(async function run() {
  // Test config
  const tmpRoot = fs.mkdtempSync(path.join(os.tmpdir(), 'data-'));
  process.env.DATA_ROOT = tmpRoot;
  process.env.BYTES_MAX_PER_RECEIPT = '1024'; // 1KB cap for test
  process.env.SINGLE_USE_RECEIPTS = 'false';
  process.env.PRICE_DEFAULT_SATS = '100';
  process.env.RECEIPT_TTL_SEC = '300';

  const app = express();
  app.use(express.json({ limit: '1mb' }));
  const db = new Database(':memory:');
  initSchema(db);
  app.use(payRouter(db));
  app.use(dataRouter(db));

  // Prepare a fake blob file
  const contentHash = 'a'.repeat(64);
  const dataBytes = Buffer.from('hello world'); // 11 bytes
  fs.writeFileSync(path.join(tmpRoot, contentHash), dataBytes);

  // Insert manifest with contentHash so /pay will accept
  const versionId = 'b'.repeat(64);
  upsertManifest(db, {
    version_id: versionId,
    manifest_hash: versionId,
    content_hash: contentHash,
    title: 'Test Dataset',
    license: 'cc-by-4.0',
    classification: 'public',
    created_at: '2024-05-01T00:00:00Z',
    manifest_json: JSON.stringify({
      type: 'datasetVersionManifest',
      datasetId: 'ds-test',
      content: { contentHash },
      provenance: { createdAt: '2024-05-01T00:00:00Z' },
      policy: { license: 'cc-by-4.0', classification: 'public' }
    })
  });

  // Create receipt
  const payRes = await request(app)
    .post('/pay')
    .set('content-type', 'application/json')
    .send({ versionId, quantity: 1 });
  assert.strictEqual(payRes.status, 200);
  const receiptId = payRes.body.receiptId;

  // 1) Positive: within limit -> 200 + bytes
  const r1 = await request(app).get(`/v1/data?contentHash=${contentHash}&receiptId=${receiptId}`);
  assert.strictEqual(r1.status, 200);
  assert.strictEqual(Buffer.compare(r1.body as any, dataBytes), 0, 'returned bytes must match stored blob');

  // 2) Negative: wrong contentHash -> 409
  const bad1 = await request(app).get(`/v1/data?contentHash=${'c'.repeat(64)}&receiptId=${receiptId}`);
  assert.strictEqual(bad1.status, 409);
  assert.strictEqual(bad1.body.error, 'content-mismatch');

  // 3) Negative: limit exceeded (set cap just below file size + used)
  process.env.BYTES_MAX_PER_RECEIPT = '15'; // used=11, size=11 -> 22 > 15
  // Recreate app/dataRouter to pick up new ENV (module reads at import time)
  const app2 = express();
  app2.use(express.json({ limit: '1mb' }));
  app2.use(payRouter(db));
  app2.use(dataRouter(db));
  const r2 = await request(app2).get(`/v1/data?contentHash=${contentHash}&receiptId=${receiptId}`);
  assert.strictEqual(r2.status, 409);
  assert.strictEqual(r2.body.error, 'quota-exceeded');

  // 4) Negative: expired receipt
  // Manually expire by decreasing expires_at
  db.prepare('UPDATE receipts SET expires_at = ? WHERE receipt_id = ?').run(Math.floor(Date.now()/1000) - 10, receiptId);
  const r3 = await request(app2).get(`/v1/data?contentHash=${contentHash}&receiptId=${receiptId}`);
  assert.strictEqual(r3.status, 403);
  assert.strictEqual(r3.body.error, 'expired');

  console.log('OK: /v1/data (streaming & quotas) tests passed.');
})().catch((e) => {
  console.error('data tests failed:', e);
  process.exit(1);
});
```

5) Update file: server.ts (mount the data router)
With content patch:
```ts
import express from 'express';
import { openDb, initSchema } from './src/db';
import { submitDlm1Router } from './src/routes/submit-builder';
import { submitReceiverRouter } from './src/routes/submit-receiver';
import { bundleRouter } from './src/routes/bundle';
import { readyRouter } from './src/routes/ready';
import { priceRouter } from './src/routes/price';
import { listingsRouter } from './src/routes/listings';
import { payRouter } from './src/routes/pay';
import { dataRouter } from './src/routes/data';

const PORT = Number(process.env.OVERLAY_PORT || 8788);
const BODY_MAX_SIZE = Number(process.env.BODY_MAX_SIZE || 1048576);

async function main() {
  const app = express();
  app.use(express.json({ limit: '2mb' }));

  const db = openDb();
  initSchema(db);

  app.use(submitDlm1Router());
  app.use(submitReceiverRouter(db, { bodyMaxSize: BODY_MAX_SIZE }));
  app.use(bundleRouter(db));
  app.use(readyRouter(db));
  app.use(priceRouter(db));
  app.use(payRouter(db));
  app.use(dataRouter(db)); // <-- stream route
  app.use(listingsRouter(db));

  app.get('/health', (_req, res) => res.json({ ok: true }));

  app.listen(PORT, () => console.log(`Overlay listening on :${PORT}`));
}
main().catch((e) => { console.error(e); process.exit(1); });
```

6) Update file: package.json (add test script)
With content patch:
```json
{
  "scripts": {
    "test:data": "ts-node test/integration/data.spec.ts"
  }
}
```

How to run D07
- Apply DB schema change (fresh dev DB: delete ./data/overlay.db, or ALTER TABLE to add bytes_used and last_seen).
- Place blobs at DATA_ROOT/contentHash (default ./data/blobs/<64hex>).
- Run tests: npm run test:data

What you completed (matches D07 DoD)
- GET /v1/data enforces:
  - receipt existence and TTL
  - status (pending/paid only; consumed/expired blocked)
  - contentHash match
  - total bytes quota (BYTES_MAX_PER_RECEIPT)
  - single-use toggle (SINGLE_USE_RECEIPTS) to mark on first full delivery
- Streams bytes from local disk and atomically updates counters after delivery.
- Clear JSON errors: 400 bad params, 401/403 forbidden/expired, 404 not-found, 409 content-mismatch or quota-exceeded.

Notes
- For production, switch to presigned URLs to reduce IO/CPU. Keep quota/TTL enforcement server-side by issuing short-lived signed links tied to receiptId and decrementing counters when redeemed.
- You can add a job to expire receipts in bulk and clean up, plus metrics for bandwidth served per version/producer.
