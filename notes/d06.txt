
Awesome—here are the exact Cursor “Create/Update file … with content …” tasks to implement D06 (Pay, Receipts & Revenue Log). Paste them in order. This adds receipt schema/validator, DB helpers, /pay and /receipt routes, and integration tests.

1) Update file: src/db/schema.sql
With content:
```sql
-- Declarations, Manifests, Edges (unchanged above)

-- Receipts: add amount_sat and expires_at for D06
CREATE TABLE IF NOT EXISTS receipts (
  receipt_id TEXT PRIMARY KEY,
  version_id TEXT NOT NULL,
  quantity INTEGER NOT NULL,
  content_hash TEXT,
  amount_sat INTEGER NOT NULL,
  status TEXT NOT NULL DEFAULT 'pending', -- 'pending'|'paid'|'consumed'|'expired'
  created_at INTEGER NOT NULL,
  expires_at INTEGER NOT NULL
);

-- Prices (unchanged)
CREATE TABLE IF NOT EXISTS prices (
  version_id TEXT PRIMARY KEY,
  satoshis INTEGER NOT NULL
);

-- Revenue events (simple append-only log)
CREATE TABLE IF NOT EXISTS revenue_events (
  event_id INTEGER PRIMARY KEY AUTOINCREMENT,
  receipt_id TEXT NOT NULL,
  version_id TEXT NOT NULL,
  amount_sat INTEGER NOT NULL,
  quantity INTEGER NOT NULL,
  created_at INTEGER NOT NULL,
  type TEXT NOT NULL DEFAULT 'pay' -- 'pay' | 'refund' | 'adjust'
);

-- Helpful indexes (optional)
CREATE INDEX IF NOT EXISTS idx_receipts_version ON receipts(version_id);
CREATE INDEX IF NOT EXISTS idx_receipts_status ON receipts(status);
CREATE INDEX IF NOT EXISTS idx_revenue_version ON revenue_events(version_id);
CREATE INDEX IF NOT EXISTS idx_revenue_receipt ON revenue_events(receipt_id);
```

2) Update file: src/db/index.ts
With content:
```ts
 //import fs from 'fs';
import path from 'path';

export type DeclarationRow = {
  version_id: string;
  txid: string | null;
  type: 'DLM1' | 'TRN1' | 'UNKNOWN';
  status: 'pending' | 'confirmed';
  created_at: number;
  block_hash: string | null;
  height: number | null;
  opret_vout: number | null;
  raw_tx: string | null;
  proof_json: string | null;
};

export type ManifestRow = {
  version_id: string;
  manifest_hash: string;
  content_hash: string | null;
  title: string | null;
  license: string | null;
  classification: string | null;
  created_at: string | null;
  manifest_json: string;
};

export type ReceiptRow = {
  receipt_id: string;
  version_id: string;
  quantity: number;
  content_hash: string | null;
  amount_sat: number;
  status: 'pending' | 'paid' | 'consumed' | 'expired';
  created_at: number;
  expires_at: number;
};

export type RevenueEventRow = {
  event_id?: number;
  receipt_id: string;
  version_id: string;
  amount_sat: number;
  quantity: number;
  created_at: number;
  type: 'pay' | 'refund' | 'adjust';
};

export function openDb(dbPath = process.env.DB_PATH || './data/overlay.db') {
  fs.mkdirSync(path.dirname(dbPath), { recursive: true });
  const db = new Database(dbPath);
  db.pragma('journal_mode = WAL');
  return db;
}

export function initSchema(db: Database.Database, schemaFile = 'src/db/schema.sql') {
  const sql = fs.readFileSync(schemaFile, 'utf8');
  db.exec(sql);
}

/* Declarations/Manifests/Edges helpers omitted here for brevity — keep your existing ones */

/* Prices */
export function setPrice(db: Database.Database, versionId: string, satoshis: number) {
  db.prepare(
    `INSERT INTO prices(version_id, satoshis) VALUES (?, ?)
     ON CONFLICT(version_id) DO UPDATE SET satoshis = excluded.satoshis`,
  ).run(versionId, satoshis);
}
export function getPrice(db: Database.Database, versionId: string): number | undefined {
  const row = db.prepare('SELECT satoshis FROM prices WHERE version_id = ?').get(versionId) as any;
  return row?.satoshis;
}

/* Manifests (get) */
export function getManifest(db: Database.Database, versionId: string): ManifestRow | undefined {
  return db.prepare('SELECT * FROM manifests WHERE version_id = ?').get(versionId) as any;
}

/* Receipts */
export function insertReceipt(db: Database.Database, row: ReceiptRow) {
  const stmt = db.prepare(`
    INSERT INTO receipts(receipt_id, version_id, quantity, content_hash, amount_sat, status, created_at, expires_at)
    VALUES (@receipt_id, @version_id, @quantity, @content_hash, @amount_sat, @status, @created_at, @expires_at)
  `);
  stmt.run(row as any);
}

export function getReceipt(db: Database.Database, receiptId: string): ReceiptRow | undefined {
  return db.prepare('SELECT * FROM receipts WHERE receipt_id = ?').get(receiptId) as any;
}

export function setReceiptStatus(
  db: Database.Database,
  receiptId: string,
  status: ReceiptRow['status'],
) {
  db.prepare('UPDATE receipts SET status = ? WHERE receipt_id = ?').run(status, receiptId);
}

/* Revenue log */
export function logRevenue(db: Database.Database, ev: RevenueEventRow) {
  const stmt = db.prepare(`
    INSERT INTO revenue_events(receipt_id, version_id, amount_sat, quantity, created_at, type)
    VALUES (@receipt_id, @version_id, @amount_sat, @quantity, @created_at, @type)
  `);
  stmt.run(ev as any);
}
```

3) Create file: schemas/receipt.schema.json
With content:
```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$id": "schemas/receipt.schema.json",
  "title": "Overlay Receipt (MVP)",
  "type": "object",
  "required": ["receiptId", "versionId", "contentHash", "quantity", "amountSat", "status", "expiresAt", "createdAt"],
  "properties": {
    "receiptId": { "type": "string", "minLength": 8 },
    "versionId": { "type": "string", "pattern": "^[0-9a-fA-F]{64}$" },
    "contentHash": { "type": "string", "pattern": "^[0-9a-fA-F]{64}$" },
    "quantity": { "type": "integer", "minimum": 1 },
    "amountSat": { "type": "integer", "minimum": 1 },
    "status": { "type": "string", "enum": ["pending", "paid", "consumed", "expired"] },
    "createdAt": { "type": "integer", "minimum": 0 },
    "expiresAt": { "type": "integer", "minimum": 0 },
    "signature": { "type": "string", "minLength": 16 }
  },
  "additionalProperties": false
}
```

4) Create file: src/validators/receipt.ts
With content:
```ts
import fs from 'fs';
import path from 'path';
import Ajv from 'ajv';
import addFormats from 'ajv-formats';

let ajv: Ajv | null = null;
let validateReceiptFn: Ajv.ValidateFunction | null = null;

export function initReceiptValidator(schemaPath?: string) {
  if (!ajv) {
    ajv = new Ajv({ allErrors: true, strict: false });
    addFormats(ajv);
  }
  if (!validateReceiptFn) {
    const p = schemaPath || path.resolve(process.cwd(), 'schemas/receipt.schema.json');
    const schema = JSON.parse(fs.readFileSync(p, 'utf8'));
    validateReceiptFn = ajv!.compile(schema);
  }
}

export function validateReceipt(doc: unknown): { ok: boolean; errors?: any } {
  if (!ajv || !validateReceiptFn) initReceiptValidator();
  const ok = validateReceiptFn!(doc);
  if (!ok) return { ok: false, errors: validateReceiptFn!.errors };
  return { ok: true };
}
```

5) Create file: src/routes/pay.ts
With content:
```ts
import type { Request, Response, Router } from 'express';
import { Router as makeRouter } from 'express';
 //import crypto from 'crypto';
import { getManifest, getPrice, insertReceipt, getReceipt, logRevenue } from '../db';

const PRICE_DEFAULT_SATS = Number(process.env.PRICE_DEFAULT_SATS || 5000);
const RECEIPT_TTL_SEC = Number(process.env.RECEIPT_TTL_SEC || 1800); // 30 minutes

function isHex64(s: string): boolean { return /^[0-9a-fA-F]{64}$/.test(s); }

function randomId(prefix: string) {
  return `${prefix}_${crypto.randomBytes(8).toString('hex')}`;
}

function json(res: Response, code: number, body: any) {
  return res.status(code).json(body);
}

export function payRouter(db: Database.Database): Router {
  const router = makeRouter();

  // POST /pay { versionId, quantity }
  router.post('/pay', (req: Request, res: Response) => {
    try {
      const { versionId, quantity } = req.body || {};
      if (!isHex64(String(versionId || ''))) {
        return json(res, 400, { error: 'bad-request', hint: 'versionId=64-hex' });
      }
      if (!Number.isInteger(quantity) || quantity <= 0) {
        return json(res, 400, { error: 'bad-request', hint: 'quantity must be integer > 0' });
      }

      const man = getManifest(db, String(versionId).toLowerCase());
      if (!man) {
        return json(res, 404, { error: 'not-found', hint: 'manifest missing' });
      }

      const unit = getPrice(db, String(versionId).toLowerCase()) ?? PRICE_DEFAULT_SATS;
      const amount = unit * Number(quantity);
      const now = Math.floor(Date.now() / 1000);
      const expiresAt = now + RECEIPT_TTL_SEC;

      const receiptId = randomId('rcpt');
      insertReceipt(db, {
        receipt_id: receiptId,
        version_id: String(versionId).toLowerCase(),
        quantity: Number(quantity),
        content_hash: man.content_hash || null,
        amount_sat: amount,
        status: 'pending',
        created_at: now,
        expires_at: expiresAt,
      });

      // Simple revenue log entry (pending)
      logRevenue(db, {
        receipt_id: receiptId,
        version_id: String(versionId).toLowerCase(),
        amount_sat: amount,
        quantity: Number(quantity),
        created_at: now,
        type: 'pay',
      });

      // Return receipt JSON (schema-aligned). Signature omitted in MVP.
      return json(res, 200, {
        receiptId,
        versionId: String(versionId).toLowerCase(),
        contentHash: man.content_hash,
        quantity: Number(quantity),
        amountSat: amount,
        status: 'pending',
        createdAt: now,
        expiresAt,
      });
    } catch (e: any) {
      return json(res, 500, { error: 'pay-failed', message: String(e?.message || e) });
    }
  });

  // GET /receipt?receiptId=...
  router.get('/receipt', (req: Request, res: Response) => {
    const receiptId = String(req.query.receiptId || '');
    if (!receiptId || receiptId.length < 8) {
      return json(res, 400, { error: 'bad-request', hint: 'receiptId required' });
    }
    const r = getReceipt(db, receiptId);
    if (!r) {
      return json(res, 404, { error: 'not-found', hint: 'receipt missing' });
    }
    return json(res, 200, {
      receiptId: r.receipt_id,
      versionId: r.version_id,
      contentHash: r.content_hash,
      quantity: r.quantity,
      amountSat: r.amount_sat,
      status: r.status,
      createdAt: r.created_at,
      expiresAt: r.expires_at,
    });
  });

  return router;
}
```

6) Create file: test/integration/pay.spec.ts
With content:
```ts
import assert from 'assert';
import express from 'express';
import request from 'supertest';
 //import { initSchema, upsertManifest, setPrice } from '../../src/db';
import { payRouter } from '../../src/routes/pay';
import { initReceiptValidator, validateReceipt } from '../../src/validators/receipt';

(async function run() {
  // deterministic defaults for test
  process.env.PRICE_DEFAULT_SATS = '1000';
  process.env.RECEIPT_TTL_SEC = '120';

  initReceiptValidator(); // compile schema for validation

  const app = express();
  app.use(express.json({ limit: '1mb' }));
  const db = new Database(':memory:');
  initSchema(db);
  app.use(payRouter(db));

  const versionId = 'a'.repeat(64);
  const contentHash = 'c'.repeat(64);

  // Insert manifest row (required)
  upsertManifest(db, {
    version_id: versionId,
    manifest_hash: versionId,
    content_hash: contentHash,
    title: 'Test Dataset',
    license: 'cc-by-4.0',
    classification: 'public',
    created_at: '2024-05-01T00:00:00Z',
    manifest_json: JSON.stringify({
      type: 'datasetVersionManifest',
      datasetId: 'ds-test',
      content: { contentHash },
      provenance: { createdAt: '2024-05-01T00:00:00Z' },
      policy: { license: 'cc-by-4.0', classification: 'public' }
    })
  });

  // 1) /pay happy path with default price (1000 * 2 = 2000)
  const t0 = Math.floor(Date.now() / 1000);
  const r1 = await request(app)
    .post('/pay')
    .set('content-type', 'application/json')
    .send({ versionId, quantity: 2 });
  assert.strictEqual(r1.status, 200);
  const rec = r1.body;
  assert.strictEqual(rec.versionId, versionId);
  assert.strictEqual(rec.contentHash, contentHash);
  assert.strictEqual(rec.quantity, 2);
  assert.strictEqual(rec.amountSat, 2000);
  assert.ok(rec.expiresAt >= t0 && rec.expiresAt <= t0 + 120 + 2);

  // Schema-check
  const schemaRes = validateReceipt(rec);
  assert.strictEqual(schemaRes.ok, true, `receipt schema errors: ${JSON.stringify(schemaRes.errors)}`);

  // 2) Override price and pay again (price 2500 * 1 = 2500)
  setPrice(db, versionId, 2500);
  const r2 = await request(app)
    .post('/pay')
    .set('content-type', 'application/json')
    .send({ versionId, quantity: 1 });
  assert.strictEqual(r2.status, 200);
  assert.strictEqual(r2.body.amountSat, 2500);

  // 3) GET /receipt should return the last receipt by id
  const r3 = await request(app).get(`/receipt?receiptId=${r2.body.receiptId}`);
  assert.strictEqual(r3.status, 200);
  assert.strictEqual(r3.body.amountSat, 2500);

  // 4) Negative: unknown versionId
  const bad1 = await request(app).post('/pay').send({ versionId: 'b'.repeat(64), quantity: 1 }).set('content-type','application/json');
  assert.strictEqual(bad1.status, 404);

  // 5) Negative: invalid quantity
  const bad2 = await request(app).post('/pay').send({ versionId, quantity: 0 }).set('content-type','application/json');
  assert.strictEqual(bad2.status, 400);

  console.log('OK: /pay & /receipt tests passed.');
})().catch((e) => {
  console.error('pay tests failed:', e);
  process.exit(1);
});
```

7) Update file: package.json (add test script for pay)
With content patch:
```json
{
  "scripts": {
    "test:pay": "ts-node test/integration/pay.spec.ts"
  }
}
```

8) Update file: server.ts (mount pay router)
With content patch:
```ts
import express from 'express';
import { openDb, initSchema } from './src/db';
import { submitDlm1Router } from './src/routes/submit-builder';
import { submitReceiverRouter } from './src/routes/submit-receiver';
import { bundleRouter } from './src/routes/bundle';
import { readyRouter } from './src/routes/ready';
import { priceRouter } from './src/routes/price';
import { listingsRouter } from './src/routes/listings';
import { payRouter } from './src/routes/pay';

const PORT = Number(process.env.OVERLAY_PORT || 8788);
const BODY_MAX_SIZE = Number(process.env.BODY_MAX_SIZE || 1048576);

async function main() {
  const app = express();
  app.use(express.json({ limit: '2mb' }));

  const db = openDb();
  initSchema(db);

  app.use(submitDlm1Router());
  app.use(submitReceiverRouter(db, { bodyMaxSize: BODY_MAX_SIZE }));
  app.use(bundleRouter(db));
  app.use(readyRouter(db));
  app.use(priceRouter(db));
  app.use(payRouter(db));
  app.use(listingsRouter(db));

  app.get('/health', (_req, res) => res.json({ ok: true }));

  app.listen(PORT, () => console.log(`Overlay listening on :${PORT}`));
}
main().catch((e) => { console.error(e); process.exit(1); });
```

How to run D06
- Run migrations (schema updated): if using a file DB, delete ./data/overlay.db for a clean start or run ALTER TABLEs manually.
- Run tests:
  npm run test:pay

What you completed (matches D06 DoD)
- POST /pay: validates inputs, looks up price (override or default), computes total, generates a pending receipt with TTL, logs a revenue event, and returns a schema-valid receipt JSON.
- GET /receipt: returns up-to-date receipt status/limits.
- Status flow ready for D07: pending → consumed/expired (enforced in /v1/data).
- TRN1 optional: future enhancement to anchor payments on-chain; not blocking the MVP.

If you want, I can add a small “expire-receipts” cron script that marks pending receipts as expired after TTL, and wire it into a dev cron/PM2 task.
