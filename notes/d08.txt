

Awesome—here are the exact Cursor “Create/Update file … with content …” tasks to implement D08 (Producer Registry & Mapping). Paste them in order. This adds a producers table, maps manifests to producers by datasetId and identityKey on submit, exposes producer lookup/search endpoints, and enriches listings with publisher info.

1) Update file: src/db/schema.sql
With content (append or alter; keep existing tables):
```sql
-- Producers registry
CREATE TABLE IF NOT EXISTS producers (
  producer_id TEXT PRIMARY KEY,
  name TEXT,
  website TEXT,
  identity_key TEXT UNIQUE, -- hex compressed pubkey (66 chars), optional-unique
  created_at INTEGER NOT NULL
);

CREATE INDEX IF NOT EXISTS idx_producers_identity ON producers(identity_key);

-- Extend manifests with dataset_id and producer_id for mapping
ALTER TABLE manifests ADD COLUMN dataset_id TEXT;
ALTER TABLE manifests ADD COLUMN producer_id TEXT;

CREATE INDEX IF NOT EXISTS idx_manifests_dataset ON manifests(dataset_id);
CREATE INDEX IF NOT EXISTS idx_manifests_producer ON manifests(producer_id);
```

Notes
- If your SQLite doesn’t support repeated ALTER TABLE, run them once or recreate the DB in dev (rm ./data/overlay.db).
- If manifests already exist, columns will be NULL until resubmitted or backfilled.

2) Update file: src/db/index.ts
With content:
```ts
 //import fs from 'fs';
import path from 'path';

export type DeclarationRow = {
  version_id: string;
  txid: string | null;
  type: 'DLM1' | 'TRN1' | 'UNKNOWN';
  status: 'pending' | 'confirmed';
  created_at: number;
  block_hash: string | null;
  height: number | null;
  opret_vout: number | null;
  raw_tx: string | null;
  proof_json: string | null;
};

export type ManifestRow = {
  version_id: string;
  manifest_hash: string;
  content_hash: string | null;
  title: string | null;
  license: string | null;
  classification: string | null;
  created_at: string | null;
  manifest_json: string;
  dataset_id?: string | null;
  producer_id?: string | null;
};

export type ProducerRow = {
  producer_id: string;
  name: string | null;
  website: string | null;
  identity_key: string | null;
  created_at: number;
};

export function openDb(dbPath = process.env.DB_PATH || './data/overlay.db') {
  fs.mkdirSync(path.dirname(dbPath), { recursive: true });
  const db = new Database(dbPath);
  db.pragma('journal_mode = WAL');
  return db;
}

export function initSchema(db: Database.Database, schemaFile = 'src/db/schema.sql') {
  const sql = fs.readFileSync(schemaFile, 'utf8');
  db.exec(sql);
}

/* Producers */
export function upsertProducer(db: Database.Database, p: { identity_key?: string | null; name?: string | null; website?: string | null }): string {
  // If identity_key present and exists, reuse producer_id. Else create a new one.
  let existing: ProducerRow | undefined;
  if (p.identity_key) {
    existing = db.prepare('SELECT * FROM producers WHERE identity_key = ?').get(String(p.identity_key).toLowerCase()) as any;
  }
  if (existing) {
    // Optionally update name/website if provided
    db.prepare('UPDATE producers SET name = COALESCE(?, name), website = COALESCE(?, website) WHERE producer_id = ?')
      .run(p.name ?? null, p.website ?? null, existing.producer_id);
    return existing.producer_id;
  }
  const producer_id = 'pr_' + Math.random().toString(16).slice(2) + Date.now().toString(16);
  db.prepare(`
    INSERT INTO producers(producer_id, name, website, identity_key, created_at)
    VALUES (?, ?, ?, ?, ?)
  `).run(producer_id, p.name ?? null, p.website ?? null, p.identity_key ? String(p.identity_key).toLowerCase() : null, Math.floor(Date.now()/1000));
  return producer_id;
}

export function getProducerById(db: Database.Database, producerId: string): ProducerRow | undefined {
  return db.prepare('SELECT * FROM producers WHERE producer_id = ?').get(producerId) as any;
}

export function getProducerByDatasetId(db: Database.Database, datasetId: string): ProducerRow | undefined {
  // Resolve latest manifest for datasetId and join to producers
  const row = db.prepare(`
    SELECT p.* FROM manifests m
    JOIN producers p ON p.producer_id = m.producer_id
    WHERE m.dataset_id = ?
    ORDER BY m.created_at DESC NULLS LAST
    LIMIT 1
  `).get(datasetId) as any;
  return row as ProducerRow | undefined;
}

/* Declarations helpers kept from D01-D03 ... */

/* Manifests */
export function upsertManifest(db: Database.Database, row: ManifestRow) {
  const stmt = db.prepare(`
    INSERT INTO manifests(version_id, manifest_hash, content_hash, title, license, classification, created_at, manifest_json, dataset_id, producer_id)
    VALUES (@version_id, @manifest_hash, @content_hash, @title, @license, @classification, @created_at, @manifest_json, @dataset_id, @producer_id)
    ON CONFLICT(version_id) DO UPDATE SET
      manifest_hash=excluded.manifest_hash,
      content_hash=excluded.content_hash,
      title=excluded.title,
      license=excluded.license,
      classification=excluded.classification,
      created_at=excluded.created_at,
      manifest_json=excluded.manifest_json,
      dataset_id=COALESCE(excluded.dataset_id, manifests.dataset_id),
      producer_id=COALESCE(excluded.producer_id, manifests.producer_id)
  `);
  stmt.run(row as any);
}

export function getManifest(db: Database.Database, versionId: string): ManifestRow | undefined {
  return db.prepare('SELECT * FROM manifests WHERE version_id = ?').get(versionId) as any;
}

/* Listings: join producer info */
export function listListings(db: Database.Database, limit = 50, offset = 0) {
  const sql = `
    SELECT
      m.version_id,
      m.title,
      m.license,
      m.classification,
      m.content_hash,
      m.dataset_id,
      p.name AS producer_name,
      p.website AS producer_website,
      d.txid,
      d.status,
      d.created_at
    FROM manifests m
    LEFT JOIN declarations d ON d.version_id = m.version_id
    LEFT JOIN producers p ON p.producer_id = m.producer_id
    ORDER BY d.created_at DESC
    LIMIT ? OFFSET ?`;
  return db.prepare(sql).all(limit, offset) as any[];
}
```

3) Update file: src/services/ingest.ts
With content (only changes shown; keep previous logic):
```ts
 //import {
  upsertDeclaration,
  upsertManifest,
  replaceEdges,
  setOpretVout,
  // new:
  upsertProducer,
} from '../db';
import { deriveManifestIds, extractParents, decodeDLM1 } from '../dlm1/codec';
import { findFirstOpReturn } from '../utils/opreturn';

export async function ingestSubmission(opts: {
  db: Database.Database;
  manifest: any;
  txid: string;
  rawTx: string;
  envelopeJson?: any;
}): Promise<{ versionId: string; opretVout: number | null; tag: 'DLM1' | 'TRN1' | 'UNKNOWN' }> {
  const { db, manifest, txid, rawTx, envelopeJson } = opts;

  const { versionId, manifestHash } = deriveManifestIds(manifest);
  const parents = extractParents(manifest);

  // Producer mapping (datasetId + identityKey)
  const datasetId: string | undefined = typeof manifest?.datasetId === 'string' ? manifest.datasetId : undefined;
  const identityKey: string | undefined = typeof manifest?.provenance?.producer?.identityKey === 'string'
    ? String(manifest.provenance.producer.identityKey).toLowerCase()
    : undefined;

  let producerId: string | undefined = undefined;
  if (identityKey) {
    // Optional producer metadata from manifest
    const name: string | undefined = manifest?.provenance?.producer?.name || undefined;
    const website: string | undefined = manifest?.provenance?.producer?.website || undefined;
    producerId = upsertProducer(db, { identity_key: identityKey, name, website });
  }

  // ... OP_RETURN parsing + DLM1 check (unchanged) ...

  const opret = findFirstOpReturn(rawTx);
  let tag: 'DLM1' | 'TRN1' | 'UNKNOWN' = 'UNKNOWN';
  let opretVout: number | null = null;

  if (opret) {
    opretVout = opret.vout;
    tag = opret.tagAscii === 'DLM1' ? 'DLM1' : opret.tagAscii === 'TRN1' ? 'TRN1' : 'UNKNOWN';

    if (tag === 'DLM1' && opret.pushesHex.length > 0) {
      const tagHex = Buffer.from('DLM1', 'ascii').toString('hex');
      let cborHex: string | null = null;
      if (opret.pushesAscii[0] === 'DLM1' && opret.pushesHex[1]) cborHex = opret.pushesHex[1];
      else if (opret.pushesHex[0].startsWith(tagHex)) cborHex = opret.pushesHex[0].slice(tagHex.length);
      if (cborHex) {
        const decoded = decodeDLM1(Buffer.from(cborHex, 'hex'));
        if (decoded.mh.toLowerCase() !== versionId.toLowerCase()) {
          throw new Error('onchain-mh-mismatch: DLM1.mh != derived manifest hash');
        }
      }
    }
  }

  // Persist manifest with dataset_id and producer_id mapping when available
  upsertManifest(db, {
    version_id: versionId,
    manifest_hash: manifestHash,
    content_hash: manifest?.content?.contentHash || null,
    title: manifest?.description || null,
    license: manifest?.policy?.license || null,
    classification: manifest?.policy?.classification || null,
    created_at: manifest?.provenance?.createdAt || null,
    manifest_json: JSON.stringify(manifest),
    dataset_id: datasetId || null,
    producer_id: producerId || null,
  });

  upsertDeclaration(db, {
    version_id: versionId,
    txid: txid.toLowerCase(),
    type: tag,
    status: 'pending',
    created_at: Math.floor(Date.now() / 1000),
    raw_tx: rawTx,
  } as any);

  if (opretVout !== null) setOpretVout(db, versionId, opretVout);
  if (parents.length) replaceEdges(db, versionId, parents);
  if (envelopeJson) {
    // keep existing envelope persist if implemented in your codebase
  }

  return { versionId, opretVout, tag };
}
```

4) Create file: src/routes/producers.ts
With content:
```ts
import type { Request, Response, Router } from 'express';
import { Router as makeRouter } from 'express';
 //import { getProducerById, getProducerByDatasetId } from '../db';

function json(res: Response, code: number, body: any) {
  return res.status(code).json(body);
}

/**
 * Producers API
 * - GET /producers/:id
 * - GET /producers?datasetId=...  (resolve mapping)
 * - (Optional) GET /producers?q=... (basic search by name, requires additional DB helper; omitted in MVP)
 */
export function producersRouter(db: Database.Database): Router {
  const router = makeRouter();

  // Resolve by datasetId
  router.get('/producers', (req: Request, res: Response) => {
    const datasetId = String(req.query.datasetId || '').trim();
    if (!datasetId) {
      return json(res, 400, { error: 'bad-request', hint: 'provide datasetId' });
    }
    const p = getProducerByDatasetId(db, datasetId);
    if (!p) return json(res, 404, { error: 'not-found', hint: 'no producer for datasetId' });
    return json(res, 200, {
      producerId: p.producer_id,
      name: p.name,
      website: p.website,
      identityKey: p.identity_key,
      createdAt: p.created_at,
    });
  });

  // Fetch by producer_id
  router.get('/producers/:id', (req: Request, res: Response) => {
    const id = String(req.params.id || '').trim();
    if (!id) return json(res, 400, { error: 'bad-request' });
    const p = getProducerById(db, id);
    if (!p) return json(res, 404, { error: 'not-found' });
    return json(res, 200, {
      producerId: p.producer_id,
      name: p.name,
      website: p.website,
      identityKey: p.identity_key,
      createdAt: p.created_at,
    });
  });

  return router;
}
```

5) Update file: src/routes/listings.ts
With content (enrich listing items with producer info already added in DB listListings):
```ts
import type { Request, Response, Router } from 'express';
import { Router as makeRouter } from 'express';
 //import { listListings } from '../db';

export function listingsRouter(db: Database.Database): Router {
  const router = makeRouter();

  router.get('/listings', (req: Request, res: Response) => {
    const limit = Math.min(Number(req.query.limit || 50), 200);
    const offset = Math.max(Number(req.query.offset || 0), 0);
    const items = listListings(db, limit, offset);
    return res.status(200).json({ items, limit, offset });
  });

  return router;
}
```

6) Update file: public/app.js
With content patch (show publisher on cards):
```js
// ... keep existing code ...

  for (const it of filtered) {
    const card = document.createElement('div');
    card.className = 'card';
    const publisher = it.producer_name ? `${it.producer_name}` : '(unknown publisher)';
    const website = it.producer_website ? ` — <a href="${it.producer_website}" target="_blank" rel="noopener">site</a>` : '';
    card.innerHTML = `
      <div><strong>${it.title || '(no title)'}</strong></div>
      <div class="muted">publisher: ${publisher}${website}</div>
      <div class="muted">versionId: <span class="mono">${it.version_id}</span></div>
      <div class="muted">contentHash: <span class="mono">${it.content_hash || '-'}</span></div>
      <div class="row">
        <span class="badge">${it.license || 'unknown'}</span>
        <span class="badge">${it.classification || 'n/a'}</span>
        <span class="badge">${it.status || 'pending'}</span>
      </div>
      <div style="margin-top:8px;">
        <button data-vid="${it.version_id}">View</button>
      </div>
    `;
    card.querySelector('button').addEventListener('click', () => viewDetails(it.version_id));
    el.appendChild(card);
  }
// ... keep existing code ...
```

7) Update file: server.ts (mount producers router)
With content patch:
```ts
import express from 'express';
import { openDb, initSchema } from './src/db';
import { submitDlm1Router } from './src/routes/submit-builder';
import { submitReceiverRouter } from './src/routes/submit-receiver';
import { bundleRouter } from './src/routes/bundle';
import { readyRouter } from './src/routes/ready';
import { priceRouter } from './src/routes/price';
import { listingsRouter } from './src/routes/listings';
import { payRouter } from './src/routes/pay';
import { dataRouter } from './src/routes/data';
import { producersRouter } from './src/routes/producers';

const PORT = Number(process.env.OVERLAY_PORT || 8788);
const BODY_MAX_SIZE = Number(process.env.BODY_MAX_SIZE || 1048576);

async function main() {
  const app = express();
  app.use(express.json({ limit: '2mb' }));

  const db = openDb();
  initSchema(db);

  app.use(submitDlm1Router());
  app.use(submitReceiverRouter(db, { bodyMaxSize: BODY_MAX_SIZE }));
  app.use(bundleRouter(db));
  app.use(readyRouter(db));
  app.use(priceRouter(db));
  app.use(payRouter(db));
  app.use(dataRouter(db));
  app.use(listingsRouter(db));
  app.use(producersRouter(db)); // <-- new

  app.get('/health', (_req, res) => res.json({ ok: true }));

  app.listen(PORT, () => console.log(`Overlay listening on :${PORT}`));
}
main().catch((e) => { console.error(e); process.exit(1); });
```

8) Create file: test/integration/producers.spec.ts
With content:
```ts
import assert from 'assert';
import express from 'express';
import request from 'supertest';
 //import { initSchema, upsertProducer, upsertManifest } from '../../src/db';
import { producersRouter } from '../../src/routes/producers';

(async function run() {
  const app = express();
  app.use(express.json({ limit: '1mb' }));
  const db = new Database(':memory:');
  initSchema(db);
  app.use(producersRouter(db));

  // Insert a producer
  const producerId = upsertProducer(db, {
    identity_key: '02aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa',
    name: 'Acme Data',
    website: 'https://acme.example'
  });

  // Map a manifest to datasetId + producer
  const versionId = 'a'.repeat(64);
  const datasetId = 'open-images-50k';
  upsertManifest(db, {
    version_id: versionId,
    manifest_hash: versionId,
    content_hash: 'c'.repeat(64),
    title: 'Test',
    license: 'cc-by-4.0',
    classification: 'public',
    created_at: '2024-05-01T00:00:00Z',
    manifest_json: JSON.stringify({}),
    dataset_id: datasetId,
    producer_id: producerId
  });

  // Resolve by datasetId
  const r1 = await request(app).get(`/producers?datasetId=${encodeURIComponent(datasetId)}`);
  assert.strictEqual(r1.status, 200);
  assert.strictEqual(r1.body.producerId, producerId);
  assert.strictEqual(r1.body.name, 'Acme Data');

  // Fetch by id
  const r2 = await request(app).get(`/producers/${producerId}`);
  assert.strictEqual(r2.status, 200);
  assert.strictEqual(r2.body.identityKey?.startsWith('02'), true);

  console.log('OK: Producers registry & mapping tests passed.');
})().catch((e) => {
  console.error('producers tests failed:', e);
  process.exit(1);
});
```

How to run D08
- Apply schema changes (new table + columns). In dev, easiest is to recreate the DB:
  rm -f ./data/overlay.db
- Run tests:
  ts-node test/integration/producers.spec.ts

What you completed (matches D08 DoD)
- Producers registry (producer_id, name, website, identity_key, created_at).
- Mapping manifests to producers via datasetId and provenance.producer.identityKey during ingest.
- Endpoints:
  - GET /producers?datasetId=… → resolve mapping
  - GET /producers/:id → fetch profile
- Listings show publisher info (name/website).
- Clear path to D19 for identity-signed producer actions (e.g., POST /producers/register) using BRC-31 headers.

If you want, I can add an optional POST /producers/register (identity-signed) in D19, and a backfill script to populate producer_id for existing manifests from their provenance fields.

