) Create file: scripts/a2a-demo.ts
With content:
```ts
/**
 * A2A Demo (D16): GenoScreener → Molecula → ToxSim
 * Flow per stage:
 *  1) Prepare blob (bytes) and compute contentHash = sha256(bytes)
 *  2) Build manifest (datasetId, contentHash, provenance.producer identity) + publish:
 *     - POST /submit/dlm1 -> OP_RETURN scriptHex
 *     - Build synthetic rawTx (dev) and POST /submit { rawTx, manifest }
 *  3) POST /price (per-version price)
 *  4) GET /price -> POST /pay -> GET /v1/data -> compute sha256(download) == contentHash
 *  5) Stage i+1 references stage i via lineage.parents
 *  6) At the end: GET /bundle?versionId=<ToxSim> (depth 99), save all evidence JSON
 *
 * NOTE:
 * - This is a dev/staging demo. In production, replace synthetic TX with a real wallet-signed transaction.
 * - Requires DATA_ROOT to be accessible by /v1/data route (D07) to stream local files.
 */

import fs from 'fs';
import path from 'path';
import crypto from 'crypto';

type Hex = string;
type Json = any;

function exitErr(msg: string, code = 2): never {
  console.error('[a2a] ERROR:', msg);
  process.exit(code);
}

function ensureDir(p: string) {
  fs.mkdirSync(p, { recursive: true });
}

function sha256Hex(buf: Buffer): string {
  return crypto.createHash('sha256').update(buf).digest('hex');
}

async function httpJson(method: 'GET' | 'POST', url: string, body?: any, timeoutMs = 10000): Promise<any> {
  const ctl = new AbortController();
  const tm = setTimeout(() => ctl.abort(), timeoutMs);
  try {
    const r = await fetch(url, {
      method,
      signal: ctl.signal as any,
      headers: { 'accept': 'application/json', ...(body ? { 'content-type': 'application/json' } : {}) },
      body: body ? JSON.stringify(body) : undefined,
    });
    const text = await r.text();
    if (!r.ok) {
      let err: any;
      try { err = JSON.parse(text); } catch { err = text; }
      exitErr(`HTTP ${r.status} ${r.statusText} ${url} ${typeof err === 'string' ? err : JSON.stringify(err)}`, 1);
    }
    try { return JSON.parse(text); } catch { return { raw: text }; }
  } finally {
    clearTimeout(tm);
  }
}

async function httpBinary(url: string, timeoutMs = 20000): Promise<Uint8Array> {
  const ctl = new AbortController();
  const tm = setTimeout(() => ctl.abort(), timeoutMs);
  try {
    const r = await fetch(url, { signal: ctl.signal as any });
    if (!r.ok) exitErr(`HTTP ${r.status} ${r.statusText} ${url}`, 1);
    const ab = await r.arrayBuffer();
    return new Uint8Array(ab);
  } finally {
    clearTimeout(tm);
  }
}

// --- Minimal TX builder for OP_RETURN-only (dev demo) ---
function varInt(n: number): Uint8Array {
  if (n < 0xfd) return Uint8Array.of(n);
  if (n <= 0xffff) return Uint8Array.of(0xfd, n & 0xff, (n >> 8) & 0xff);
  return Uint8Array.of(0xfe, n & 0xff, (n >> 8) & 0xff, (n >> 16) & 0xff, (n >> 24) & 0xff);
}
function fromHex(hex: string): Uint8Array {
  if (!/^[0-9a-fA-F]*$/.test(hex) || hex.length % 2 !== 0) throw new Error('invalid hex');
  const out = new Uint8Array(hex.length / 2);
  for (let i = 0; i < out.length; i++) out[i] = parseInt(hex.slice(i * 2, i * 2 + 2), 16);
  return out;
}
function toHex(b: Uint8Array): string {
  return Array.from(b).map((x) => x.toString(16).padStart(2, '0')).join('');
}
function concatBytes(arr: Uint8Array[]): Uint8Array {
  const len = arr.reduce((n, a) => n + a.length, 0);
  const out = new Uint8Array(len);
  let o = 0;
  for (const a of arr) { out.set(a, o); o += a.length; }
  return out;
}
function buildRawTxWithOpReturn(scriptHex: string): string {
  const version = Uint8Array.of(1, 0, 0, 0);
  const vinCount = varInt(1);
  const prevTxid = new Uint8Array(32);
  const prevVout = Uint8Array.of(0xff, 0xff, 0xff, 0xff);
  const scriptSigLen = varInt(0);
  const sequence = Uint8Array.of(0xff, 0xff, 0xff, 0xff);
  const voutCount = varInt(1);
  const value0 = new Uint8Array(8);
  const script = fromHex(scriptHex);
  const scriptLen = varInt(script.length);
  const locktime = new Uint8Array(4);
  const tx = concatBytes([version, vinCount, prevTxid, prevVout, scriptSigLen, sequence, voutCount, value0, scriptLen, script, locktime]);
  return toHex(tx);
}

// --- Evidence writer ---
function saveEvidence(dir: string, name: string, obj: Json | Buffer | Uint8Array | string) {
  ensureDir(dir);
  const p = path.join(dir, name);
  if (obj instanceof Uint8Array || Buffer.isBuffer(obj)) {
    fs.writeFileSync(p, Buffer.from(obj));
  } else if (typeof obj === 'string') {
    fs.writeFileSync(p, obj, 'utf8');
  } else {
    fs.writeFileSync(p, JSON.stringify(obj, null, 2), 'utf8');
  }
  console.log('[a2a] saved', p);
}

async function main() {
  const host = (process.env.OVERLAY_URL || 'http://localhost:8788').replace(/\/+$/, '');
  const dataRoot = process.env.DATA_ROOT || path.resolve(process.cwd(), 'data', 'blobs');
  const outDir = path.resolve(process.cwd(), 'evidence', 'a2a-' + Date.now());
  ensureDir(outDir);
  ensureDir(dataRoot);

  // Agents and datasetIds
  const stages = [
    { key: 'genoscreener', datasetId: 'geno-screener' },
    { key: 'molecula', datasetId: 'molecula' },
    { key: 'toxsim', datasetId: 'tox-sim' },
  ];
  const identityKey = (process.env.IDENTITY_KEY || '02').padEnd(66, 'a'); // demo

  const produced: { versionId: Hex; datasetId: string; contentHash: Hex; txid: Hex }[] = [];

  for (let i = 0; i < stages.length; i++) {
    const s = stages[i];
    const stageDir = path.join(outDir, `${(i + 1).toString().padStart(2, '0')}-${s.key}`);
    ensureDir(stageDir);

    // 1) Prepare blob & contentHash
    const fakeBytes = crypto.randomBytes(256 + i * 10);
    const contentHash = sha256Hex(fakeBytes);
    fs.writeFileSync(path.join(dataRoot, contentHash), fakeBytes);
    saveEvidence(stageDir, `blob-${s.key}.bin`, fakeBytes);

    // 2) Build manifest with optional parent
    const parents = i > 0 ? [produced[i - 1].versionId] : [];
    const manifest = {
      type: 'datasetVersionManifest',
      datasetId: s.datasetId,
      description: `A2A demo stage: ${s.key}`,
      content: { contentHash },
      lineage: { parents },
      provenance: {
        createdAt: new Date().toISOString(),
        producer: { identityKey, name: 'A2A Demo Producer', website: 'https://example.com' },
        locations: [{ type: 'local', uri: `file://${path.join(dataRoot, contentHash)}` }]
      },
      policy: { license: 'cc-by-4.0', classification: 'public' }
    };
    saveEvidence(stageDir, `manifest-${s.key}.json`, manifest);

    // 3) Builder → scriptHex
    const build = await httpJson('POST', `${host}/submit/dlm1`, { manifest });
    saveEvidence(stageDir, `builder-${s.key}.json`, build);
    const versionId: Hex = build.versionId;
    const scriptHex: string = build.opReturnScriptHex || build.outputs?.[0]?.scriptHex;
    if (!versionId || !scriptHex) exitErr('builder missing versionId/scriptHex');

    // 4) Synthetic rawTx + Receiver
    const rawTx = buildRawTxWithOpReturn(scriptHex);
    const submit = await httpJson('POST', `${host}/submit`, { rawTx, manifest });
    saveEvidence(stageDir, `submit-${s.key}.json`, submit);
    const txid: Hex = submit.txid;

    // 5) Set price (demo: 1000 + i*500 sat)
    const setP = await httpJson('POST', `${host}/price`, { versionId, satoshis: 1000 + i * 500 });
    saveEvidence(stageDir, `price-set-${s.key}.json`, setP);

    // 6) Quote & Pay
    const quote = await httpJson('GET', `${host}/price?versionId=${versionId}`, undefined);
    saveEvidence(stageDir, `price-get-${s.key}.json`, quote);
    const receipt = await httpJson('POST', `${host}/pay`, { versionId, quantity: 1 });
    saveEvidence(stageDir, `pay-${s.key}.json`, receipt);

    // 7) Download (stream) and verify hash
    const bytes = await httpBinary(`${host}/v1/data?contentHash=${contentHash}&receiptId=${receipt.receiptId}`);
    saveEvidence(stageDir, `download-${s.key}.bin`, bytes);
    const gotHash = sha256Hex(Buffer.from(bytes));
    const hashOk = gotHash.toLowerCase() === contentHash.toLowerCase();
    saveEvidence(stageDir, `hash-check-${s.key}.json`, { gotHash, expected: contentHash, ok: hashOk });
    if (!hashOk) exitErr(`hash mismatch at stage ${s.key}`);

    console.log(`[a2a] stage ${s.key} published versionId=${versionId}, txid=${txid}`);
    produced.push({ versionId, datasetId: s.datasetId, contentHash, txid });
  }

  // Final: bundle for last version (depth 99), and ready check
  const last = produced.at(-1)!;
  const bundle = await httpJson('GET', `${host}/bundle?versionId=${last.versionId}`, undefined);
  saveEvidence(outDir, `final-bundle.json`, bundle);

  const ready = await httpJson('GET', `${host}/ready?versionId=${last.versionId}`, undefined);
  saveEvidence(outDir, `final-ready.json`, ready);

  // Evidence: minimal revenue log snapshot (optional: direct DB)
  // Attempt to snapshot revenue_events via DB if DB_PATH set, else skip
  try {
    const dbPath = process.env.DB_PATH;
    if (dbPath && fs.existsSync(dbPath)) {
      // lazy import better-sqlite3 only when available
      // eslint-disable-next-line @typescript-eslint/no-var-requires
      const Database = require('better-sqlite3');
      const db = new Database(dbPath);
      const evs = db.prepare('SELECT * FROM revenue_events ORDER BY created_at DESC LIMIT 100').all();
      saveEvidence(outDir, `revenue_events.json`, evs);
      db.close();
    }
  } catch (e: any) {
    console.warn('[a2a] revenue snapshot skipped:', String(e?.message || e));
  }

  // Print shareable links
  const links = {
    ready: `${host}/ready?versionId=${last.versionId}`,
    bundle: `${host}/bundle?versionId=${last.versionId}&depth=99`,
    price: `${host}/price?versionId=${last.versionId}`,
    listings: `${host}/listings`,
  };
  console.log('---');
  console.log('[a2a] DONE');
  console.log(JSON.stringify({ chain: produced, links }, null, 2));
}

main().catch((e) => exitErr(String(e?.message || e)));
```

2) Update file: package.json
With content patch (add a convenient script):
```json
{
  "scripts": {
    "cli:a2a": "ts-node scripts/a2a-demo.ts"
  }
}
```

3) Create file: scripts/README-a2a-demo.md
With content:
```md
# A2A Demo Script (GenoScreener → Molecula → ToxSim)

Purpose
- End-to-end showcase of a three-agent chain that anchors DLM1 versions, pays/streams, and produces a final lineage bundle with evidence.

Prereqs
- Overlay running (D01–D15 implemented)
- DATA_ROOT configured for /v1/data (D07)
- Optional: DB_PATH set if you want revenue_events snapshot

Run
```bash
OVERLAY_URL=http://localhost:8788 \
DATA_ROOT=./data/blobs \
IDENTITY_KEY=02aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa \
npm run cli:a2a
```

What it does
1. For each stage (geno-screener, molecula, tox-sim):
   - Creates a small blob file; computes SHA-256 contentHash
   - Builds/publishes a DLM1 manifest (parents chained)
   - Sets price, gets quote, pays 1 unit
   - Streams the blob back and verifies sha256 == contentHash
   - Saves all JSON artifacts to evidence/a2a-<timestamp>/

2. At the end:
   - GET /bundle?versionId=<tox-sim> (depth 99) and GET /ready
   - Writes final-bundle.json and final-ready.json
   - Optionally snapshots revenue_events if DB_PATH is set

Outputs
- Evidence pack at evidence/a2a-<timestamp>/ including:
  - stage manifests, builder/submit responses, price/pay receipts, downloads, hash checks
  - final-bundle.json and final-ready.json
  - optional revenue_events.json (last 100 rows)

Success criteria
- /bundle depth 99 shows the full chain
- All hash checks OK
- Receipts logged; optional revenue_events snapshot present

Notes
- In production, replace the synthetic rawTx with a wallet-signed transaction and call /submit with the real rawTx + manifest.
```

How to run the demo
- Start the overlay
- Ensure DATA_ROOT exists and is configured to your /v1/data route (D07)
- Run:
  npm run cli:a2a

Definition of Done (D16)
- The final printed links include /bundle with depth 99 showing the complete chain.
- Evidence pack contains all JSON artifacts and hash checks.
- Revenue logged (receipts), optionally included via DB snapshot.

This script is non-intrusive: it uses only the public API you already have (plus optional DB read for revenue).
