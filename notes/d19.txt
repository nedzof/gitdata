19:
Awesome—here are the exact Cursor “Create/Update file … with content …” tasks to implement D19 (Identity-signed Producer, BRC‑31 style). Paste them in order. This adds:

- An identity verification middleware that enforces X-Identity-Key, X-Nonce, X-Signature.
- Replay protection with an in-memory nonce store (TTL).
- Pluggable policy via ENV (IDENTITY_REQUIRED=true/false).
- Integrations on sensitive producer endpoints (POST /submit/dlm1, POST /price, POST/DELETE /price/rules).
- An integration test demonstrating valid signature, wrong key, and replay rejection.

Assumptions
- Signature scheme: ECDSA over secp256k1.
- Message to sign: sha256(utf8(JSON.stringify(body) + nonce)).
- Headers:
  - X-Identity-Key: 33-byte compressed pubkey hex
  - X-Nonce: arbitrary unique string (e.g., uuid v4)
  - X-Signature: signature hex (DER or compact r||s) — we try both.

We use @noble/secp256k1 for verification.

1) Update file: package.json (add noble-secp256k1)
With content patch:
```json
{
  "dependencies": {
    "@noble/secp256k1": "^2.1.0"
  }
}
```

2) Create file: src/middleware/identity.ts
With content:
```ts
/**
 * Identity (BRC-31 style) verifier middleware
 *
 * Policy:
 * - Enabled via ENV IDENTITY_REQUIRED=true|false (default false).
 * - Required for sensitive producer endpoints (POST /submit/dlm1, POST /price, POST/DELETE /price/rules).
 *
 * Signature:
 * - Headers: X-Identity-Key (33-byte compressed pubkey hex), X-Nonce, X-Signature (hex)
 * - Message = sha256( utf8( JSON.stringify(body) + nonce ) )
 * - Verify ECDSA (secp256k1). Accept DER or 64-byte compact (r||s) signatures.
 * - Replay protection: Nonce stored in-memory with TTL (NONCE_TTL_SEC, default 120s).
 *
 * On success: attaches req.identityKey = <hex>.
 * On failure: 401 { error: 'unauthorized', hint }
 */

import type { Request, Response, NextFunction } from 'express';
import { createHash } from 'crypto';
import * as secp from '@noble/secp256k1';

const IDENTITY_REQUIRED = /^true$/i.test(process.env.IDENTITY_REQUIRED || 'false');
const NONCE_TTL_SEC = Number(process.env.NONCE_TTL_SEC || 120);

type NonceRecord = { exp: number; key?: string };
const nonceStore = new Map<string, NonceRecord>();

function nowSec() {
  return Math.floor(Date.now() / 1000);
}

function sha256Hex(buf: Buffer) {
  return createHash('sha256').update(buf).digest('hex');
}

function normalizeHex(h?: string): string {
  return (h || '').toLowerCase();
}

function isCompressedPubKey(hex: string): boolean {
  return /^[0-9a-fA-F]{66}$/.test(hex) && (hex.startsWith('02') || hex.startsWith('03'));
}

async function verifySigEcdsa(sigHex: string, msgHashHex: string, pubKeyHex: string): Promise<boolean> {
  const msg = Buffer.from(msgHashHex, 'hex');
  const pub = Buffer.from(pubKeyHex, 'hex');
  const sig = Buffer.from(sigHex, 'hex');

  // Try DER first (variable length)
  try {
    const ok = secp.verify(sig, msg, pub, { strict: true });
    if (ok) return true;
  } catch {
    // ignore; try compact
  }
  // Try compact 64-byte r||s
  try {
    if (sig.length === 64) {
      const parsed = secp.Signature.fromCompact(sig);
      return parsed.verify(msg, pub);
    }
  } catch {
    // ignore
  }
  return false;
}

/**
 * Verify signature middleware factory.
 * If required=false, it will only verify when headers are present; otherwise, it continues (best-effort).
 * If required=true, missing/invalid signature → 401.
 */
export function requireIdentity(required = IDENTITY_REQUIRED) {
  return async function identityMiddleware(req: Request & { identityKey?: string }, res: Response, next: NextFunction) {
    try {
      const idKey = normalizeHex(String(req.headers['x-identity-key'] || ''));
      const nonce = String(req.headers['x-nonce'] || '');
      const sigHex = normalizeHex(String(req.headers['x-signature'] || ''));

      if (!required && !idKey && !nonce && !sigHex) {
        // Not required and not provided: pass through
        return next();
      }

      if (!isCompressedPubKey(idKey)) {
        return res.status(401).json({ error: 'unauthorized', hint: 'missing/invalid X-Identity-Key (compressed pubkey hex)' });
      }
      if (!nonce || nonce.length < 8) {
        return res.status(401).json({ error: 'unauthorized', hint: 'missing/invalid X-Nonce' });
      }
      if (!/^[0-9a-fA-F]+$/.test(sigHex) || sigHex.length < 64) {
        return res.status(401).json({ error: 'unauthorized', hint: 'missing/invalid X-Signature' });
      }

      // Replay protection
      // - Nonce must be unused; once seen, it is stored for NONCE_TTL_SEC
      const existing = nonceStore.get(nonce);
      const now = nowSec();
      if (existing && existing.exp >= now) {
        return res.status(401).json({ error: 'unauthorized', hint: 'nonce-reused' });
      }

      // Compute message hash: sha256( JSON.stringify(body) + nonce )
      // body may be undefined → use empty object {} for determinism
      const bodyStr = JSON.stringify(req.body ?? {});
      const msgHashHex = sha256Hex(Buffer.from(bodyStr + nonce, 'utf8'));

      const ok = await verifySigEcdsa(sigHex, msgHashHex, idKey);
      if (!ok) {
        return res.status(401).json({ error: 'unauthorized', hint: 'signature-invalid' });
      }

      // Store nonce
      nonceStore.set(nonce, { exp: now + NONCE_TTL_SEC, key: idKey });

      // Attach identity to request
      req.identityKey = idKey;

      return next();
    } catch (e: any) {
      return res.status(401).json({ error: 'unauthorized', hint: String(e?.message || e) });
    }
  };
}
```

3) Update file: src/routes/submit-builder.ts (enable identity on POST /submit/dlm1)
With content patch:
```ts
import { requireIdentity } from '../middleware/identity';

// inside submitDlm1Router():
// add middleware at route level
router.post('/submit/dlm1', requireIdentity(), async (req, res) => {
  // ... existing handler ...
});
```

4) Update file: src/routes/price.ts (protect POST endpoints)
With content patch:
```ts
import { requireIdentity } from '../middleware/identity';

// inside priceRouter():
router.post('/price', requireIdentity(), (req, res) => {
  // ... existing logic ...
});

router.post('/price/rules', requireIdentity(), (req, res) => {
  // ... existing logic ...
});

router.delete('/price/rules', requireIdentity(), (req, res) => {
  // ... existing logic ...
});
```

5) Optional: provide a minimal producers registration endpoint (if you want identity-bound profile updates)
Create file: src/routes/producers-register.ts
With content:
```ts
import type { Request, Response, Router } from 'express';
import { Router as makeRouter } from 'express';
import Database from 'better-sqlite3';
import { upsertProducer } from '../db';
import { requireIdentity } from '../middleware/identity';

/**
 * POST /producers/register { name?, website? }
 * Requires identity signature; associates identity key with producer profile.
 */
export function producersRegisterRouter(db: Database.Database): Router {
  const router = makeRouter();

  router.post('/producers/register', requireIdentity(true), (req: Request & { identityKey?: string }, res: Response) => {
    try {
      const name = typeof req.body?.name === 'string' ? req.body.name : undefined;
      const website = typeof req.body?.website === 'string' ? req.body.website : undefined;
      const pid = upsertProducer(db, { identity_key: req.identityKey!, name, website });
      return res.status(200).json({ status: 'ok', producerId: pid });
    } catch (e: any) {
      return res.status(500).json({ error: 'register-failed', message: String(e?.message || e) });
    }
  });

  return router;
}
```

6) Update file: server.ts (mount registration route)
With content patch:
```ts
import { producersRegisterRouter } from './src/routes/producers-register';

// after DB init and before other routers or anywhere in routers:
app.use(producersRegisterRouter(db));
```

7) Update file: sdk/README.md (show withIdentityHeaders usage)
With content patch (add a note at the end):
```md
Signing (BRC-31 style)
- For protected endpoints (POST /submit/dlm1, POST /price, POST/DELETE /price/rules), include headers:
  X-Identity-Key: <33-byte compressed pubkey hex>
  X-Nonce: <uuid or random string>
  X-Signature: <hex signature over sha256(JSON.stringify(body) + nonce)>

In your wallet/client, you can reuse the helper:
- See src/brc/index.ts -> BRC100.withIdentityHeaders() for header assembly.
- Ensure the signMessage() returns ECDSA signature hex (DER or compact r||s).
```

8) Create file: test/integration/identity.spec.ts
With content:
```ts
import assert from 'assert';
import express from 'express';
import request from 'supertest';
import Database from 'better-sqlite3';
import { initSchema } from '../../src/db';
import { submitDlm1Router } from '../../src/routes/submit-builder';
import { requireIdentity } from '../../src/middleware/identity';
import * as secp from '@noble/secp256k1';
import { createHash } from 'crypto';

// Force identity required
process.env.IDENTITY_REQUIRED = 'true';

function sha256Hex(buf: Buffer) {
  return createHash('sha256').update(buf).digest('hex');
}

(async function run() {
  const app = express();
  app.use(express.json({ limit: '1mb' }));

  const db = new Database(':memory:');
  initSchema(db);

  // Mount builder (already requires identity via internal change)
  app.use(submitDlm1Router({}));

  // Prepare a dummy manifest for call
  const manifest = {
    type: 'datasetVersionManifest',
    datasetId: 'ds-i',
    content: { contentHash: 'c'.repeat(64) },
    provenance: { createdAt: '2024-01-01T00:00:00Z', producer: {} },
    policy: { license: 'cc-by-4.0', classification: 'public' }
  };

  // Generate secp256k1 key pair
  const priv = secp.utils.randomPrivateKey();
  const pub = secp.getPublicKey(priv, true); // compressed
  const idKey = Buffer.from(pub).toString('hex');

  // Build headers for a valid request
  const nonce = 'nonce-' + Date.now();
  const bodyStr = JSON.stringify({ manifest });
  const msgHashHex = sha256Hex(Buffer.from(bodyStr + nonce, 'utf8'));
  const sigDer = Buffer.from(secp.signSync(msgHashHex, priv, { der: true })).toString('hex');

  const r1 = await request(app)
    .post('/submit/dlm1')
    .set('x-identity-key', idKey)
    .set('x-nonce', nonce)
    .set('x-signature', sigDer)
    .send({ manifest });
  // Cannot fully complete because builder tries to derive versionId from manifest etc. We only test 401 vs non-401.
  assert.notStrictEqual(r1.status, 401, `should not be unauthorized, got ${r1.status}`);

  // Wrong key
  const wrongPriv = secp.utils.randomPrivateKey();
  const wrongPub = secp.getPublicKey(wrongPriv, true);
  const wrongId = Buffer.from(wrongPub).toString('hex');
  const r2 = await request(app)
    .post('/submit/dlm1')
    .set('x-identity-key', wrongId)
    .set('x-nonce', 'nonce-2')
    .set('x-signature', sigDer) // signature from the first key
    .send({ manifest });
  assert.strictEqual(r2.status, 401);

  // Replay attack (reuse nonce)
  const r3 = await request(app)
    .post('/submit/dlm1')
    .set('x-identity-key', idKey)
    .set('x-nonce', nonce) // reuse the first nonce
    .set('x-signature', sigDer)
    .send({ manifest });
  assert.strictEqual(r3.status, 401);

  console.log('OK: Identity middleware tests passed.');
})().catch((e) => {
  console.error('identity tests failed:', e);
  process.exit(1);
});
```

9) Update file: package.json (add test script)
With content patch:
```json
{
  "scripts": {
    "test:identity": "ts-node test/integration/identity.spec.ts"
  }
}
```

Configuration
- IDENTITY_REQUIRED=true enables strict enforcement on protected routes.
- NONCE_TTL_SEC controls replay window (default 120 seconds).

What you completed (matches D19 DoD)
- Verifier middleware checks X-Identity-Key/X-Nonce/X-Signature; verifies secp256k1 ECDSA signature over sha256(JSON.stringify(body)+nonce).
- In-memory nonce store prevents replays in a TTL window.
- Protected producer actions require identity (POST /submit/dlm1, POST /price, POST/DELETE /price/rules). A /producers/register endpoint is provided for identity-bound profiles.
- Tests show:
  - Valid signature succeeds
  - Wrong key fails (401)
  - Replay (nonce reuse) fails (401)
- UI/SDK: The README note explains how to attach headers. If you already expose BRC100.withIdentityHeaders() in your SDK, use it to craft these headers client-side.

Next (optional)
- Persist nonces in Redis for multi-instance deployments.
- Add role-based policy (producer vs admin) per route using your producers table and identityKey mapping.
