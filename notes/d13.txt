
1) Create file: src/sdk/types.ts
With content:
```ts
export type SDKOptions = {
  baseUrl: string;          // e.g., http://localhost:8788
  headersUrl?: string;      // optional: URL to headers.json for client-side verifyBundle
  fetchImpl?: typeof fetch; // override for tests
  timeoutMs?: number;       // per-request timeout
};

export type ReadyResult = {
  ready: boolean;
  reason?: string | null;
  confirmations?: number;
};

export type PriceQuote = {
  versionId: string;
  contentHash: string | null;
  unitSatoshis: number;
  quantity: number;
  totalSatoshis: number;
  ruleSource: 'version-rule'|'version-override'|'producer-rule'|'default';
  tierFrom: number;
  expiresAt: number;
};

export type Receipt = {
  receiptId: string;
  versionId: string;
  contentHash: string | null;
  quantity: number;
  amountSat: number;
  status: 'pending'|'paid'|'consumed'|'expired';
  createdAt: number;
  expiresAt: number;
};

export type LineageBundle = {
  bundleType: 'datasetLineageBundle';
  target: string;
  graph: {
    nodes: { versionId: string; manifestHash: string; txo: string }[];
    edges: { child: string; parent: string }[];
  };
  manifests: { manifestHash: string; manifest: any }[];
  proofs: { versionId: string; envelope: any }[];
};

export type HeadersIndex = import('../spv/verify-envelope').HeadersIndex;
```

2) Create file: src/sdk/http.ts
With content:
```ts
export async function getJson(base: string, path: string, timeoutMs = 8000, f: typeof fetch = fetch): Promise<any> {
  const url = base.replace(/\/+$/,'') + path;
  const ctl = new AbortController();
  const tm = setTimeout(() => ctl.abort(), timeoutMs);
  try {
    const r = await f(url, { signal: ctl.signal as any, headers: { 'accept': 'application/json' } });
    if (!r.ok) throw new Error(`HTTP ${r.status} ${r.statusText}`);
    const ct = r.headers.get('content-type') || '';
    if (!ct.includes('application/json')) throw new Error(`unexpected content-type: ${ct}`);
    return await r.json();
  } finally {
    clearTimeout(tm);
  }
}

export async function postJson(base: string, path: string, body: any, timeoutMs = 8000, f: typeof fetch = fetch): Promise<any> {
  const url = base.replace(/\/+$/,'') + path;
  const ctl = new AbortController();
  const tm = setTimeout(() => ctl.abort(), timeoutMs);
  try {
    const r = await f(url, { method: 'POST', signal: ctl.signal as any, headers: { 'content-type': 'application/json', 'accept': 'application/json' }, body: JSON.stringify(body) });
    if (!r.ok) throw new Error(`HTTP ${r.status} ${r.statusText}`);
    return await r.json();
  } finally {
    clearTimeout(tm);
  }
}
```

3) Create file: src/sdk/verify.ts
With content:
```ts
import { verifyEnvelopeAgainstHeaders, loadHeaders, type HeadersIndex } from '../spv/verify-envelope';
import { LineageBundle } from './types';

export async function fetchHeaders(headersUrl: string, f: typeof fetch = fetch): Promise<HeadersIndex> {
  const res = await f(headersUrl);
  if (!res.ok) throw new Error(`headers fetch failed: ${res.status}`);
  const js = await res.json();
  // Reuse server-side loader to normalize into in-memory index
  // We write to a temp file not needed; instead emulate supported shapes:
  if (js.byHash || js.headers) {
    // Simple inliner: write to a temporary file is overkill; construct index similar to loadHeaders
    const byHash = new Map<string, { height: number; merkleRoot: string; hash: string; prevHash: string }>();
    const byHeight = new Map<number, { height: number; merkleRoot: string; hash: string; prevHash: string }>();
    const bestHeight = Number(js.bestHeight || 0);
    const tipHash = String(js.tipHash || '').toLowerCase();
    if (Array.isArray(js.headers)) {
      for (const h of js.headers) {
        const rec = { hash: String(h.hash).toLowerCase(), prevHash: String(h.prevHash||'').toLowerCase(), merkleRoot: String(h.merkleRoot).toLowerCase(), height: Number(h.height) };
        byHash.set(rec.hash, rec);
        byHeight.set(rec.height, rec);
      }
    } else if (js.byHash && typeof js.byHash === 'object') {
      for (const [k, v] of Object.entries<any>(js.byHash)) {
        const rec = { hash: String(k).toLowerCase(), prevHash: String(v.prevHash||'').toLowerCase(), merkleRoot: String(v.merkleRoot).toLowerCase(), height: Number(v.height) };
        byHash.set(rec.hash, rec);
        byHeight.set(rec.height, rec);
      }
    }
    return { bestHeight, tipHash, byHash, byHeight };
  }
  throw new Error('unsupported headers shape');
}

/**
 * Verify all SPV envelopes in a bundle against headers (from local headersUrl or provided index).
 * Returns { ok, results, minConfirmations }.
 */
export async function verifyBundleSPV(bundle: LineageBundle, opts: { headersUrl?: string; headersIdx?: HeadersIndex; minConfs?: number; fetchImpl?: typeof fetch }): Promise<{ ok: boolean; results: { versionId: string; ok: boolean; reason?: string; confirmations?: number }[]; minConfirmations?: number }> {
  const f = opts.fetchImpl || fetch;
  const minConfs = Number(opts.minConfs ?? 0);
  const idx = opts.headersIdx || (opts.headersUrl ? await fetchHeaders(opts.headersUrl, f) : null);
  if (!idx) throw new Error('headers required: provide headersUrl or headersIdx');

  const results: { versionId: string; ok: boolean; reason?: string; confirmations?: number }[] = [];
  let minC = Number.POSITIVE_INFINITY;

  for (const p of bundle.proofs) {
    const vr = await verifyEnvelopeAgainstHeaders(p.envelope as any, idx, minConfs);
    results.push({ versionId: p.versionId, ok: vr.ok, reason: vr.reason, confirmations: vr.confirmations });
    if (vr.ok && typeof vr.confirmations === 'number') minC = Math.min(minC, vr.confirmations);
  }

  const ok = results.every((r) => r.ok);
  return { ok, results, minConfirmations: isFinite(minC) ? minC : undefined };
}
```

4) Create file: src/sdk/index.ts
With content:
```ts
import { SDKOptions, ReadyResult, PriceQuote, Receipt, LineageBundle } from './types';
import { getJson, postJson } from './http';
import { verifyBundleSPV } from './verify';

export class GitdataSDK {
  private baseUrl: string;
  private headersUrl?: string;
  private f: typeof fetch;
  private timeoutMs: number;

  constructor(opts: SDKOptions) {
    this.baseUrl = opts.baseUrl.replace(/\/+$/,'');
    this.headersUrl = opts.headersUrl;
    this.f = opts.fetchImpl || fetch;
    this.timeoutMs = Number(opts.timeoutMs || 8000);
  }

  async ready(versionId: string): Promise<ReadyResult> {
    const path = `/ready?versionId=${encodeURIComponent(versionId)}`;
    return await getJson(this.baseUrl, path, this.timeoutMs, this.f);
  }

  async bundle(versionId: string): Promise<LineageBundle> {
    const path = `/bundle?versionId=${encodeURIComponent(versionId)}`;
    return await getJson(this.baseUrl, path, this.timeoutMs, this.f);
  }

  async verifyBundle(versionIdOrBundle: string | LineageBundle, minConfs = 0): Promise<{ ok: boolean; minConfirmations?: number; results: { versionId: string; ok: boolean; reason?: string; confirmations?: number }[] }> {
    const bundle = typeof versionIdOrBundle === 'string' ? await this.bundle(versionIdOrBundle) : versionIdOrBundle;
    const { ok, results, minConfirmations } = await verifyBundleSPV(bundle, { headersUrl: this.headersUrl, minConfs, fetchImpl: this.f });
    return { ok, minConfirmations, results };
  }

  async price(versionId: string, quantity = 1): Promise<PriceQuote> {
    const q = `/price?versionId=${encodeURIComponent(versionId)}&quantity=${encodeURIComponent(String(quantity))}`;
    return await getJson(this.baseUrl, q, this.timeoutMs, this.f);
  }

  async pay(versionId: string, quantity = 1): Promise<Receipt> {
    return await postJson(this.baseUrl, `/pay`, { versionId, quantity }, this.timeoutMs, this.f);
  }

  /**
   * streamData: returns a Uint8Array of content bytes (MVP).
   * In production, you may prefer to receive a presigned URL and fetch directly from CDN/storage.
   */
  async streamData(contentHash: string, receiptId: string): Promise<Uint8Array> {
    const url = `${this.baseUrl}/v1/data?contentHash=${encodeURIComponent(contentHash)}&receiptId=${encodeURIComponent(receiptId)}`;
    const ctl = new AbortController();
    const tm = setTimeout(() => ctl.abort(), this.timeoutMs);
    try {
      const r = await this.f(url, { signal: ctl.signal as any });
      if (!r.ok) throw new Error(`HTTP ${r.status} ${r.statusText}`);
      const buf = new Uint8Array(await r.arrayBuffer());
      return buf;
    } finally {
      clearTimeout(tm);
    }
  }
}
```

5) Create file: README-SDK.md
With content:
```md
# Gitdata SDK (JS/TS, Minimal)

Install (local project):
- This SDK lives in `src/sdk`. Import via relative path or publish a local npm package as needed.

Usage

```ts
import { GitdataSDK } from './src/sdk';

const sdk = new GitdataSDK({
  baseUrl: 'http://localhost:8788',
  headersUrl: 'http://localhost:8788/data/headers.json' // or another mirror URL
});

(async () => {
  const versionId = '<64-hex>';

  // Ready gate
  const r = await sdk.ready(versionId);
  console.log('ready?', r.ready, 'reason:', r.reason);

  // Bundle + SPV verify (no indexer required)
  const v = await sdk.verifyBundle(versionId, 1);
  console.log('bundle SPV ok?', v.ok, 'minConfs:', v.minConfirmations);

  // Price & Pay
  const quote = await sdk.price(versionId, 2);
  console.log('quote total', quote.totalSatoshis);

  const receipt = await sdk.pay(versionId, 2);
  console.log('receipt id', receipt.receiptId);

  // Download/stream
  const bytes = await sdk.streamData(quote.contentHash!, receipt.receiptId);
  console.log('downloaded bytes:', bytes.length);
})();
```

API
- ready(versionId): GET /ready
- verifyBundle(versionId | bundle, minConfs?): Fetch or take provided bundle and verify SPV envelopes against headers (headersUrl or headersIdx required).
- price(versionId, quantity?): GET /price?versionId=&quantity=
- pay(versionId, quantity?): POST /pay
- streamData(contentHash, receiptId): GET /v1/data

Notes
- Headers mirror URL should serve the JSON your overlay writes (see scripts/headers-mirror.ts).
- This SDK verifies bundle proofs using SPV (no indexer). For browsers, ensure a CORS-enabled headersUrl.
- For large downloads, prefer presigned URLs and streaming.
```

6) Create file: examples/sdk-quickstart.ts
With content:
```ts
import { GitdataSDK } from '../src/sdk';
import crypto from 'crypto';

async function main() {
  const baseUrl = process.env.OVERLAY_URL || 'http://localhost:8788';
  const headersUrl = process.env.HEADERS_URL || (baseUrl + '/data/headers.json');
  const versionId = process.env.VERSION_ID || 'a'.repeat(64);

  const sdk = new GitdataSDK({ baseUrl, headersUrl, timeoutMs: 8000 });

  // 10-line quickstart
  const ready = await sdk.ready(versionId);
  console.log('ready?', ready.ready, ready.reason || '');

  const price = await sdk.price(versionId, 1);
  console.log('unit=', price.unitSatoshis, 'total=', price.totalSatoshis);

  const spv = await sdk.verifyBundle(versionId, 1);
  console.log('bundle-ok?', spv.ok, 'minConfs=', spv.minConfirmations || 0);

  // Only attempt data if content is expected and free (for demo)
  if (price.contentHash) {
    const receipt = await sdk.pay(versionId, 1);
    const bytes = await sdk.streamData(price.contentHash, receipt.receiptId);
    const digest = crypto.createHash('sha256').update(Buffer.from(bytes)).digest('hex');
    console.log('bytes=', bytes.length, 'sha256=', digest);
  }
}

main().catch((e) => { console.error('sdk quickstart failed:', e); process.exit(1); });
```

7) Update file: package.json (add SDK build/test scripts)
With content patch:
```json
{
  "scripts": {
    "sdk:quickstart": "ts-node examples/sdk-quickstart.ts"
  }
}
```

What you’ve completed (matches D13 DoD)
- SDK functions: ready(), verifyBundle(), price(), pay(), streamData().
- SPV verification is done client-side with your existing verify-envelope logic and a headersUrl (indexer-free).
- README-SDK.md shows a 10-line example that runs end-to-end (ready → price → verify → pay → stream).
- Types included for results (ReadyResult, PriceQuote, Receipt, LineageBundle, HeadersIndex).

Notes
- If you publish as a package, add a new package.json under a packages/sdk folder with proper exports/types and bump SemVer for future API changes.
- For browser usage, ensure the overlay enables CORS for /bundle, /ready, /price, /pay, /v1/data, and your headers mirror URL.
