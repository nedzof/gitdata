var bt=Object.defineProperty;var kt=(v,t,i)=>t in v?bt(v,t,{enumerable:!0,configurable:!0,writable:!0,value:i}):v[t]=i;var f=(v,t,i)=>kt(v,typeof t!="symbol"?t+"":t,i);import{C as W,B as A,t as at,f as ot,a as Nt,s as U,b as ft,v as pt,P as Q,c as St,d as u,e as G,g as At,A as Vt,h as ct,i as Ct,j as Kt,S as mt,k as T,W as et,l as I,R as D,m as k,n as g,o as It,p as Dt}from"./Cdn01nKd.js";class xt{constructor(){f(this,"_rand");var i;const t=()=>{throw new Error("No secure random number generator is available in this environment.")};if(this._rand=t,typeof self=="object")(i=self.crypto)!=null&&i.getRandomValues?this._rand=e=>{const n=new Uint8Array(e);return self.crypto.getRandomValues(n),[...n]}:this._rand=t;else try{const e=require("crypto");typeof e.randomBytes=="function"&&(this._rand=n=>[...e.randomBytes(n)])}catch{this._rand=t}}generate(t){return this._rand(t)}}let tt=null;const P=v=>(tt==null&&(tt=new xt),tt.generate(v));class H{constructor(t,i){f(this,"x");f(this,"y");const e=new W().p;this.x=t.umod(e),this.y=i.umod(e)}toString(){return at(this.x.toArray())+"."+at(this.y.toArray())}static fromString(t){const[i,e]=t.split(".");return new H(new A(ot(i)),new A(ot(e)))}}class J{constructor(t,i){f(this,"points");f(this,"threshold");this.points=t,this.threshold=i??t.length}static fromPrivateKey(t,i){const e=new W().p,n=[new H(new A(0),new A(t.toArray()))];for(let s=1;s<i;s++){const r=new A(P(32)).umod(e),o=new A(P(32)).umod(e);n.push(new H(r,o))}return new J(n)}valueAt(t){const i=new W().p;let e=new A(0);for(let n=0;n<this.threshold;n++){let s=this.points[n].y;for(let r=0;r<this.threshold;r++)if(n!==r){const o=this.points[r].x,a=this.points[n].x,c=t.sub(o).umod(i),d=a.sub(o).umod(i).invm(i),w=c.mul(d).umod(i);s=s.mul(w).umod(i)}e=e.add(s).umod(i)}return e}}class _{constructor(t,i,e){f(this,"points");f(this,"threshold");f(this,"integrity");this.points=t,this.threshold=i,this.integrity=e}static fromBackupFormat(t){let i=0,e="";const n=t.map((s,r)=>{const o=s.split(".");if(o.length!==4)throw new Error("Invalid share format in share "+r.toString()+'. Expected format: "x.y.t.i" - received '+s);const[a,c,h,d]=o;if(h===void 0)throw new Error("Threshold not found in share "+r.toString());if(d===void 0)throw new Error("Integrity not found in share "+r.toString());const w=parseInt(h);if(r!==0&&i!==w)throw new Error("Threshold mismatch in share "+r.toString());if(r!==0&&e!==d)throw new Error("Integrity mismatch in share "+r.toString());return i=w,e=d,H.fromString([a,c].join("."))});return new _(n,i,e)}toBackupFormat(){return this.points.map(t=>t.toString()+"."+this.threshold.toString()+"."+this.integrity)}}class K extends A{static fromRandom(){return new K(P(32))}static fromString(t,i="hex"){return new K(super.fromString(t,i).toArray())}static fromHex(t){return new K(super.fromHex(t,"big"))}static fromWif(t,i=1){const e=Nt(t,void 0,i);if(e.data.length!==33)throw new Error("Invalid WIF length");if(e.data[32]!==1)throw new Error("Invalid WIF padding");return new K(e.data.slice(0,32))}constructor(t=0,i=10,e="be",n="apply"){if(t instanceof A?(super(),t.copy(this)):super(t,i,e),n!=="nocheck"){const s=this.checkInField();if(!s.inField){if(n==="error")throw new Error("Input is out of field");A.move(this,s.modN)}}}checkInField(){const t=new W,i=this.mod(t.n);return{inField:this.cmp(i)===0,modN:i}}isValid(){return this.checkInField().inField}sign(t,i,e=!0,n){const s=new A(U(t,i),16);return ft(s,this,e,n)}verify(t,i,e){const n=new A(U(t,e),16);return pt(n,i,this.toPublicKey())}toPublicKey(){const i=new W().g.mul(this);return new Q(i.x,i.y)}toWif(t=[128]){if(!this.isValid())throw new Error("Value is out of field");return St([...this.toArray("be",32),1],t)}toAddress(t=[0]){return this.toPublicKey().toAddress(t)}toHex(){return super.toHex(32)}toString(t="hex",i=64){return super.toString(t,i)}deriveSharedSecret(t){if(!t.validate())throw new Error("Public key not valid for ECDH secret derivation");return t.mul(this)}deriveChild(t,i,e,n){let s;if(typeof n=="function"){const c=n(this,t);typeof c<"u"?s=c:(s=this.deriveSharedSecret(t),typeof e=="function"&&e(this,t,s))}else s=this.deriveSharedSecret(t);const r=u(i,"utf8"),o=G(s.encode(!0),r),a=new W;return new K(this.add(new A(o)).mod(a.n).toArray())}toKeyShares(t,i){if(typeof t!="number"||typeof i!="number")throw new Error("threshold and totalShares must be numbers");if(t<2)throw new Error("threshold must be at least 2");if(i<2)throw new Error("totalShares must be at least 2");if(t>i)throw new Error("threshold should be less than or equal to totalShares");const e=J.fromPrivateKey(this,t),n=[],s=new Set,r=new W,o=P(64);for(let c=0;c<i;c++){let h,d=0;do{const l=[c,d,...P(32)],y=At(o,l);if(h=new A(y).umod(r.p),d++,d>5)throw new Error("Failed to generate unique x coordinate after 5 attempts")}while(h.isZero()||s.has(h.toString()));s.add(h.toString());const w=e.valueAt(h);n.push(new H(h,w))}const a=this.toPublicKey().toHash("hex").slice(0,8);return new _(n,t,a)}toBackupShares(t,i){return this.toKeyShares(t,i).toBackupFormat()}static fromBackupShares(t){return K.fromKeyShares(_.fromBackupFormat(t))}static fromKeyShares(t){const{points:i,threshold:e,integrity:n}=t;if(e<2)throw new Error("threshold must be at least 2");if(i.length<e)throw new Error(`At least ${e} shares are required to reconstruct the private key`);for(let a=0;a<e;a++)for(let c=a+1;c<e;c++)if(i[a].x.eq(i[c].x))throw new Error("Duplicate share detected, each must be unique.");const s=new J(i,e),r=new K(s.valueAt(new A(0)).toArray());if(r.toPublicKey().toHash("hex").slice(0,8)!==n)throw new Error("Integrity hash mismatch");return r}}class it extends A{static fromRandom(){return new it(P(32))}encrypt(t,i){const e=P(32);t=u(t,i);const{result:n,authenticationTag:s}=Vt(t,[],e,this.toArray("be",32));return ct([...e,...n,...s],i)}decrypt(t,i){t=u(t,i);const e=t.slice(0,32),n=t.slice(32),s=n.slice(-16),r=n.slice(0,-16),o=Ct(r,[],e,s,this.toArray());if(o===null)throw new Error("Decryption failed!");return ct(o,i)}}class Pt{constructor(){f(this,"curve");this.curve=new W}generateProof(t,i,e,n){const s=K.fromRandom(),r=s.toPublicKey(),o=e.mul(s),a=this.computeChallenge(i,e,n,o,r),c=s.add(a.mul(t)).umod(this.curve.n);return{R:r,SPrime:o,z:c}}verifyProof(t,i,e,n){const{R:s,SPrime:r,z:o}=n,a=this.computeChallenge(t,i,e,r,s),c=this.curve.g.mul(o),h=s.add(t.mul(a));if(!c.eq(h))return!1;const d=i.mul(o),w=r.add(e.mul(a));return!!d.eq(w)}computeChallenge(t,i,e,n,s){const r=[...t.encode(!0),...i.encode(!0),...e.encode(!0),...n.encode(!0),...s.encode(!0)],o=U(r);return new A(o).umod(this.curve.n)}}class Bt{constructor(t,i,e){f(this,"cacheSharedSecret");f(this,"retrieveCachedSharedSecret");f(this,"rootKey");f(this,"identityKey");f(this,"anyone");this.cacheSharedSecret=i,this.retrieveCachedSharedSecret=e,this.anyone=new K(1).toPublicKey(),t==="anyone"?this.rootKey=new K(1):this.rootKey=t,this.identityKey=this.rootKey.toPublicKey().toString()}derivePublicKey(t,i,e,n=!1){return e=this.normalizeCounterparty(e),n?this.rootKey.deriveChild(e,this.computeInvoiceNumber(t,i),this.cacheSharedSecret,this.retrieveCachedSharedSecret).toPublicKey():e.deriveChild(this.rootKey,this.computeInvoiceNumber(t,i),this.cacheSharedSecret,this.retrieveCachedSharedSecret)}derivePrivateKey(t,i,e){return e=this.normalizeCounterparty(e),this.rootKey.deriveChild(e,this.computeInvoiceNumber(t,i),this.cacheSharedSecret,this.retrieveCachedSharedSecret)}deriveSymmetricKey(t,i,e){var r,o;e==="anyone"?e=this.anyone:e=this.normalizeCounterparty(e);const n=this.derivePublicKey(t,i,e),s=this.derivePrivateKey(t,i,e);return new it(((o=(r=s.deriveSharedSecret(n))==null?void 0:r.x)==null?void 0:o.toArray())??[])}revealCounterpartySecret(t){if(t==="self")throw new Error("Counterparty secrets cannot be revealed for counterparty=self.");t=this.normalizeCounterparty(t);const i=this.rootKey.toPublicKey(),e=this.rootKey.deriveChild(i,"test").toHex(),n=this.rootKey.deriveChild(t,"test").toHex();if(e===n)throw new Error("Counterparty secrets cannot be revealed for counterparty=self.");return this.rootKey.deriveSharedSecret(t).encode(!0)}revealSpecificSecret(t,i,e){t=this.normalizeCounterparty(t);const n=this.rootKey.deriveSharedSecret(t),s=u(this.computeInvoiceNumber(i,e),"utf8");return G(n.encode(!0),s)}normalizeCounterparty(t){if(t==null)throw new Error("counterparty must be self, anyone or a public key!");return t==="self"?this.rootKey.toPublicKey():t==="anyone"?new K(1).toPublicKey():typeof t=="string"?Q.fromString(t):t}computeInvoiceNumber(t,i){const e=t[0];if(!Number.isInteger(e)||e<0||e>2)throw new Error("Protocol security level must be 0, 1, or 2");const n=t[1].toLowerCase().trim();if(i.length>800)throw new Error("Key IDs must be 800 characters or less");if(i.length<1)throw new Error("Key IDs must be 1 character or more");if(n.length>400)if(n.startsWith("specific linkage revelation ")){if(n.length>430)throw new Error("Specific linkage revelation protocol names must be 430 characters or less")}else throw new Error("Protocol names must be 400 characters or less");if(n.length<5)throw new Error("Protocol names must be 5 characters or more");if(n.includes("  "))throw new Error('Protocol names cannot contain multiple consecutive spaces ("  ")');if(!/^[a-z0-9 ]+$/g.test(n))throw new Error("Protocol names can only contain letters, numbers and spaces");if(n.endsWith(" protocol"))throw new Error('No need to end your protocol name with " protocol"');return`${e}-${n}-${i}`}}class Lt{constructor(t,i){f(this,"keyDeriver");f(this,"cache");f(this,"maxCacheSize");f(this,"rootKey");f(this,"identityKey");t==="anyone"?this.rootKey=new K(1):this.rootKey=t,this.keyDeriver=new Bt(this.rootKey,(n,s,r)=>{this.cacheSet(`${n.toString()}-${s.toString()}`,r)},(n,s)=>this.cacheGet(`${n.toString()}-${s.toString()}`)),this.identityKey=this.rootKey.toPublicKey().toString(),this.cache=new Map;const e=i==null?void 0:i.maxCacheSize;this.maxCacheSize=e!=null&&!isNaN(e)&&e>0?e:1e3}derivePublicKey(t,i,e,n=!1){const s=this.generateCacheKey("derivePublicKey",t,i,e,n);if(this.cache.has(s)){const r=this.cacheGet(s);if(r===void 0)throw new Error("Cached value is undefined");return r}else{const r=this.keyDeriver.derivePublicKey(t,i,e,n);return this.cacheSet(s,r),r}}derivePrivateKey(t,i,e){const n=this.generateCacheKey("derivePrivateKey",t,i,e);if(this.cache.has(n)){const s=this.cacheGet(n);if(s===void 0)throw new Error("Cached value is undefined");return s}else{const s=this.keyDeriver.derivePrivateKey(t,i,e);return this.cacheSet(n,s),s}}deriveSymmetricKey(t,i,e){const n=this.generateCacheKey("deriveSymmetricKey",t,i,e);if(this.cache.has(n)){const s=this.cacheGet(n);if(s===void 0)throw new Error("Cached value is undefined");return s}else{const s=this.keyDeriver.deriveSymmetricKey(t,i,e);return this.cacheSet(n,s),s}}revealCounterpartySecret(t){const i=this.generateCacheKey("revealCounterpartySecret",t);if(this.cache.has(i)){const e=this.cacheGet(i);if(e===void 0)throw new Error("Cached value is undefined");return e}else{const e=this.keyDeriver.revealCounterpartySecret(t);return this.cacheSet(i,e),e}}revealSpecificSecret(t,i,e){const n=this.generateCacheKey("revealSpecificSecret",t,i,e);if(this.cache.has(n)){const s=this.cacheGet(n);if(s===void 0)throw new Error("Cached value is undefined");return s}else{const s=this.keyDeriver.revealSpecificSecret(t,i,e);return this.cacheSet(n,s),s}}generateCacheKey(t,...i){const e=i.map(n=>this.serializeArgument(n)).join("|");return`${t}|${e}`}serializeArgument(t){return t instanceof Q||t instanceof K?t.toString():Array.isArray(t)?t.map(i=>this.serializeArgument(i)).join(","):typeof t=="object"&&t!==null?JSON.stringify(t):String(t)}cacheGet(t){const i=this.cache.get(t);return this.cache.delete(t),i!==void 0&&this.cache.set(t,i),i}cacheSet(t,i){if(this.cache.size>=this.maxCacheSize){const e=this.cache.keys().next().value;this.cache.delete(e)}this.cache.set(t,i)}}class Wt{constructor(t){f(this,"keyDeriver");typeof t.identityKey!="string"&&(t=new Lt(t)),this.keyDeriver=t}async getPublicKey(t){if(t.identityKey){if(this.keyDeriver==null)throw new Error("keyDeriver is undefined");return{publicKey:this.keyDeriver.rootKey.toPublicKey().toString()}}else{if(t.protocolID==null||t.keyID==null||t.keyID==="")throw new Error("protocolID and keyID are required if identityKey is false or undefined.");return{publicKey:(this.keyDeriver??(()=>{throw new Error("keyDeriver is undefined")})()).derivePublicKey(t.protocolID,t.keyID,t.counterparty??"self",t.forSelf).toString()}}}async revealCounterpartyKeyLinkage(t){const{publicKey:i}=await this.getPublicKey({identityKey:!0});if(this.keyDeriver==null)throw new Error("keyDeriver is undefined");const e=this.keyDeriver.revealCounterpartySecret(t.counterparty),n=new Pt().generateProof(this.keyDeriver.rootKey,this.keyDeriver.rootKey.toPublicKey(),Q.fromString(t.counterparty),Kt.fromDER(e)),s=[...n.R.encode(!0),...n.SPrime.encode(!0),...n.z.toArray()],r=new Date().toISOString(),{ciphertext:o}=await this.encrypt({plaintext:e,protocolID:[2,"counterparty linkage revelation"],keyID:r,counterparty:t.verifier}),{ciphertext:a}=await this.encrypt({plaintext:s,protocolID:[2,"counterparty linkage revelation"],keyID:r,counterparty:t.verifier});return{prover:i,verifier:t.verifier,counterparty:t.counterparty,revelationTime:r,encryptedLinkage:o,encryptedLinkageProof:a}}async revealSpecificKeyLinkage(t){const{publicKey:i}=await this.getPublicKey({identityKey:!0});if(this.keyDeriver==null)throw new Error("keyDeriver is undefined");const e=this.keyDeriver.revealSpecificSecret(t.counterparty,t.protocolID,t.keyID),{ciphertext:n}=await this.encrypt({plaintext:e,protocolID:[2,`specific linkage revelation ${t.protocolID[0]} ${t.protocolID[1]}`],keyID:t.keyID,counterparty:t.verifier}),{ciphertext:s}=await this.encrypt({plaintext:[0],protocolID:[2,`specific linkage revelation ${t.protocolID[0]} ${t.protocolID[1]}`],keyID:t.keyID,counterparty:t.verifier});return{prover:i,verifier:t.verifier,counterparty:t.counterparty,protocolID:t.protocolID,keyID:t.keyID,encryptedLinkage:n,encryptedLinkageProof:s,proofType:0}}async encrypt(t){if(this.keyDeriver==null)throw new Error("keyDeriver is undefined");return{ciphertext:this.keyDeriver.deriveSymmetricKey(t.protocolID,t.keyID,t.counterparty??"self").encrypt(t.plaintext)}}async decrypt(t,i){if(this.keyDeriver==null)throw new Error("keyDeriver is undefined");return{plaintext:this.keyDeriver.deriveSymmetricKey(t.protocolID,t.keyID,t.counterparty??"self").decrypt(t.ciphertext)}}async createHmac(t){if(this.keyDeriver==null)throw new Error("keyDeriver is undefined");const i=this.keyDeriver.deriveSymmetricKey(t.protocolID,t.keyID,t.counterparty??"self");return{hmac:G(i.toArray(),t.data)}}async verifyHmac(t){if(this.keyDeriver==null)throw new Error("keyDeriver is undefined");const i=this.keyDeriver.deriveSymmetricKey(t.protocolID,t.keyID,t.counterparty??"self"),e=G(i.toArray(),t.data).toString()===t.hmac.toString();if(!e){const n=new Error("HMAC is not valid");throw n.code="ERR_INVALID_HMAC",n}return{valid:e}}async createSignature(t){if(t.hashToDirectlySign==null&&t.data==null)throw new Error("args.data or args.hashToDirectlySign must be valid");const i=t.hashToDirectlySign??U(t.data??[]),n=(this.keyDeriver??(()=>{throw new Error("keyDeriver is undefined")})()).derivePrivateKey(t.protocolID,t.keyID,t.counterparty??"anyone");return{signature:ft(new A(i),n,!0).toDER()}}async verifySignature(t){if(t.hashToDirectlyVerify==null&&t.data==null)throw new Error("args.data or args.hashToDirectlyVerify must be valid");const i=t.hashToDirectlyVerify??U(t.data??[]),n=(this.keyDeriver??(()=>{throw new Error("keyDeriver is undefined")})()).derivePublicKey(t.protocolID,t.keyID,t.counterparty??"self",t.forSelf),s=pt(new A(i),mt.fromDER(t.signature),n);if(!s){const r=new Error("Signature is not valid");throw r.code="ERR_INVALID_SIGNATURE",r}return{valid:s}}}class ut{constructor(){f(this,"CWI");if(typeof window!="object")throw new Error("The window.CWI substrate requires a global window object.");if(typeof window.CWI!="object")throw new Error("The window.CWI interface does not appear to be bound to the window object.");this.CWI=window.CWI}async createAction(t,i){return await this.CWI.createAction(t,i)}async signAction(t,i){return await this.CWI.signAction(t,i)}async abortAction(t,i){return await this.CWI.abortAction(t,i)}async listActions(t,i){return await this.CWI.listActions(t,i)}async internalizeAction(t,i){return await this.CWI.internalizeAction(t,i)}async listOutputs(t,i){return await this.CWI.listOutputs(t,i)}async relinquishOutput(t,i){return await this.CWI.relinquishOutput(t,i)}async getPublicKey(t,i){return await this.CWI.getPublicKey(t,i)}async revealCounterpartyKeyLinkage(t,i){return await this.CWI.revealCounterpartyKeyLinkage(t,i)}async revealSpecificKeyLinkage(t,i){return await this.CWI.revealSpecificKeyLinkage(t,i)}async encrypt(t,i){return await this.CWI.encrypt(t,i)}async decrypt(t,i){return await this.CWI.decrypt(t,i)}async createHmac(t,i){return await this.CWI.createHmac(t,i)}async verifyHmac(t,i){return await this.CWI.verifyHmac(t,i)}async createSignature(t,i){return await this.CWI.createSignature(t,i)}async verifySignature(t,i){return await this.CWI.verifySignature(t,i)}async acquireCertificate(t,i){return await this.CWI.acquireCertificate(t,i)}async listCertificates(t,i){return await this.CWI.listCertificates(t,i)}async proveCertificate(t,i){return await this.CWI.proveCertificate(t,i)}async relinquishCertificate(t,i){return await this.CWI.relinquishCertificate(t,i)}async discoverByIdentityKey(t,i){return await this.CWI.discoverByIdentityKey(t,i)}async discoverByAttributes(t,i){return await this.CWI.discoverByAttributes(t,i)}async isAuthenticated(t,i){return await this.CWI.isAuthenticated(t,i)}async waitForAuthentication(t,i){return await this.CWI.waitForAuthentication(t,i)}async getHeight(t,i){return await this.CWI.getHeight(t,i)}async getHeaderForHeight(t,i){return await this.CWI.getHeaderForHeight(t,i)}async getNetwork(t,i){return await this.CWI.getNetwork(t,i)}async getVersion(t,i){return await this.CWI.getVersion(t,i)}}class lt{constructor(t="*"){f(this,"domain");if(typeof window!="object")throw new Error("The XDM substrate requires a global window object.");if(typeof window.postMessage!="function")throw new Error("The window object does not seem to support postMessage calls.");this.domain=t}async invoke(t,i){return await new Promise((e,n)=>{const s=T(P(12)),r=o=>{if(!(o.data.type!=="CWI"||!o.isTrusted||o.data.id!==s||o.data.isInvocation===!0))if(typeof window.removeEventListener=="function"&&window.removeEventListener("message",r),o.data.status==="error"){const a=new et(o.data.description,o.data.code);n(a)}else e(o.data.result)};window.addEventListener("message",r),window.parent.postMessage({type:"CWI",isInvocation:!0,id:s,call:t,args:i},this.domain)})}async createAction(t){return await this.invoke("createAction",t)}async signAction(t){return await this.invoke("signAction",t)}async abortAction(t){return await this.invoke("abortAction",t)}async listActions(t){return await this.invoke("listActions",t)}async internalizeAction(t){return await this.invoke("internalizeAction",t)}async listOutputs(t){return await this.invoke("listOutputs",t)}async relinquishOutput(t){return await this.invoke("relinquishOutput",t)}async getPublicKey(t){return await this.invoke("getPublicKey",t)}async revealCounterpartyKeyLinkage(t){return await this.invoke("revealCounterpartyKeyLinkage",t)}async revealSpecificKeyLinkage(t){return await this.invoke("revealSpecificKeyLinkage",t)}async encrypt(t){return await this.invoke("encrypt",t)}async decrypt(t){return await this.invoke("decrypt",t)}async createHmac(t){return await this.invoke("createHmac",t)}async verifyHmac(t){return await this.invoke("verifyHmac",t)}async createSignature(t){return await this.invoke("createSignature",t)}async verifySignature(t){return await this.invoke("verifySignature",t)}async acquireCertificate(t){return await this.invoke("acquireCertificate",t)}async listCertificates(t){return await this.invoke("listCertificates",t)}async proveCertificate(t){return await this.invoke("proveCertificate",t)}async relinquishCertificate(t){return await this.invoke("relinquishCertificate",t)}async discoverByIdentityKey(t){return await this.invoke("discoverByIdentityKey",t)}async discoverByAttributes(t){return await this.invoke("discoverByAttributes",t)}async isAuthenticated(t){return await this.invoke("isAuthenticated",t)}async waitForAuthentication(t){return await this.invoke("waitForAuthentication",t)}async getHeight(t){return await this.invoke("getHeight",t)}async getHeaderForHeight(t){return await this.invoke("getHeaderForHeight",t)}async getNetwork(t){return await this.invoke("getNetwork",t)}async getVersion(t){return await this.invoke("getVersion",t)}}class j{constructor(t,i,e,n,s,r,o){f(this,"type");f(this,"serialNumber");f(this,"subject");f(this,"certifier");f(this,"revocationOutpoint");f(this,"fields");f(this,"signature");this.type=t,this.serialNumber=i,this.subject=e,this.certifier=n,this.revocationOutpoint=s,this.fields=r,this.signature=o}toBinary(t=!0){const i=new I,e=u(this.type,"base64");i.write(e);const n=u(this.serialNumber,"base64");i.write(n);const s=u(this.subject,"hex");i.write(s);const r=u(this.certifier,"hex");i.write(r);const[o,a]=this.revocationOutpoint.split("."),c=u(o,"hex");i.write(c),i.writeVarIntNum(Number(a));const h=Object.keys(this.fields).sort();i.writeVarIntNum(h.length);for(const d of h){const w=this.fields[d],l=u(d,"utf8");i.writeVarIntNum(l.length),i.write(l);const y=u(w,"utf8");i.writeVarIntNum(y.length),i.write(y)}if(t&&(this.signature??"").length>0){const d=u(this.signature,"hex");i.write(d)}return i.toArray()}static fromBinary(t){const i=new D(t),e=i.read(32),n=T(e),s=i.read(32),r=T(s),o=i.read(33),a=k(o),c=i.read(33),h=k(c),d=i.read(32),w=k(d),l=i.readVarIntNum(),y=`${w}.${l}`,m=i.readVarIntNum(),p={};for(let S=0;S<m;S++){const N=i.readVarIntNum(),V=i.read(N),x=g(V),B=i.readVarIntNum(),C=i.read(B),E=g(C);p[x]=E}let b;if(!i.eof()){const S=i.read();b=mt.fromDER(S).toString("hex")}return new j(n,r,a,h,y,p,b)}async verify(){const t=new Wt("anyone"),i=this.toBinary(!1),e=this.signature??"",{valid:n}=await t.verifySignature({signature:u(e,"hex"),data:i,protocolID:[2,"certificate signature"],keyID:`${this.type} ${this.serialNumber}`,counterparty:this.certifier});return n}async sign(t){if(this.signature!=null&&this.signature.length>0)throw new Error(`Certificate has already been signed! Signature present: ${this.signature}`);this.certifier=(await t.getPublicKey({identityKey:!0})).publicKey;const i=this.toBinary(!1),{signature:e}=await t.createSignature({data:i,protocolID:[2,"certificate signature"],keyID:`${this.type} ${this.serialNumber}`});this.signature=k(e)}static getCertificateFieldEncryptionDetails(t,i){return{protocolID:[2,"certificate field encryption"],keyID:i?`${i} ${t}`:t}}}class ht{constructor(t){f(this,"wire");this.wire=t}async transmit(t,i="",e=[]){const n=new I;n.writeUInt8(It[t]);const s=u(i,"utf8");n.writeUInt8(s.length),n.write(s),e.length>0&&n.write(e);const r=n.toArray(),o=await this.wire.transmitToWallet(r),a=new D(o),c=a.readUInt8();if(c===0)return a.read();{const h=a.readVarIntNum(),d=a.read(h),w=g(d),l=a.readVarIntNum(),y=a.read(l),m=g(y);throw new et(w,c,m)}}async createAction(t,i){const e=new I,n=u(t.description,"utf8");if(e.writeVarIntNum(n.length),e.write(n),t.inputBEEF!=null?(e.writeVarIntNum(t.inputBEEF.length),e.write(t.inputBEEF)):e.writeVarIntNum(-1),t.inputs!=null){e.writeVarIntNum(t.inputs.length);for(const l of t.inputs){if(e.write(this.encodeOutpoint(l.outpoint)),l.unlockingScript!=null&&l.unlockingScript!==""){const m=u(l.unlockingScript,"hex");e.writeVarIntNum(m.length),e.write(m)}else e.writeVarIntNum(-1),e.writeVarIntNum(l.unlockingScriptLength??0);const y=u(l.inputDescription,"utf8");e.writeVarIntNum(y.length),e.write(y),typeof l.sequenceNumber=="number"?e.writeVarIntNum(l.sequenceNumber):e.writeVarIntNum(-1)}}else e.writeVarIntNum(-1);if(t.outputs!=null){e.writeVarIntNum(t.outputs.length);for(const l of t.outputs){const y=u(l.lockingScript,"hex");e.writeVarIntNum(y.length),e.write(y),e.writeVarIntNum(l.satoshis);const m=u(l.outputDescription,"utf8");if(e.writeVarIntNum(m.length),e.write(m),l.basket!=null&&l.basket!==""){const p=u(l.basket,"utf8");e.writeVarIntNum(p.length),e.write(p)}else e.writeVarIntNum(-1);if(l.customInstructions!=null&&l.customInstructions!==""){const p=u(l.customInstructions,"utf8");e.writeVarIntNum(p.length),e.write(p)}else e.writeVarIntNum(-1);if(l.tags!=null){e.writeVarIntNum(l.tags.length);for(const p of l.tags){const b=u(p,"utf8");e.writeVarIntNum(b.length),e.write(b)}}else e.writeVarIntNum(-1)}}else e.writeVarIntNum(-1);if(typeof t.lockTime=="number"?e.writeVarIntNum(t.lockTime):e.writeVarIntNum(-1),typeof t.version=="number"?e.writeVarIntNum(t.version):e.writeVarIntNum(-1),t.labels!=null){e.writeVarIntNum(t.labels.length);for(const l of t.labels){const y=u(l,"utf8");e.writeVarIntNum(y.length),e.write(y)}}else e.writeVarIntNum(-1);if(t.options!=null){if(e.writeInt8(1),typeof t.options.signAndProcess=="boolean"?e.writeInt8(t.options.signAndProcess?1:0):e.writeInt8(-1),typeof t.options.acceptDelayedBroadcast=="boolean"?e.writeInt8(t.options.acceptDelayedBroadcast?1:0):e.writeInt8(-1),t.options.trustSelf==="known"?e.writeInt8(1):e.writeInt8(-1),t.options.knownTxids!=null){e.writeVarIntNum(t.options.knownTxids.length);for(const l of t.options.knownTxids){const y=u(l,"hex");e.write(y)}}else e.writeVarIntNum(-1);if(typeof t.options.returnTXIDOnly=="boolean"?e.writeInt8(t.options.returnTXIDOnly?1:0):e.writeInt8(-1),typeof t.options.noSend=="boolean"?e.writeInt8(t.options.noSend?1:0):e.writeInt8(-1),t.options.noSendChange!=null){e.writeVarIntNum(t.options.noSendChange.length);for(const l of t.options.noSendChange)e.write(this.encodeOutpoint(l))}else e.writeVarIntNum(-1);if(t.options.sendWith!=null){e.writeVarIntNum(t.options.sendWith.length);for(const l of t.options.sendWith){const y=u(l,"hex");e.write(y)}}else e.writeVarIntNum(-1);typeof t.options.randomizeOutputs=="boolean"?e.writeInt8(t.options.randomizeOutputs?1:0):e.writeInt8(-1)}else e.writeInt8(0);const s=await this.transmit("createAction",i,e.toArray()),r=new D(s),o={};if(r.readInt8()===1){const l=r.read(32);o.txid=k(l)}if(r.readInt8()===1){const l=r.readVarIntNum();o.tx=r.read(l)}const h=r.readVarIntNum();if(h>=0){o.noSendChange=[];for(let l=0;l<h;l++){const y=this.readOutpoint(r);o.noSendChange.push(y)}}const d=r.readVarIntNum();if(d>=0){o.sendWithResults=[];for(let l=0;l<d;l++){const y=r.read(32),m=k(y),p=r.readInt8();let b="unproven";p===1?b="unproven":p===2?b="sending":p===3&&(b="failed"),o.sendWithResults.push({txid:m,status:b})}}if(r.readInt8()===1){const l=r.readVarIntNum(),y=r.read(l),m=r.readVarIntNum(),p=r.read(m);o.signableTransaction={tx:y,reference:T(p)}}return o}async signAction(t,i){const e=new I,n=Object.keys(t.spends);e.writeVarIntNum(n.length);for(const w of n){e.writeVarIntNum(Number(w));const l=t.spends[Number(w)],y=u(l.unlockingScript,"hex");e.writeVarIntNum(y.length),e.write(y),typeof l.sequenceNumber=="number"?e.writeVarIntNum(l.sequenceNumber):e.writeVarIntNum(-1)}const s=u(t.reference,"base64");if(e.writeVarIntNum(s.length),e.write(s),t.options!=null)if(e.writeInt8(1),typeof t.options.acceptDelayedBroadcast=="boolean"?e.writeInt8(t.options.acceptDelayedBroadcast?1:0):e.writeInt8(-1),typeof t.options.returnTXIDOnly=="boolean"?e.writeInt8(t.options.returnTXIDOnly?1:0):e.writeInt8(-1),typeof t.options.noSend=="boolean"?e.writeInt8(t.options.noSend?1:0):e.writeInt8(-1),t.options.sendWith!=null){e.writeVarIntNum(t.options.sendWith.length);for(const w of t.options.sendWith){const l=u(w,"hex");e.write(l)}}else e.writeVarIntNum(-1);else e.writeInt8(0);const r=await this.transmit("signAction",i,e.toArray()),o=new D(r),a={};if(o.readInt8()===1){const w=o.read(32);a.txid=k(w)}if(o.readInt8()===1){const w=o.readVarIntNum();a.tx=o.read(w)}const d=o.readVarIntNum();if(d>=0){a.sendWithResults=[];for(let w=0;w<d;w++){const l=o.read(32),y=k(l),m=o.readInt8();let p="unproven";m===1?p="unproven":m===2?p="sending":m===3&&(p="failed"),a.sendWithResults.push({txid:y,status:p})}}return a}async abortAction(t,i){return await this.transmit("abortAction",i,u(t.reference,"base64")),{aborted:!0}}async listActions(t,i){const e=new I;e.writeVarIntNum(t.labels.length);for(const c of t.labels){const h=u(c,"utf8");e.writeVarIntNum(h.length),e.write(h)}t.labelQueryMode==="any"?e.writeInt8(1):t.labelQueryMode==="all"?e.writeInt8(2):e.writeInt8(-1);const n=[t.includeLabels,t.includeInputs,t.includeInputSourceLockingScripts,t.includeInputUnlockingScripts,t.includeOutputs,t.includeOutputLockingScripts];for(const c of n)typeof c=="boolean"?e.writeInt8(c?1:0):e.writeInt8(-1);typeof t.limit=="number"?e.writeVarIntNum(t.limit):e.writeVarIntNum(-1),typeof t.offset=="number"?e.writeVarIntNum(t.offset):e.writeVarIntNum(-1),e.writeInt8(typeof t.seekPermission=="boolean"?t.seekPermission?1:0:-1);const s=await this.transmit("listActions",i,e.toArray()),r=new D(s),o=r.readVarIntNum(),a=[];for(let c=0;c<o;c++){const h=r.read(32),d=k(h),w=r.readVarIntNum(),l=r.readInt8();let y;switch(l){case 1:y="completed";break;case 2:y="unprocessed";break;case 3:y="sending";break;case 4:y="unproven";break;case 5:y="unsigned";break;case 6:y="nosend";break;case 7:y="nonfinal";break;case 8:y="failed";break;default:throw new Error(`Unknown status code: ${l}`)}const m=r.readInt8()===1,p=r.readVarIntNum(),b=r.read(p),S=g(b),N={txid:d,satoshis:w,status:y,isOutgoing:m,description:S,version:0,lockTime:0},V=r.readVarIntNum();if(V>=0){N.labels=[];for(let C=0;C<V;C++){const E=r.readVarIntNum(),O=r.read(E);N.labels.push(g(O))}}N.version=r.readVarIntNum(),N.lockTime=r.readVarIntNum();const x=r.readVarIntNum();if(x>=0){N.inputs=[];for(let C=0;C<x;C++){const E=this.readOutpoint(r),O=r.readVarIntNum(),F=r.readVarIntNum();let q;if(F>=0){const R=r.read(F);q=k(R)}const $=r.readVarIntNum();let z;if($>=0){const R=r.read($);z=k(R)}const Y=r.readVarIntNum(),Z=r.read(Y),M=g(Z),X=r.readVarIntNum();N.inputs.push({sourceOutpoint:E,sourceSatoshis:O,sourceLockingScript:q,unlockingScript:z,inputDescription:M,sequenceNumber:X})}}const B=r.readVarIntNum();if(B>=0){N.outputs=[];for(let C=0;C<B;C++){const E=r.readVarIntNum(),O=r.readVarIntNum(),F=r.readVarIntNum();let q;if(F>=0){const L=r.read(F);q=k(L)}const $=r.readInt8()===1,z=r.readVarIntNum(),Y=r.read(z),Z=g(Y),M=r.readVarIntNum();let X;if(M>=0){const L=r.read(M);X=g(L)}const R=r.readVarIntNum(),rt=[];if(R>=0)for(let L=0;L<R;L++){const vt=r.readVarIntNum(),gt=r.read(vt);rt.push(g(gt))}const nt=r.readVarIntNum();let st;if(nt>=0){const L=r.read(nt);st=g(L)}N.outputs.push({outputIndex:E,satoshis:O,lockingScript:q,spendable:$,outputDescription:Z,basket:X,tags:rt,customInstructions:st})}}a.push(N)}return{totalActions:o,actions:a}}async internalizeAction(t,i){var s,r,o;const e=new I;e.writeVarIntNum(t.tx.length),e.write(t.tx),e.writeVarIntNum(t.outputs.length);for(const a of t.outputs)if(e.writeVarIntNum(a.outputIndex),a.protocol==="wallet payment"){if(a.paymentRemittance==null)throw new Error("Payment remittance is required for wallet payment");e.writeUInt8(1),e.write(u(a.paymentRemittance.senderIdentityKey,"hex"));const c=u(a.paymentRemittance.derivationPrefix,"base64");e.writeVarIntNum(c.length),e.write(c);const h=u(a.paymentRemittance.derivationSuffix,"base64");e.writeVarIntNum(h.length),e.write(h)}else{e.writeUInt8(2);const c=u((s=a.insertionRemittance)==null?void 0:s.basket,"utf8");if(e.writeVarIntNum(c.length),e.write(c),typeof((r=a.insertionRemittance)==null?void 0:r.customInstructions)=="string"&&a.insertionRemittance.customInstructions!==""){const h=u(a.insertionRemittance.customInstructions,"utf8");e.writeVarIntNum(h.length),e.write(h)}else e.writeVarIntNum(-1);if(typeof((o=a.insertionRemittance)==null?void 0:o.tags)=="object"){e.writeVarIntNum(a.insertionRemittance.tags.length);for(const h of a.insertionRemittance.tags){const d=u(h,"utf8");e.writeVarIntNum(d.length),e.write(d)}}else e.writeVarIntNum(0)}if(typeof t.labels=="object"){e.writeVarIntNum(t.labels.length);for(const a of t.labels){const c=u(a,"utf8");e.writeVarIntNum(c.length),e.write(c)}}else e.writeVarIntNum(-1);const n=u(t.description);return e.writeVarIntNum(n.length),e.write(n),e.writeInt8(typeof t.seekPermission=="boolean"?t.seekPermission?1:0:-1),await this.transmit("internalizeAction",i,e.toArray()),{accepted:!0}}async listOutputs(t,i){const e=new I,n=u(t.basket,"utf8");if(e.writeVarIntNum(n.length),e.write(n),typeof t.tags=="object"){e.writeVarIntNum(t.tags.length);for(const d of t.tags){const w=u(d,"utf8");e.writeVarIntNum(w.length),e.write(w)}}else e.writeVarIntNum(0);t.tagQueryMode==="all"?e.writeInt8(1):t.tagQueryMode==="any"?e.writeInt8(2):e.writeInt8(-1),t.include==="locking scripts"?e.writeInt8(1):t.include==="entire transactions"?e.writeInt8(2):e.writeInt8(-1),typeof t.includeCustomInstructions=="boolean"?e.writeInt8(t.includeCustomInstructions?1:0):e.writeInt8(-1),typeof t.includeTags=="boolean"?e.writeInt8(t.includeTags?1:0):e.writeInt8(-1),typeof t.includeLabels=="boolean"?e.writeInt8(t.includeLabels?1:0):e.writeInt8(-1),typeof t.limit=="number"?e.writeVarIntNum(t.limit):e.writeVarIntNum(-1),typeof t.offset=="number"?e.writeVarIntNum(t.offset):e.writeVarIntNum(-1),e.writeInt8(typeof t.seekPermission=="boolean"?t.seekPermission?1:0:-1);const s=await this.transmit("listOutputs",i,e.toArray()),r=new D(s),o=r.readVarIntNum(),a=r.readVarIntNum();let c;a>=0&&(c=r.read(a));const h=[];for(let d=0;d<o;d++){const w=this.readOutpoint(r),l=r.readVarIntNum(),y={spendable:!0,outpoint:w,satoshis:l},m=r.readVarIntNum();m>=0&&(y.lockingScript=k(r.read(m)));const p=r.readVarIntNum();p>=0&&(y.customInstructions=g(r.read(p)));const b=r.readVarIntNum();if(b!==-1){const N=[];for(let V=0;V<b;V++){const x=r.readVarIntNum();N.push(g(r.read(x)))}y.tags=N}const S=r.readVarIntNum();if(S!==-1){const N=[];for(let V=0;V<S;V++){const x=r.readVarIntNum();N.push(g(r.read(x)))}y.labels=N}h.push(y)}return{totalOutputs:o,BEEF:c,outputs:h}}async relinquishOutput(t,i){const e=new I,n=u(t.basket,"utf8");return e.writeVarIntNum(n.length),e.write(n),e.write(this.encodeOutpoint(t.output)),await this.transmit("relinquishOutput",i,e.toArray()),{relinquished:!0}}encodeOutpoint(t){const i=new I,[e,n]=t.split(".");return i.write(u(e,"hex")),i.writeVarIntNum(Number(n)),i.toArray()}readOutpoint(t){const i=k(t.read(32)),e=t.readVarIntNum();return`${i}.${e}`}async getPublicKey(t,i){const e=new I;e.writeUInt8(t.identityKey?1:0),t.identityKey?e.write(this.encodePrivilegedParams(t.privileged,t.privilegedReason)):(e.write(this.encodeKeyRelatedParams(t.protocolID??(t.protocolID=[Dt.Silent,"default"]),t.keyID??(t.keyID=""),t.counterparty,t.privileged,t.privilegedReason)),typeof t.forSelf=="boolean"?e.writeInt8(t.forSelf?1:0):e.writeInt8(-1)),e.writeInt8(typeof t.seekPermission=="boolean"?t.seekPermission?1:0:-1);const n=await this.transmit("getPublicKey",i,e.toArray());return{publicKey:k(n)}}async revealCounterpartyKeyLinkage(t,i){const e=new I;e.write(this.encodePrivilegedParams(t.privileged,t.privilegedReason)),e.write(u(t.counterparty,"hex")),e.write(u(t.verifier,"hex"));const n=await this.transmit("revealCounterpartyKeyLinkage",i,e.toArray()),s=new D(n),r=k(s.read(33)),o=k(s.read(33)),a=k(s.read(33)),c=s.readVarIntNum(),h=g(s.read(c)),d=s.readVarIntNum(),w=s.read(d),l=s.readVarIntNum(),y=s.read(l);return{prover:r,verifier:o,counterparty:a,revelationTime:h,encryptedLinkage:w,encryptedLinkageProof:y}}async revealSpecificKeyLinkage(t,i){const e=new I;e.write(this.encodeKeyRelatedParams(t.protocolID,t.keyID,t.counterparty,t.privileged,t.privilegedReason)),e.write(u(t.verifier,"hex"));const n=await this.transmit("revealSpecificKeyLinkage",i,e.toArray()),s=new D(n),r=k(s.read(33)),o=k(s.read(33)),a=k(s.read(33)),c=s.readUInt8(),h=s.readVarIntNum(),d=g(s.read(h)),w=s.readVarIntNum(),l=g(s.read(w)),y=s.readVarIntNum(),m=s.read(y),p=s.readVarIntNum(),b=s.read(p),S=s.readUInt8();return{prover:r,verifier:o,counterparty:a,protocolID:[c,d],keyID:l,encryptedLinkage:m,encryptedLinkageProof:b,proofType:S}}async encrypt(t,i){const e=new I;return e.write(this.encodeKeyRelatedParams(t.protocolID,t.keyID,t.counterparty,t.privileged,t.privilegedReason)),e.writeVarIntNum(t.plaintext.length),e.write(t.plaintext),e.writeInt8(typeof t.seekPermission=="boolean"?t.seekPermission?1:0:-1),{ciphertext:await this.transmit("encrypt",i,e.toArray())}}async decrypt(t,i){const e=new I;return e.write(this.encodeKeyRelatedParams(t.protocolID,t.keyID,t.counterparty,t.privileged,t.privilegedReason)),e.writeVarIntNum(t.ciphertext.length),e.write(t.ciphertext),e.writeInt8(typeof t.seekPermission=="boolean"?t.seekPermission?1:0:-1),{plaintext:await this.transmit("decrypt",i,e.toArray())}}async createHmac(t,i){const e=new I;return e.write(this.encodeKeyRelatedParams(t.protocolID,t.keyID,t.counterparty,t.privileged,t.privilegedReason)),e.writeVarIntNum(t.data.length),e.write(t.data),e.writeInt8(typeof t.seekPermission=="boolean"?t.seekPermission?1:0:-1),{hmac:await this.transmit("createHmac",i,e.toArray())}}async verifyHmac(t,i){const e=new I;return e.write(this.encodeKeyRelatedParams(t.protocolID,t.keyID,t.counterparty,t.privileged,t.privilegedReason)),e.write(t.hmac),e.writeVarIntNum(t.data.length),e.write(t.data),e.writeInt8(typeof t.seekPermission=="boolean"?t.seekPermission?1:0:-1),await this.transmit("verifyHmac",i,e.toArray()),{valid:!0}}async createSignature(t,i){const e=new I;return e.write(this.encodeKeyRelatedParams(t.protocolID,t.keyID,t.counterparty,t.privileged,t.privilegedReason)),typeof t.data=="object"?(e.writeUInt8(1),e.writeVarIntNum(t.data.length),e.write(t.data)):(e.writeUInt8(2),e.write(t.hashToDirectlySign??(t.hashToDirectlySign=[]))),e.writeInt8(typeof t.seekPermission=="boolean"?t.seekPermission?1:0:-1),{signature:await this.transmit("createSignature",i,e.toArray())}}async verifySignature(t,i){const e=new I;return e.write(this.encodeKeyRelatedParams(t.protocolID,t.keyID,t.counterparty,t.privileged,t.privilegedReason)),typeof t.forSelf=="boolean"?e.writeInt8(t.forSelf?1:0):e.writeInt8(-1),e.writeVarIntNum(t.signature.length),e.write(t.signature),typeof t.data=="object"?(e.writeUInt8(1),e.writeVarIntNum(t.data.length),e.write(t.data)):(e.writeUInt8(2),e.write(t.hashToDirectlyVerify??[])),e.writeInt8(typeof t.seekPermission=="boolean"?t.seekPermission?1:0:-1),await this.transmit("verifySignature",i,e.toArray()),{valid:!0}}encodeKeyRelatedParams(t,i,e,n,s){const r=new I;r.writeUInt8(t[0]);const o=u(t[1],"utf8");r.writeVarIntNum(o.length),r.write(o);const a=u(i,"utf8");return r.writeVarIntNum(a.length),r.write(a),typeof e!="string"?r.writeUInt8(0):e==="self"?r.writeUInt8(11):e==="anyone"?r.writeUInt8(12):r.write(u(e,"hex")),r.write(this.encodePrivilegedParams(n,s)),r.toArray()}async acquireCertificate(t,i){var o;const e=new I;e.write(u(t.type,"base64")),e.write(u(t.certifier,"hex"));const n=Object.entries(t.fields);e.writeVarIntNum(n.length);for(const[a,c]of n){const h=u(a,"utf8"),d=u(c,"utf8");e.writeVarIntNum(h.length),e.write(h),e.writeVarIntNum(d.length),e.write(d)}if(e.write(this.encodePrivilegedParams(t.privileged,t.privilegedReason)),e.writeUInt8(t.acquisitionProtocol==="direct"?1:2),t.acquisitionProtocol==="direct"){e.write(u(t.serialNumber,"base64")),e.write(this.encodeOutpoint(t.revocationOutpoint??""));const a=u(t.signature,"hex");e.writeVarIntNum(a.length),e.write(a);const c=t.keyringRevealer!=="certifier"?u(t.keyringRevealer,"hex"):[11];e.write(c);const h=Object.keys(t.keyringForSubject??{});e.writeVarIntNum(h.length);for(let d=0;d<h.length;d++){const w=u(h[d],"utf8");e.writeVarIntNum(w.length),e.write(w);const l=u((o=t.keyringForSubject)==null?void 0:o[h[d]],"base64");e.writeVarIntNum(l.length),e.write(l)}}else{const a=u(t.certifierUrl,"utf8");e.writeVarIntNum(a.length),e.write(a)}const s=await this.transmit("acquireCertificate",i,e.toArray()),r=j.fromBinary(s);return{...r,signature:r.signature}}encodePrivilegedParams(t,i){const e=new I;if(typeof t=="boolean"?e.writeInt8(t?1:0):e.writeInt8(-1),typeof i=="string"){const n=u(i,"utf8");e.writeInt8(n.length),e.write(n)}else e.writeInt8(-1);return e.toArray()}async listCertificates(t,i){const e=new I;e.writeVarIntNum(t.certifiers.length);for(let a=0;a<t.certifiers.length;a++)e.write(u(t.certifiers[a],"hex"));e.writeVarIntNum(t.types.length);for(let a=0;a<t.types.length;a++)e.write(u(t.types[a],"base64"));typeof t.limit=="number"?e.writeVarIntNum(t.limit):e.writeVarIntNum(-1),typeof t.offset=="number"?e.writeVarIntNum(t.offset):e.writeVarIntNum(-1),e.write(this.encodePrivilegedParams(t.privileged,t.privilegedReason));const n=await this.transmit("listCertificates",i,e.toArray()),s=new D(n),r=s.readVarIntNum(),o=[];for(let a=0;a<r;a++){const c=s.readVarIntNum(),h=s.read(c),d=j.fromBinary(h);o.push({...d,signature:d.signature})}return{totalCertificates:r,certificates:o}}async proveCertificate(t,i){const e=new I,n=u(t.certificate.type,"base64");e.write(n);const s=u(t.certificate.subject,"hex");e.write(s);const r=u(t.certificate.serialNumber,"base64");e.write(r);const o=u(t.certificate.certifier,"hex");e.write(o);const a=this.encodeOutpoint(t.certificate.revocationOutpoint??"");e.write(a);const c=u(t.certificate.signature,"hex");e.writeVarIntNum(c.length),e.write(c);const h=Object.entries(t.certificate.fields??{});e.writeVarIntNum(h.length);for(const[m,p]of h){const b=u(m,"utf8"),S=u(p,"utf8");e.writeVarIntNum(b.length),e.write(b),e.writeVarIntNum(S.length),e.write(S)}e.writeVarIntNum(t.fieldsToReveal.length);for(const m of t.fieldsToReveal){const p=u(m,"utf8");e.writeVarIntNum(p.length),e.write(p)}e.write(u(t.verifier,"hex")),e.write(this.encodePrivilegedParams(t.privileged,t.privilegedReason));const d=await this.transmit("proveCertificate",i,e.toArray()),w=new D(d),l=w.readVarIntNum(),y={};for(let m=0;m<l;m++){const p=w.readVarIntNum(),b=g(w.read(p)),S=w.readVarIntNum();y[b]=T(w.read(S))}return{keyringForVerifier:y}}async relinquishCertificate(t,i){const e=new I,n=u(t.type,"base64");e.write(n);const s=u(t.serialNumber,"base64");e.write(s);const r=u(t.certifier,"hex");return e.write(r),await this.transmit("relinquishCertificate",i,e.toArray()),{relinquished:!0}}parseDiscoveryResult(t){const i=new D(t),e=i.readVarIntNum(),n=[];for(let s=0;s<e;s++){const r=i.readVarIntNum(),o=i.read(r),a=j.fromBinary(o),c=i.readVarIntNum(),h=g(i.read(c)),d=i.readVarIntNum(),w=g(i.read(d)),l=i.readVarIntNum(),y=g(i.read(l)),m=i.readUInt8(),p={},b=i.readVarIntNum();for(let V=0;V<b;V++){const x=i.readVarIntNum(),B=g(i.read(x)),C=i.readVarIntNum();p[B]=i.read(C)}const S={},N=i.readVarIntNum();for(let V=0;V<N;V++){const x=i.readVarIntNum(),B=g(i.read(x)),C=i.readVarIntNum();S[B]=g(i.read(C))}n.push({...a,signature:a.signature,certifierInfo:{iconUrl:w,name:h,description:y,trust:m},publiclyRevealedKeyring:p,decryptedFields:S})}return{totalCertificates:e,certificates:n}}async discoverByIdentityKey(t,i){const e=new I;e.write(u(t.identityKey,"hex")),typeof t.limit=="number"?e.writeVarIntNum(t.limit):e.writeVarIntNum(-1),typeof t.offset=="number"?e.writeVarIntNum(t.offset):e.writeVarIntNum(-1),e.writeInt8(typeof t.seekPermission=="boolean"?t.seekPermission?1:0:-1);const n=await this.transmit("discoverByIdentityKey",i,e.toArray());return this.parseDiscoveryResult(n)}async discoverByAttributes(t,i){const e=new I,n=Object.keys(t.attributes);e.writeVarIntNum(n.length);for(let r=0;r<n.length;r++)e.writeVarIntNum(n[r].length),e.write(u(n[r],"utf8")),e.writeVarIntNum(t.attributes[n[r]].length),e.write(u(t.attributes[n[r]],"utf8"));typeof t.limit=="number"?e.writeVarIntNum(t.limit):e.writeVarIntNum(-1),typeof t.offset=="number"?e.writeVarIntNum(t.offset):e.writeVarIntNum(-1),e.writeInt8(typeof t.seekPermission=="boolean"?t.seekPermission?1:0:-1);const s=await this.transmit("discoverByAttributes",i,e.toArray());return this.parseDiscoveryResult(s)}async isAuthenticated(t,i){return{authenticated:(await this.transmit("isAuthenticated",i))[0]===1}}async waitForAuthentication(t,i){return await this.transmit("waitForAuthentication",i),{authenticated:!0}}async getHeight(t,i){const e=await this.transmit("getHeight",i);return{height:new D(e).readVarIntNum()}}async getHeaderForHeight(t,i){const e=new I;e.writeVarIntNum(t.height);const n=await this.transmit("getHeaderForHeight",i,e.toArray());return{header:k(n)}}async getNetwork(t,i){return{network:(await this.transmit("getNetwork",i))[0]===0?"mainnet":"testnet"}}async getVersion(t,i){const e=await this.transmit("getVersion",i);return{version:g(e)}}}class yt{constructor(t,i="http://localhost:3301",e=fetch){f(this,"baseUrl");f(this,"httpClient");f(this,"originator");this.baseUrl=i,this.httpClient=e,this.originator=t}async transmitToWallet(t){const i=new D(t),e=i.readUInt8(),n=It[e];if(n===void 0||n==="")throw new Error(`Invalid call code: ${e}`);const s=i.readUInt8();let r;if(s>0){const h=i.read(s);r=g(h)}const o=i.read(),c=await(await fetch(`${this.baseUrl}/${n}`,{method:"POST",headers:{"Content-Type":"application/octet-stream",Origin:r??""},body:new Uint8Array(o)})).arrayBuffer();return Array.from(new Uint8Array(c))}}class Et extends Error{constructor(i,e,n,s,r){super("Undelayed createAction or signAction results require review.");f(this,"reviewActionResults");f(this,"sendWithResults");f(this,"txid");f(this,"tx");f(this,"noSendChange");f(this,"code");f(this,"isError",!0);this.reviewActionResults=i,this.sendWithResults=e,this.txid=n,this.tx=s,this.noSendChange=r,this.code=5,this.name=this.constructor.name}}function Rt(v,t="http"){if(/^[a-z][a-z0-9+.-]*:\/\//i.test(v))try{return new URL(v).origin}catch{}try{return new URL(`${t}://${v}`).origin}catch{throw new Error(`Invalid originator value: ${v}`)}}class dt{constructor(t,i="http://localhost:3321",e=fetch){f(this,"baseUrl");f(this,"httpClient");f(this,"originator");f(this,"api");this.baseUrl=i,this.originator=t,this.httpClient=e;const n=typeof window<"u"&&typeof document<"u"&&(window==null?void 0:window.origin)!=="file://";this.api=async(s,r)=>{const o=!n&&this.originator?Rt(this.originator,"http"):void 0;!n&&o===void 0&&console.error("Originator is required in Node.js environments");const a=await await e(`${this.baseUrl}/${s}`,{method:"POST",headers:{Accept:"application/json","Content-Type":"application/json",...o?{Origin:o}:{},...o?{Originator:o}:{}},body:JSON.stringify(r)}),c=await a.json();if(!a.ok){if(a.status===400&&c.isError&&c.code===5)throw new Et(c.reviewActionResults,c.sendWithResults,c.txid,c.tx,c.noSendChange);{const h={call:s,args:r,message:c.message??`HTTP Client error ${a.status}`};throw new Error(JSON.stringify(h))}}return c}}async createAction(t){return await this.api("createAction",t)}async signAction(t){return await this.api("signAction",t)}async abortAction(t){return await this.api("abortAction",t)}async listActions(t){return await this.api("listActions",t)}async internalizeAction(t){return await this.api("internalizeAction",t)}async listOutputs(t){return await this.api("listOutputs",t)}async relinquishOutput(t){return await this.api("relinquishOutput",t)}async getPublicKey(t){return await this.api("getPublicKey",t)}async revealCounterpartyKeyLinkage(t){return await this.api("revealCounterpartyKeyLinkage",t)}async revealSpecificKeyLinkage(t){return await this.api("revealSpecificKeyLinkage",t)}async encrypt(t){return await this.api("encrypt",t)}async decrypt(t){return await this.api("decrypt",t)}async createHmac(t){return await this.api("createHmac",t)}async verifyHmac(t){return await this.api("verifyHmac",t)}async createSignature(t){return await this.api("createSignature",t)}async verifySignature(t){return await this.api("verifySignature",t)}async acquireCertificate(t){return await this.api("acquireCertificate",t)}async listCertificates(t){return await this.api("listCertificates",t)}async proveCertificate(t){return await this.api("proveCertificate",t)}async relinquishCertificate(t){return await this.api("relinquishCertificate",t)}async discoverByIdentityKey(t){return await this.api("discoverByIdentityKey",t)}async discoverByAttributes(t){return await this.api("discoverByAttributes",t)}async isAuthenticated(t){return await this.api("isAuthenticated",t)}async waitForAuthentication(t){return await this.api("waitForAuthentication",t)}async getHeight(t){return await this.api("getHeight",t)}async getHeaderForHeight(t){return await this.api("getHeaderForHeight",t)}async getNetwork(t){return await this.api("getNetwork",t)}async getVersion(t){return await this.api("getVersion",t)}}class wt{constructor(t="*"){f(this,"domain");if(typeof window!="object")throw new Error("The XDM substrate requires a global window object.");if(!window.hasOwnProperty("ReactNativeWebView"))throw new Error("The window object does not have a ReactNativeWebView property.");if(typeof window.ReactNativeWebView.postMessage!="function")throw new Error("The window.ReactNativeWebView property does not seem to support postMessage calls.");this.domain=t}async invoke(t,i){return await new Promise((e,n)=>{const s=T(P(12)),r=o=>{const a=JSON.parse(o.data);if(!(a.type!=="CWI"||a.id!==s||a.isInvocation===!0))if(typeof window.removeEventListener=="function"&&window.removeEventListener("message",r),a.status==="error"){const c=new et(a.description,a.code);n(c)}else e(a.result)};window.addEventListener("message",r),window.ReactNativeWebView.postMessage(JSON.stringify({type:"CWI",isInvocation:!0,id:s,call:t,args:i}))})}async createAction(t){return await this.invoke("createAction",t)}async signAction(t){return await this.invoke("signAction",t)}async abortAction(t){return await this.invoke("abortAction",t)}async listActions(t){return await this.invoke("listActions",t)}async internalizeAction(t){return await this.invoke("internalizeAction",t)}async listOutputs(t){return await this.invoke("listOutputs",t)}async relinquishOutput(t){return await this.invoke("relinquishOutput",t)}async getPublicKey(t){return await this.invoke("getPublicKey",t)}async revealCounterpartyKeyLinkage(t){return await this.invoke("revealCounterpartyKeyLinkage",t)}async revealSpecificKeyLinkage(t){return await this.invoke("revealSpecificKeyLinkage",t)}async encrypt(t){return await this.invoke("encrypt",t)}async decrypt(t){return await this.invoke("decrypt",t)}async createHmac(t){return await this.invoke("createHmac",t)}async verifyHmac(t){return await this.invoke("verifyHmac",t)}async createSignature(t){return await this.invoke("createSignature",t)}async verifySignature(t){return await this.invoke("verifySignature",t)}async acquireCertificate(t){return await this.invoke("acquireCertificate",t)}async listCertificates(t){return await this.invoke("listCertificates",t)}async proveCertificate(t){return await this.invoke("proveCertificate",t)}async relinquishCertificate(t){return await this.invoke("relinquishCertificate",t)}async discoverByIdentityKey(t){return await this.invoke("discoverByIdentityKey",t)}async discoverByAttributes(t){return await this.invoke("discoverByAttributes",t)}async isAuthenticated(t){return await this.invoke("isAuthenticated",t)}async waitForAuthentication(t){return await this.invoke("waitForAuthentication",t)}async getHeight(t){return await this.invoke("getHeight",t)}async getHeaderForHeight(t){return await this.invoke("getHeaderForHeight",t)}async getNetwork(t){return await this.invoke("getNetwork",t)}async getVersion(t){return await this.invoke("getVersion",t)}}const Tt=200;class Ht{constructor(t="auto",i){f(this,"substrate");f(this,"originator");t==="Cicada"&&(t=new ht(new yt(i))),t==="window.CWI"&&(t=new ut),t==="XDM"&&(t=new lt),t==="json-api"&&(t=new dt(i)),t==="react-native"&&(t=new wt(i)),this.substrate=t,this.originator=i}async connectToSubstrate(){if(typeof this.substrate=="object")return;let t;const i=async e=>{let n;if(typeof e=="number"?n=await Promise.race([t.getVersion({}),new Promise((s,r)=>setTimeout(()=>r(new Error("Timed out.")),e))]):n=await t.getVersion({}),typeof n!="object"||typeof n.version!="string")throw new Error("Failed to use substrate.")};try{t=new ut,await i(),this.substrate=t}catch{try{t=new lt,await i(Tt),this.substrate=t}catch{try{t=new ht(new yt(this.originator)),await i(),this.substrate=t}catch{try{t=new dt(this.originator),await i(),this.substrate=t}catch{try{t=new wt(this.originator),await i(),this.substrate=t}catch{throw new Error("No wallet available over any communication substrate. Install a BSV wallet today!")}}}}}}async createAction(t){return await this.connectToSubstrate(),await this.substrate.createAction(t,this.originator)}async signAction(t){return await this.connectToSubstrate(),await this.substrate.signAction(t,this.originator)}async abortAction(t){return await this.connectToSubstrate(),await this.substrate.abortAction(t,this.originator)}async listActions(t){return await this.connectToSubstrate(),await this.substrate.listActions(t,this.originator)}async internalizeAction(t){return await this.connectToSubstrate(),await this.substrate.internalizeAction(t,this.originator)}async listOutputs(t){return await this.connectToSubstrate(),await this.substrate.listOutputs(t,this.originator)}async relinquishOutput(t){return await this.connectToSubstrate(),await this.substrate.relinquishOutput(t,this.originator)}async getPublicKey(t){return await this.connectToSubstrate(),await this.substrate.getPublicKey(t,this.originator)}async revealCounterpartyKeyLinkage(t){return await this.connectToSubstrate(),await this.substrate.revealCounterpartyKeyLinkage(t,this.originator)}async revealSpecificKeyLinkage(t){return await this.connectToSubstrate(),await this.substrate.revealSpecificKeyLinkage(t,this.originator)}async encrypt(t){return await this.connectToSubstrate(),await this.substrate.encrypt(t,this.originator)}async decrypt(t){return await this.connectToSubstrate(),await this.substrate.decrypt(t,this.originator)}async createHmac(t){return await this.connectToSubstrate(),await this.substrate.createHmac(t,this.originator)}async verifyHmac(t){return await this.connectToSubstrate(),await this.substrate.verifyHmac(t,this.originator)}async createSignature(t){return await this.connectToSubstrate(),await this.substrate.createSignature(t,this.originator)}async verifySignature(t){return await this.connectToSubstrate(),await this.substrate.verifySignature(t,this.originator)}async acquireCertificate(t){return await this.connectToSubstrate(),await this.substrate.acquireCertificate(t,this.originator)}async listCertificates(t){return await this.connectToSubstrate(),await this.substrate.listCertificates(t,this.originator)}async proveCertificate(t){return await this.connectToSubstrate(),await this.substrate.proveCertificate(t,this.originator)}async relinquishCertificate(t){return await this.connectToSubstrate(),await this.substrate.relinquishCertificate(t,this.originator)}async discoverByIdentityKey(t){return await this.connectToSubstrate(),await this.substrate.discoverByIdentityKey(t,this.originator)}async discoverByAttributes(t){return await this.connectToSubstrate(),await this.substrate.discoverByAttributes(t,this.originator)}async isAuthenticated(t={}){return await this.connectToSubstrate(),await this.substrate.isAuthenticated(t,this.originator)}async waitForAuthentication(t={}){return await this.connectToSubstrate(),await this.substrate.waitForAuthentication(t,this.originator)}async getHeight(t={}){return await this.connectToSubstrate(),await this.substrate.getHeight(t,this.originator)}async getHeaderForHeight(t){return await this.connectToSubstrate(),await this.substrate.getHeaderForHeight(t,this.originator)}async getNetwork(t={}){return await this.connectToSubstrate(),await this.substrate.getNetwork(t,this.originator)}async getVersion(t={}){return await this.connectToSubstrate(),await this.substrate.getVersion(t,this.originator)}}class Ot{constructor(t={}){this.isConnected=!1,this.isChecking=!1,this.publicKey=null,this.connectionListeners=[],this.config={apiUrl:"http://localhost:8788",checkInterval:1e3,...t},this.walletClient=new Ht,this.startMetaNetCheck()}startMetaNetCheck(){if(this.isChecking)return;this.isChecking=!0,console.log("🔍 Starting MetaNet Desktop detection...");const t=setInterval(async()=>{try{await this.checkForMetaNetClient()?(console.log("✅ MetaNet Client detected!"),clearInterval(t),this.isChecking=!1,await this.attemptAuthentication()):console.log("⏳ Waiting for MetaNet Client...")}catch(i){console.log("❌ MetaNet check error:",i.message)}},this.config.checkInterval)}async checkForMetaNetClient(){try{const t=await this.walletClient.isAuthenticated();return!0}catch(t){return!(t.message.includes("No MetaNet Client")||t.message.includes("not running")||t.message.includes("connection refused"))}}async attemptAuthentication(){try{console.log("🔐 Attempting authentication with MetaNet Desktop..."),await this.walletClient.waitForAuthentication(),console.log("✅ Authentication successful!");const t=await this.walletClient.getPublicKey({identityKey:!0});this.publicKey=t.publicKey,this.isConnected=!0,console.log("🔑 Got identity key:",this.publicKey.slice(0,10)+"..."),this.notifyConnectionChange(!0),await this.authenticateWithBackend()}catch(t){throw console.error("❌ Authentication failed:",t),this.isConnected=!1,this.publicKey=null,this.notifyConnectionChange(!1),t}}async connect(){if(console.log("🔗 Manual connect requested..."),this.isConnected&&this.publicKey)return{publicKey:this.publicKey,isConnected:!0};if(await this.attemptAuthentication(),!this.isConnected||!this.publicKey)throw new Error("Failed to connect to MetaNet Desktop wallet");return{publicKey:this.publicKey,isConnected:!0}}async disconnect(){this.isConnected=!1,this.publicKey=null,this.notifyConnectionChange(!1),console.log("🔌 Disconnected from wallet")}isWalletConnected(){return this.isConnected}getPublicKey(){return this.publicKey}getWalletClient(){return this.walletClient}async authenticateWithBackend(){if(!this.publicKey)throw new Error("No public key available for backend authentication");try{console.log("🔄 Authenticating with backend...");const t=await fetch(`${this.config.apiUrl}/identity/wallet/connect`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({walletType:"metanet",capabilities:["sign","pay","identity"]})});if(!t.ok)throw new Error(`Backend init failed: ${t.statusText}`);const{sessionId:i}=await t.json();console.log("📋 Got session ID:",i);const e=this.generateNonce(),n=`wallet_verification:${i}`,s=await this.walletClient.createSignature({data:btoa(n+e),protocolID:[2,"gitdata-identity"],keyID:"identity",privilegedReason:"Verify wallet ownership for Gitdata platform"}),r=await fetch(`${this.config.apiUrl}/identity/wallet/verify`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({sessionId:i,identityKey:this.publicKey,signature:s.signature,nonce:e})});if(!r.ok)throw new Error(`Backend verification failed: ${r.statusText}`);console.log("✅ Backend authentication successful!")}catch(t){console.error("❌ Backend authentication error:",t)}}async generateAuthHeaders(t=""){if(!this.publicKey)throw new Error("No wallet connected");const i=this.generateNonce(),e=t+i,n=await this.walletClient.createSignature({data:btoa(e),protocolID:[2,"gitdata-identity"],keyID:"identity",privilegedReason:"Authenticate API request"});return{"X-Identity-Key":this.publicKey,"X-Nonce":i,"X-Signature":n.signature,"Content-Type":"application/json"}}generateNonce(){const t=new Uint8Array(16);return crypto.getRandomValues(t),Array.from(t,i=>i.toString(16).padStart(2,"0")).join("")}onConnectionChange(t){return this.connectionListeners.push(t),()=>{const i=this.connectionListeners.indexOf(t);i>-1&&this.connectionListeners.splice(i,1)}}notifyConnectionChange(t){this.connectionListeners.forEach(i=>{try{i(t)}catch(e){console.error("Connection listener error:",e)}})}}const jt=new Ot;export{jt as bsvWalletService,Ot as default};
