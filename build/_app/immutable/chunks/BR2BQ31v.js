var u={};function s(){if(typeof globalThis<"u"&&"window"in globalThis)return globalThis.window}class g{constructor(){this.walletConnection=null,this.connectionListeners=[]}async detectWallet(){var t,r;console.log("🔍 Detecting wallets...");const e=s();if(e){if(console.log("🌐 Window object available, checking for wallets..."),(t=e.bsv)!=null&&t.wallet)return console.log("✅ Found BSV standard wallet"),e.bsv.wallet;if(e.wallet)return console.log("✅ Found generic wallet"),e.wallet;const a=["panda","yours","handcash","moneybutton"];for(const n of a)if((r=e[n])!=null&&r.wallet)return console.log(`✅ Found ${n} wallet`),e[n].wallet;if(console.log("🔍 Checking for MetaNet Desktop wallet..."),e.metanet||e.metaNet||e.MetaNet){const n=e.metanet||e.metaNet||e.MetaNet;return console.log("✅ Found MetaNet Desktop wallet"),n||null}const o=Object.keys(e).filter(n=>n.toLowerCase().includes("wallet")||n.toLowerCase().includes("metanet")||n.toLowerCase().includes("bsv"));console.log("🔍 Available wallet-related window properties:",o)}else console.log("❌ Window object not available");return console.log("❌ No wallet detected"),null}async connect(){console.log("🔗 Starting wallet connection...");try{const e=await this.detectWallet();if(!e)throw console.log("❌ No wallet found, throwing error"),new Error("No BRC-100 compatible wallet found. Please install a compatible wallet.");if(console.log("✅ Wallet detected, proceeding with connection..."),e.isAvailable&&!await e.isAvailable())throw new Error("Wallet is not available or not responding.");const t=await e.getPublicKey({identityKey:!0});return await this.authenticateWithBackend(e,t.publicKey),this.walletConnection={wallet:e,isConnected:!0,publicKey:t.publicKey},this.notifyConnectionChange(!0),this.walletConnection}catch(e){throw this.walletConnection=null,this.notifyConnectionChange(!1),new Error(`Failed to connect to wallet: ${e.message}`)}}async disconnect(){this.walletConnection=null,this.notifyConnectionChange(!1)}getConnection(){return this.walletConnection}isConnected(){var e;return((e=this.walletConnection)==null?void 0:e.isConnected)??!1}getWallet(){var e;return u.VITEST?{createAction:async t=>({txid:"mock-txid",tx:"mock-beef"}),signAction:async t=>({txid:"mock-txid",tx:"mock-beef"}),abortAction:async t=>({aborted:!0}),listActions:async t=>({actions:[]}),internalizeAction:async t=>({accepted:!0}),listOutputs:async t=>({outputs:[]}),relinquishOutput:async t=>({relinquished:!0}),getPublicKey:async t=>({publicKey:"mock-test-pubkey"}),revealCounterpartyKeyLinkage:async t=>({linkage:"mock-linkage"}),revealSpecificKeyLinkage:async t=>({linkage:"mock-specific-linkage"}),encrypt:async t=>({ciphertext:"mock-encrypted"}),decrypt:async t=>({plaintext:"mock-decrypted"}),createHmac:async t=>({hmac:"mock-hmac"}),verifyHmac:async t=>({valid:!0}),createSignature:async t=>({signature:"mock-signature"}),verifySignature:async t=>({valid:!0}),acquireCertificate:async t=>({certificate:"mock-cert"}),listCertificates:async t=>({certificates:[]}),proveCertificate:async t=>({proof:"mock-proof"}),relinquishCertificate:async t=>({relinquished:!0}),discoverByIdentityKey:async t=>({certificates:[]}),discoverByAttributes:async t=>({certificates:[]}),isAuthenticated:async()=>!0,waitForAuthentication:async()=>!0,getHeight:async()=>8e5,getHeaderForHeight:async t=>({height:t,hash:"mock-hash",version:1,previousHash:"mock-prev-hash",merkleRoot:"mock-merkle",time:Date.now(),bits:486604799,nonce:12345}),getNetwork:async()=>"testnet",getVersion:async()=>({version:"1.0.0",implementation:"mock-test-wallet"}),isAvailable:async()=>!0}:((e=this.walletConnection)==null?void 0:e.wallet)??null}getPublicKey(){var e;return((e=this.walletConnection)==null?void 0:e.publicKey)??null}async authenticate(){const e=this.getWallet();if(!e)throw new Error("No wallet connected");try{return{publicKey:(await e.getPublicKey({identityKey:!0})).publicKey}}catch(t){throw new Error(`Authentication failed: ${t.message}`)}}async createPurchaseTransaction(e){const t=this.getWallet();if(!t)throw new Error("No wallet connected");try{return await t.createAction({description:e.description,outputs:[{script:e.recipientScript,satoshis:e.amount,description:`Purchase of data version ${e.versionId}`,basket:"purchases",tags:["data-purchase",`version:${e.versionId}`]}],labels:["data-purchase","gitdata-purchase"]})}catch(r){throw new Error(`Failed to create purchase transaction: ${r.message}`)}}async signAction(e){const t=this.getWallet();if(!t)throw new Error("No wallet connected");try{return await t.signAction(e)}catch(r){throw new Error(`Failed to sign action: ${r.message}`)}}async abortAction(e){const t=this.getWallet();if(!t)throw new Error("No wallet connected");try{return await t.abortAction({reference:e})}catch(r){throw new Error(`Failed to abort action: ${r.message}`)}}async internalizeAction(e){const t=this.getWallet();if(!t)throw new Error("No wallet connected");try{return await t.internalizeAction(e)}catch(r){throw new Error(`Failed to internalize action: ${r.message}`)}}async relinquishOutput(e,t){const r=this.getWallet();if(!r)throw new Error("No wallet connected");try{return await r.relinquishOutput({basket:e,output:t})}catch(a){throw new Error(`Failed to relinquish output: ${a.message}`)}}async revealCounterpartyKeyLinkage(e){const t=this.getWallet();if(!t)throw new Error("No wallet connected");try{return await t.revealCounterpartyKeyLinkage(e)}catch(r){throw new Error(`Failed to reveal counterparty key linkage: ${r.message}`)}}async revealSpecificKeyLinkage(e){const t=this.getWallet();if(!t)throw new Error("No wallet connected");try{return await t.revealSpecificKeyLinkage(e)}catch(r){throw new Error(`Failed to reveal specific key linkage: ${r.message}`)}}async createHmac(e){const t=this.getWallet();if(!t)throw new Error("No wallet connected");try{return await t.createHmac(e)}catch(r){throw new Error(`Failed to create HMAC: ${r.message}`)}}async verifyHmac(e){const t=this.getWallet();if(!t)throw new Error("No wallet connected");try{return await t.verifyHmac(e)}catch(r){throw new Error(`Failed to verify HMAC: ${r.message}`)}}async verifySignature(e){const t=this.getWallet();if(!t)throw new Error("No wallet connected");try{return await t.verifySignature(e)}catch(r){throw new Error(`Failed to verify signature: ${r.message}`)}}async acquireCertificate(e){const t=this.getWallet();if(!t)throw new Error("No wallet connected");try{return await t.acquireCertificate(e)}catch(r){throw new Error(`Failed to acquire certificate: ${r.message}`)}}async listCertificates(e){const t=this.getWallet();if(!t)throw new Error("No wallet connected");try{return await t.listCertificates(e)}catch(r){throw new Error(`Failed to list certificates: ${r.message}`)}}async proveCertificate(e){const t=this.getWallet();if(!t)throw new Error("No wallet connected");try{return await t.proveCertificate(e)}catch(r){throw new Error(`Failed to prove certificate: ${r.message}`)}}async relinquishCertificate(e){const t=this.getWallet();if(!t)throw new Error("No wallet connected");try{return await t.relinquishCertificate(e)}catch(r){throw new Error(`Failed to relinquish certificate: ${r.message}`)}}async discoverByIdentityKey(e){const t=this.getWallet();if(!t)throw new Error("No wallet connected");try{return await t.discoverByIdentityKey(e)}catch(r){throw new Error(`Failed to discover certificates by identity key: ${r.message}`)}}async discoverByAttributes(e){const t=this.getWallet();if(!t)throw new Error("No wallet connected");try{return await t.discoverByAttributes(e)}catch(r){throw new Error(`Failed to discover certificates by attributes: ${r.message}`)}}async getPurchaseHistory(){const e=this.getWallet();if(!e)throw new Error("No wallet connected");try{return(await e.listActions({labels:["data-purchase","gitdata-purchase"],labelQueryMode:"any",includeOutputs:!0,includeLabels:!0})).actions}catch(t){throw new Error(`Failed to get purchase history: ${t.message}`)}}async getAvailableBalance(){const e=this.getWallet();if(!e)throw new Error("No wallet connected");try{const t=await e.listOutputs({basket:"default",includeCustomInstructions:!0,includeTags:!0});return{balance:t.outputs.reduce((a,o)=>a+o.satoshis,0),outputs:t.outputs}}catch(t){throw new Error(`Failed to get available balance: ${t.message}`)}}async generateAuthHeaders(e=""){var r;if(!((r=this.walletConnection)!=null&&r.publicKey))throw new Error("No wallet connected or no public key available");const t=this.getWallet();if(!t)throw new Error("No wallet available");try{const a=this.generateNonce(),o=e+a,n=await t.createSignature({data:btoa(o),protocolID:[2,"gitdata-identity"],keyID:"identity",privilegedReason:"Authenticate API request with Gitdata platform"});return{"X-Identity-Key":this.walletConnection.publicKey,"X-Nonce":a,"X-Signature":n.signature,"Content-Type":"application/json"}}catch(a){throw new Error(`Failed to generate auth headers: ${a.message}`)}}async signData(e,t="gitdata-auth"){const r=this.getWallet();if(!r)throw new Error("No wallet connected");try{return(await r.createSignature({data:btoa(e),protocolID:[2,t],keyID:"identity",privilegedReason:"Authenticate with Gitdata platform"})).signature}catch(a){throw new Error(`Failed to sign data: ${a.message}`)}}async encryptData(e,t="gitdata-storage"){const r=this.getWallet();if(!r)throw new Error("No wallet connected");try{return(await r.encrypt({plaintext:btoa(e),protocolID:[2,t],keyID:"storage",counterparty:"self"})).ciphertext}catch(a){throw new Error(`Failed to encrypt data: ${a.message}`)}}async decryptData(e,t="gitdata-storage"){const r=this.getWallet();if(!r)throw new Error("No wallet connected");try{const a=await r.decrypt({ciphertext:e,protocolID:[2,t],keyID:"storage",counterparty:"self"});return atob(a.plaintext)}catch(a){throw new Error(`Failed to decrypt data: ${a.message}`)}}async getWalletInfo(){const e=this.getWallet();if(!e||!e.getVersion)return null;try{return await e.getVersion()}catch{return null}}async isAuthenticated(){const e=this.getWallet();if(!e)return!1;try{return e.isAuthenticated?await e.isAuthenticated():(await e.getPublicKey({identityKey:!0}),!0)}catch{return!1}}async waitForAuthentication(){const e=this.getWallet();if(!e)throw new Error("No wallet connected");try{return e.waitForAuthentication?await e.waitForAuthentication():await this.isAuthenticated()}catch(t){throw new Error(`Failed to wait for authentication: ${t.message}`)}}async getHeight(){const e=this.getWallet();if(!e)throw new Error("No wallet connected");try{if(e.getHeight)return await e.getHeight();throw new Error("Wallet does not support getHeight method")}catch(t){throw new Error(`Failed to get blockchain height: ${t.message}`)}}async getHeaderForHeight(e){const t=this.getWallet();if(!t)throw new Error("No wallet connected");try{if(t.getHeaderForHeight)return await t.getHeaderForHeight(e);throw new Error("Wallet does not support getHeaderForHeight method")}catch(r){throw new Error(`Failed to get header for height ${e}: ${r.message}`)}}async getNetwork(){const e=this.getWallet();if(!e)throw new Error("No wallet connected");try{return e.getNetwork?await e.getNetwork():"mainnet"}catch(t){throw new Error(`Failed to get network: ${t.message}`)}}async getVersion(){const e=this.getWallet();if(!e)throw new Error("No wallet connected");try{return e.getVersion?await e.getVersion():{version:"1.0.0",implementation:"Unknown BRC-100 Wallet"}}catch(t){throw new Error(`Failed to get wallet version: ${t.message}`)}}onConnectionChange(e){return this.connectionListeners.push(e),()=>{const t=this.connectionListeners.indexOf(e);t>-1&&this.connectionListeners.splice(t,1)}}async authenticateWithBackend(e,t){try{const r=await fetch("http://localhost:8787/identity/wallet/connect",{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({walletType:this.detectWalletType(e),capabilities:["sign","pay","identity"]})});if(!r.ok)throw new Error(`Failed to initialize session: ${r.statusText}`);const{sessionId:a}=await r.json(),o=this.generateNonce(),i=`wallet_verification:${a}`+o,w=await e.createSignature({data:btoa(i),protocolID:[2,"gitdata-identity"],keyID:"identity",privilegedReason:"Verify wallet ownership for Gitdata platform"}),c=await fetch("http://localhost:8787/identity/wallet/verify",{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({sessionId:a,identityKey:t,signature:w.signature,nonce:o})});if(!c.ok){const h=await c.json();throw new Error(`Authentication failed: ${h.error||c.statusText}`)}console.log("Successfully authenticated with backend identity system")}catch(r){throw console.error("Backend authentication failed:",r),new Error(`Backend authentication failed: ${r.message}`)}}detectWalletType(e){var r,a,o,n,i;const t=s();if(t){if(t.metanet||t.metaNet||t.MetaNet)return"metanet";if(((r=t.handcash)==null?void 0:r.wallet)===e)return"handcash";if(((a=t.yours)==null?void 0:a.wallet)===e)return"yours";if(((o=t.panda)==null?void 0:o.wallet)===e)return"panda";if(((n=t.moneybutton)==null?void 0:n.wallet)===e)return"moneybutton";if(((i=t.bsv)==null?void 0:i.wallet)===e)return"bsv-standard";if(t.wallet===e)return"generic"}return"unknown"}generateNonce(){const e=new Uint8Array(16);return crypto.getRandomValues(e),Array.from(e,t=>t.toString(16).padStart(2,"0")).join("")}notifyConnectionChange(e){this.connectionListeners.forEach(t=>{try{t(e)}catch(r){console.error("Error in wallet connection listener:",r)}})}async validateWallet(e){const t=["createAction","signAction","abortAction","listActions","internalizeAction","listOutputs","relinquishOutput","getPublicKey","revealCounterpartyKeyLinkage","revealSpecificKeyLinkage","encrypt","decrypt","createHmac","verifyHmac","createSignature","verifySignature","acquireCertificate","listCertificates","proveCertificate","relinquishCertificate","discoverByIdentityKey","discoverByAttributes"],r=["isAuthenticated","waitForAuthentication","getHeight","getHeaderForHeight","getNetwork","getVersion","isAvailable"];let a=0,o=0;for(const n of t)typeof e[n]!="function"&&(console.warn(`Wallet missing required BRC-100 method: ${n}`),a++);for(const n of r)typeof e[n]!="function"&&(console.info(`Wallet missing optional BRC-100 method: ${n}`),o++);console.log(`BRC-100 Validation Results:
      Required methods: ${t.length-a}/${t.length}
      Optional methods: ${r.length-o}/${r.length}
      Total compliance: ${t.length+r.length-a-o}/${t.length+r.length}`);try{return e.isAvailable&&await e.isAvailable(),a===0}catch(n){return console.warn("Wallet validation failed:",n),!1}}}const d=new g;async function y(l=""){return d.generateAuthHeaders(l)}export{y as generateAuthHeaders,d as walletService};
